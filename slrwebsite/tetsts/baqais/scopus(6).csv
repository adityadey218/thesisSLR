Authors,Author(s) ID,Title,Year,Source title,Volume,Issue,Art. No.,Page start,Page end,Page count,Cited by,DOI,Link,Abstract,Document Type,Publication Stage,Source
Firouzi E.; Sami A.,57208248547; 7004124604,"Visual studio automated refactoring tool should improve development time, but resharper led to more solution-build failures",2019,MAINT 2019 - 2019 IEEE 2nd International Workshop on Mining and Analyzing Interaction Histories,,,8666936,2,6,4,3,10.1109/MAINT.2019.8666936,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064202412&doi=10.1109%2fMAINT.2019.8666936&partnerID=40&md5=0fae858adbd9077b2b68b9b4f941a04e,"Several studies showed effectiveness of manual refactoring. Thus, automated refactoring tools in Visual Studio are expected to have positive effects on the success rate of 'Builds'. Few studies have actually investigated automated refactoring tools impact in this aspect. In addition, we have investigated test results, commits and undo changes into version control system (VCS) also. Firstly, if the number of successful compilation of session solution 'Builds' is considered as a metric, our investigation on Enriched Event Stream Dataset showed use of ReSharper has lowered the success rate of builds, introduced errors and may have increased the development time.Secondly, test error rates decreased when ReSharper tools are used aligned with previous studies on software testing. Finally, percentage of commits has significantly increased and reverts decreased on use of ReSharper. Overall, despite some positive impacts that the automated refactoring tool of Visual Studio had, our study showed that the automated suggestions and changes that ReSharper has made are not completely trustable. Our research suggests that ReSharper may not consider a global view of the solution. © 2019 IEEE.",Conference paper,Final,Scopus
Mohan M.; Greer D.; McMullan P.,57189345360; 35228903500; 7003939217,Maximizing refactoring coverage in an automated maintenance approach using multi-objective optimization,2019,"Proceedings - 2019 IEEE/ACM 3rd International Workshop on Refactoring, IWOR 2019",,,8844417,31,38,7,1,10.1109/IWoR.2019.00014,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073463574&doi=10.1109%2fIWoR.2019.00014&partnerID=40&md5=968cdd058450dad59afb35d9493f0641,"This paper describes a multi-objective genetic algorithm used to automate software refactoring. The approach is validated using a set of open source Java programs with a purpose built tool, MultiRefactor. The tool uses a metric function to measure quality in a software system and tests a second objective to measure the amount of code coverage of the applied refactorings by analyzing the code elements they have been applied to. The multi-objective setup will refactor the input program to improve its quality using the quality objective, while also maximizing the code coverage of the refactorings applied to the software. An experiment has been constructed to measure the multi-objective approach against the alternative mono-objective approach that does not use an objective to measure refactoring coverage. The two approaches are tested on six different open source Java programs. The multi-objective approach is found to give significantly better refactoring coverage scores across all inputs in a similar time, while also generating improvements in the quality scores. © 2019 IEEE.",Conference paper,Final,Scopus
Zhang J.; Han S.; Hao D.; Zhang L.; Zhang D.,36505536200; 55487844700; 23388889700; 56275778800; 55717568500,Automated refactoring of Nested-IF formulae in spreadsheets,2018,ESEC/FSE 2018 - Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering,,,,833,838,5,9,10.1145/3236024.3275532,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058285003&doi=10.1145%2f3236024.3275532&partnerID=40&md5=c0c93fcc841b6040b28ed5274c026771,"Nest-IF expressions have low readability and maintainability. This paper proposes the first exploration of the nest-if usage status against two large-scale spreadsheet corpora containing over 80,000 industry-level spreadsheets. We found the use of nested-IF expressions are surprisingly common among end users. We then present an approach to tackling this problem through automatic formula refactoring. The general idea is two-fold. First, we detect and remove logic redundancy based on the AST of a formula. Second, we identify higher-level semantics that have been represented with fragmented and scattered syntax, and reassemble the syntax using concise built-in functions. A comprehensive evaluation with over 28 million nested-IF formulae reveals that the approach is able to relieve the smell of over 90% of nested-IF formulae. © 2018 Association for Computing Machinery.",Conference paper,Final,Scopus
Kohler M.; Salvaneschi G.,56396113300; 35867883400,Automated refactoring to reactive programming,2019,"Proceedings - 2019 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019",,,8952329,835,846,11,2,10.1109/ASE.2019.00082,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078916950&doi=10.1109%2fASE.2019.00082&partnerID=40&md5=7e5ba3f4d4085c23fc504edcd049f09a,"Reactive programming languages and libraries, such as ReactiveX, have been shown to significantly improve software design and have seen important industrial adoption over the last years. Asynchronous applications-which are notoriously error-prone to implement and to maintain-greatly benefit from reactive programming because they can be defined in a declarative style, which improves code clarity and extensibility. In this paper, we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming. We propose 2Rx, a refactoring approach to automatically convert asynchronous code to reactive programming. Our evaluation on top-starred GitHub projects shows that 2Rx is effective with the most common asynchronous constructs, covering 12.7% of projects with asynchronous computations, and it can provide a refactoring for 91.7% of their occurrences. © 2019 IEEE.",Conference paper,Final,Scopus
Cao S.; Zhao Y.; Shi L.,57215353666; 36122020600; 55248604900,Software complexity reduction by automated refactoring schema,2019,"Proceedings - 2019 13th International Symposium on Theoretical Aspects of Software Engineering, TASE 2019",,,8914118,208,215,7,1,10.1109/TASE.2019.00005,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076943993&doi=10.1109%2fTASE.2019.00005&partnerID=40&md5=f93b5279cfb343f038039cd4e37e4350,"As the scale of software systems is growing rapidly, software complexity is becoming one of the main problems in software engineering. Higher complexity in software increases the potential risk and defects of software system, which makes it more difficult to analyze the correctness and improve the quality of software. In this paper, we present an automated refactoring schema to reduce the complexity of the component-based software. The main idea of our approach is to search a hierarchical software with a minimum hierarchical complexity and refactor the original software into it by reassembling several subcomponents into tightly coupled hierarchical ones. Besides, our approach can be easily adjusted to deal with some new situations, in which several types of constraints on partition of software components are given. Finally, we conduct a case study with Battery Management System (BMS) and the result demonstrates our approach can automatically and effectively reduce the structural complexity of software system. © 2019 IEEE.",Conference paper,Final,Scopus
Zhang Y.; Liu C.-G.; Zhang D.-W.; Zheng K.; Zheng Y.-J.,55816561700; 57205198637; 35303919200; 57205196717; 57205198670,Software Refactoring for Java Threads; [??Java????????????],2018,Beijing Ligong Daxue Xuebao/Transaction of Beijing Institute of Technology,38,11,,1149,1155,6,0,10.15918/j.tbit1001-0645.2018.11.008,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058997834&doi=10.15918%2fj.tbit1001-0645.2018.11.008&partnerID=40&md5=80b57bae973187fd304401168e25fd32,"Java thread mechanisms, such as Thread and Executor, are different in the thread management pattern, code and the performance. To implement the automated refactoring between different thread mechanism and help programmers to choose the right thread mechanism, an automated refactoring method was proposed for Java thread mechanism able refactoring between Thread and Executor. To test the validity of the method, an automated refactoring tool named Rethreader was developed in Eclipse JDT. In the experimentation, several programs in the Java Grande Form (JGF) were tested, including Series, Crypt, Lufact, Sparsematmult and montecarlo. The experimental results show that the Rethreader can successfully implement the automatic refactoring from Thread to Executor within 1 s. © 2018, Editorial Department of Transaction of Beijing Institute of Technology. All right reserved.",Article,Final,Scopus
Rahman M.M.; Riyadh R.R.; Khaled S.M.; Satter A.; Rahman M.R.,57212184356; 57193994052; 35435302100; 57190971473; 55976708200,"MMRUC3: A recommendation approach of move method refactoring using coupling, cohesion, and contextual similarity to enhance software design",2018,Software - Practice and Experience,48,9,,1560,1587,27,6,10.1002/spe.2591,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047658999&doi=10.1002%2fspe.2591&partnerID=40&md5=917725e95eb083675aa7168f44262761,"Placement of methods is one of the most important design activities for any object-oriented application in terms of coupling and cohesion. Due to method misplacement, the application becomes tightly coupled and loosely cohesive, reflecting inefficient design. Therefore, a feature envy code smell emerges from the application, as many methods use more features of other classes than its current class. Hence, development and maintenance time, cost, and effort are increased. To refactor the code smell and enhance the design quality, move method refactoring plays a significant role through grouping similar behaviors of methods. This is because the manual refactoring process is infeasible due to the necessity of huge time and most of the existing techniques consider only coupling-based and/or cohesion-based information of nonstatic entities (methods and attributes) for the recommendation. However, this article proposes an approach that uses contextual information, based on information retrieval techniques, along with dependency (coupling and cohesion)-based information of the application for the recommendation. In addition, the approach incorporates both static and nonstatic entities in the recommendation process. For validation, the approach is applied on seven well-known open source projects. The results of the experimental evaluation indicate that the proposed approach provides better results with an average precision of 18.91%, a recall of 69.91%, and an F-measure of 29.77% than the JDeodorant tool (a widely used eclipse plugin for refactorings). Moreover, this article establishes several relationships between the accuracy of the approach and project standards and sizes. Copyright © 2018 John Wiley & Sons, Ltd.",Article,Final,Scopus
Singh S.; Kaur S.,7407874009; 57215553685,A systematic literature review: Refactoring for disclosing code smells in object oriented software,2018,Ain Shams Engineering Journal,9,4,,2129,2151,22,53,10.1016/j.asej.2017.03.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85015808258&doi=10.1016%2fj.asej.2017.03.002&partnerID=40&md5=5c660ecb8b2ded05a6eade8de60650ca,"Context: Reusing a design pattern is not always in the favor of developers. Thus, the code starts smelling. The presence of “Code Smells” leads to more difficulties for the developers. This racket of code smells is sometimes called Anti-Patterns. Objective: The paper aimed at a systematic literature review of refactoring with respect to code smells. However the review of refactoring is done in general and the identification of code smells and anti-patterns is performed in depth. Method: A systematic literature survey has been performed on 238 research items that includes articles from leading Conferences, Workshops and premier journals, theses of researchers and book chapters. Results: Several data sets and tools for performing refactoring have been revealed under the specified research questions. Conclusion: The work done in the paper is an addition to prior systematic literature surveys. With the study of paper the attentiveness of readers about code smells and anti-patterns will be enhanced. © 2017",Article,Final,Scopus
Guggulothu T.; Moiz S.A.,57208908165; 23467539000,An Approach to Suggest Code Smell Order for Refactoring,2019,Communications in Computer and Information Science,985,,,250,260,10,8,10.1007/978-981-13-8300-7_21,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85066074957&doi=10.1007%2f978-981-13-8300-7_21&partnerID=40&md5=b852aa710e8ca62c4702e4152cf35bcc,"Code smell is an indicator of issues in source code qualities that may hinder maintenance, and evolution. Source code metrics are used to measure the quality of the code. In the literature, there are many code smells, refactoring techniques, and refactoring tools. However, a software project often contains thousands of code smells and many of them have no relation with design quality. It is a challenge for developers to decide which kind of code smell should be refactored first. We have proposed an approach that suggests a code smell order based on two aspects: (1) finding relevant metrics for each code smell dataset with the help of feature selection technique (2) analyzing the internal relation among the code smells with those relevant metrics. With this analysis, we are suggesting code smell order for developers to save their effort in the refactoring stage. The suggested order is evaluated on simple java source code. © 2019, Springer Nature Singapore Pte Ltd.",Conference paper,Final,Scopus
Wild A.; Porter B.,57204136034; 13604663600,General Program Synthesis Using Guided Corpus Generation and Automatic Refactoring,2019,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),11664 LNCS,,,89,104,15,2,10.1007/978-3-030-27455-9_7,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072869774&doi=10.1007%2f978-3-030-27455-9_7&partnerID=40&md5=1d1dde942fe44c54472194f307eaeae7,"Program synthesis aims to produce source code based on a user specification, raising the abstraction level of building systems and opening the potential for non-programmers to synthesise their own bespoke services. Both genetic programming (GP) and neural code synthesis have proposed a wide range of approaches to solving this problem, but both have limitations in generality and scope. We propose a hybrid search-based approach which combines (i) a genetic algorithm to autonomously generate a training corpus of programs centred around a set of highly abstracted hints describing interesting features; and (ii) a neural network which trains on this data and automatically refactors it towards a form which makes a more ideal use of the neural network’s representational capacity. When given an unseen program represented as a small set of input and output examples, our neural network is used to generate a rank-ordered search space of what it sees as the most promising programs; we then iterate through this list up to a given maximum search depth. Our results show that this approach is able to find up to 60% of a human-useful target set of programs that it has never seen before, including applying a clip function to the values in an array to restrict them to a given maximum, and offsetting all values in an array. © Springer Nature Switzerland AG 2019.",Conference paper,Final,Scopus
Zhao F.; Zhang L.; Zhao J.,57208513377; 55961743000; 57208515323,Research on the tools of clone code refactoring,2019,ACM International Conference Proceeding Series,,,,27,31,4,0,10.1145/3312662.3312693,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064980121&doi=10.1145%2f3312662.3312693&partnerID=40&md5=f9e4016f5208dcf240ebf2cd3ac4cbb7,"Clone code is the code fragment that is identical or similar in syntax or semantics, which has great impact on software development and maintenance. According to the large amount of clone code in software and its complex changes, researchers have proposed many methods to eliminate the harmful clone code, in which refactoring is an effective measure. In this paper, concepts of clone code and refactoring are introduced firstly. And then the main methods of current clone code refactoring are compared and analyzed, so the related tools of clone code refactoring can be elaborated and their advantages and disadvantages are summarized. At last, the shortcomings and limitations of the clone code refactoring are discussed. © 2019 Association for Computing Machinery.",Conference paper,Final,Scopus
Shen B.; Zhang W.; Zhao H.; Liang G.; Wang Q.,56609617800; 56760589600; 57219037610; 36661190100; 55515912300,Intellimerge: A refactoring-aware software merging technique,2019,Proceedings of the ACM on Programming Languages,3,OOPSLA,A170,,,,34,10.1145/3360596,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85096861183&doi=10.1145%2f3360596&partnerID=40&md5=f40742c5c4fb9a164f6d1cf2b2f59d10,"In modern software development, developers rely on version control systems like Git to collaborate in the branch-based development workflow. One downside of this workflow is the conflicts occurred when merging contributions from different developers: These conflicts are tedious and error-prone to be correctly resolved, reducing the efficiency of collaboration and introducing potential bugs. The situation becomes even worse, with the popularity of refactorings in software development and evolution, because current merging tools (usually based on the text or tree structures of source code) are unaware of refactorings. In this paper, we present IntelliMerge, a graph-based refactoring-aware merging algorithm for Java programs. We explicitly enhance this algorithm's ability in detecting and resolving refactoring-related conflicts. Through the evaluation on 1,070 merge scenarios from 10 popular open-source Java projects, we show that IntelliMerge reduces the number of merge conflicts by 58.90% comparing with GitMerge (the prevalent unstructured merging tool) and 11.84% comparing with jFSTMerge (the state-of-the-art semi-structured merging tool) without sacrificing the auto-merging precision (88.48%) and recall (90.22%). Besides, the evaluation of performance shows that IntelliMerge takes 539 milliseconds to process one merge scenario on the median, which indicates its feasibility in real-world applications. © 2019 Copyright held by the owner/author(s).",Article,Final,Scopus
Gradišnik M.; Karakati? S.; Berani? T.; Heri?ko M.; Mauša G.; Grbac T.G.,55531148400; 55772495000; 57203508230; 6603385018; 55338667600; 57202354149,The impact of refactoring on maintability of Java code: A preliminary review,2019,CEUR Workshop Proceedings,2508,,2,,,,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076458785&partnerID=40&md5=c9394985c9a562bbc1ccd438dfa6ccce,"The preservation of a proper level of software systems quality is one in the cornerstones of making software evolution easier and sustainable in the long run. A good design allows complex systems to evolve with little effort and in an economically efficient way. When design deviations are detected, refactoring techniques are applied to eliminate or at least reduce the identified flaws. A number of studies show that not all refactoring techniques contribute to improving the quality of different software systems equally. Therefore, effective approaches to measuring the impact of refactoring on software quality are required. In this study, we examine approaches to estimate the effect of applied refactoring techniques on the maintainability of Java based software systems. Since refactoring primarily affects the system's internal structure, maintainability was put in the focus of the study. We conducted a brief literature review, limiting our study on quantitative metrics. The results show that researchers use different approaches for evaluating the impact of refactoring on the observed Java based software systems. In some studies, researchers measured the effect of refactoring on the internal structure attributes measured by software metrics, e.g. C&K metric suite but the scope of our research was limited to the effects of refactoring on maintainability. In other studies, the effects of refactoring are estimated through external quality attributes, e.g. maintainability, readability, and understandability. Additionally, some researchers observed the impact of refactoring indirectly, e.g. through the defect proneness of classes of observed systems. Copyright © 2019 for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",Conference paper,Final,Scopus
Martsenyuk V.; Semenets A.,6603347161; 57205200093,On Code Refactoring for Decision Making Component Combined with the Open-Source Medical Information System,2019,Advances in Intelligent Systems and Computing,889,,,196,208,12,1,10.1007/978-3-030-03314-9_18,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058986652&doi=10.1007%2f978-3-030-03314-9_18&partnerID=40&md5=bb2d1aafa33227d89891c372103cc810,"The work is devoted to the facility of decision making for the open-source medical information systems. Our approach is based on the code refactoring of the dialog subsystem of platform of the clinical decision support system. The structure of the information model of database of the clinical decision support subsystem should be updated according to the medical information system requirements. The Model - View - Controller (MVC) based approach has to be implemented for dialog subsystem of the clinical decision support system. As an example we consider OpenMRS developer tools and corresponding software APIs. For this purpose we have developed a specialized module. When updating database structure, we have used Liquibase framework. For the implementation of MVC approach Spring and Hybernate frameworks were applied. The data exchanging formats and methods for the interaction of the OpenMRS dialog subsystem module and the Google App Engine (GAE) Decision Tree service are implemented with the help of AJAX technology through the jQuery library. Experimental research use the data of pregnant and it is aimed to the decision making about the gestational age of the birth. Prediction errors and attribute usage were analyzed. © 2019, Springer Nature Switzerland AG.",Conference paper,Final,Scopus
Singh N.K.; Aït-Ameur Y.; Méry D.,55364410000; 6602220813; 57198374387,Formal ontology driven model refactoring,2018,"Proceedings of the IEEE International Conference on Engineering of Complex Computer Systems, ICECCS",2018-December,,8595067,136,145,9,8,10.1109/ICECCS2018.2018.00022,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061399904&doi=10.1109%2fICECCS2018.2018.00022&partnerID=40&md5=0634f65b45ac4d096f0031825748b1ad,"Refactoring, successfully used in the field of programming, can be used in maintenance and restructuring of the large and complex models. In this paper, we present a novel approach for model refactoring and a set of modelling patterns that are applicable for refinement-based formal development. In order to carry out this study, we investigate the previously developed large and complex model and required ontology to develop a domain model and a refactored system model. Further, we use the Rodin tools to check the internal consistency with respect to the desired functional behaviour and the required safety properties. Our main contributions are: to develop a refactoring technique related to the correct by construction approach; to use the domain specific knowledge in a system model explicitly; to define a set of modelling patterns; and to define a restructuring mechanism in the formal development. Finally, this proposed approach is evaluated through a complex medical case study: ECG clinical assessment protocol. © 2018 IEEE.",Conference paper,Final,Scopus
Misbhauddin M.; Alshayeb M.,36662537800; 6506030177,An integrated metamodel-based approach to software model refactoring,2019,Software and Systems Modeling,18,3,,2013,2050,37,7,10.1007/s10270-017-0628-3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85032370679&doi=10.1007%2fs10270-017-0628-3&partnerID=40&md5=09cac6599d2338486df1d4ffe99e0a9c,"Software refactoring is the process of changing a software system in a manner that does not alter its external behavior and yet improving its internal structure. Model-driven architecture and the popularity of the UML enabled the application of refactoring at model level, which was earlier applied to software code. In this paper, we propose a multi-view integrated approach to model-driven refactoring using UML models. We selected a single model from each UML view at metamodel level to construct an integrated metamodel. We selected class diagram to represent the structural view, sequence diagram to represent the behavioral view and use case diagram to represent the functional view. We validated the proposed approach by comparing integrated refactoring approach with refactoring applied to models individually in terms of quality improvement through UML model metrics. Our results indicate that more bad smell instances can be detected using the integrated approach rather than the individual refactoring approach. © 2017, Springer-Verlag GmbH Germany.",Article,Final,Scopus
Techapalokul P.; Tilevich E.,57189044783; 6507251807,QIS: Automated Refactoring for Scratch,2019,"Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing, VL/HCC",2019-October,,8818906,265,266,1,2,10.1109/VLHCC.2019.8818906,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078141550&doi=10.1109%2fVLHCC.2019.8818906&partnerID=40&md5=dd27358ffd43cfed7daa4ccdf40de8b6,"Recent studies have demonstrated that the code quality of Scratch projects impacts this learning environment's educational effectiveness. For example, novice programmers are less willing to remix and continue modifying those projects whose code quality is low. This showpiece demonstrates QIS (pronounced as/ch?z/), a novice-friendly refactoring tool for Scratch 3.0. Integrated with the latest Scratch environment, QIS analyzes on-the-fly the code quality of an edited project, displaying the refactorable quality problems as actionable improvement hints. Programmers can then decide to act by carrying out the suggested refactoring to improve the quality of the project's code. QIS not only empowers novice programmers to easily and effectively improve their code, but also educates them about the benefits and importance of code quality and its improvement practices. © 2019 IEEE.",Conference paper,Final,Scopus
An K.,57203415734,Facilitating the evolutionary modifications in distributed apps via automated refactoring,2019,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),11496 LNCS,,,548,553,5,4,10.1007/978-3-030-19274-7_43,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85065488389&doi=10.1007%2f978-3-030-19274-7_43&partnerID=40&md5=f7a7b0a664a4448aa3fc9bb7adb3769f,"Actively used software applications must be changed continuously to ensure their utility, correctness, and performance. To perform these changes, programmers spend a considerable amount of time and effort pinpointing the exact locations in the code to modify, a particularly hard task for distributed applications. In distributed applications, server/middleware misconfigurations and network volatility often cause performance and correctness problems. My dissertation research puts forward a novel approach to facilitating the evolutionary modifications of distributed applications that introduces a novel automated refactoring—Client Insourcing. This refactoring transforms a distributed application into its semantically equivalent centralized variant, in which the remote parts are glued together and communicate with each other by means of regular function calls, eliminating any middleware, server, and network-related problems from the list of potential problem causes. Programmers then can use the resulting centralized variant to facilitate debugging, security enhancements, and fault-tolerance adaptations (Some of the preliminary work of this dissertation is described in a paper accepted for presentation in the main technical program of ICWE 2019 [4]). © Springer Nature Switzerland AG 2019.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Di Pompeo D.,55317293800; 6603764364; 57188727238,Performance-Driven Software Architecture Refactoring,2018,"Proceedings - 2018 IEEE 15th International Conference on Software Architecture Companion, ICSA-C 2018",,,8432081,2,3,1,3,10.1109/ICSA-C.2018.00006,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052553276&doi=10.1109%2fICSA-C.2018.00006&partnerID=40&md5=f629839e29a9852ee231c2cad0ad57d3,"Performance engineering of software architecture can be defined as the process of analyzing the performance of a software architecture and then reacting to problems emerging from such analysis by refactoring the software architecture in order to meet performance requirements. In the last decade, many approaches in this field have appeared, whereas the problem of reacting to problems by proposing and evaluating alternative solutions through architectural refactoring has been much less treated. Indeed, the introduction of automated support to refactoring becomes crucial to drive architectural evolutions that might lead to performance improvement. This tutorial is aimed at introducing notations, methodologies and tools that can be adopted for Performance-Driven Software Architecture Refactoring. © 2018 IEEE.",Conference paper,Final,Scopus
Pietsch C.; Kelter U.; Kehrer T.; Seidl C.,57172219300; 6603608144; 25960845900; 55389295800,Formal foundations for analyzing and refactoring delta-oriented model-based software product lines,2019,ACM International Conference Proceeding Series,A,,,,,,13,10.1145/3336294.3336299,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85117538879&doi=10.1145%2f3336294.3336299&partnerID=40&md5=01b056440a84879ebf35cc93346905bf,"Model-Based Software Product Line (MBSPL) Engineering combines Model-Based Software Engineering (MBSE) and Software Product Line (SPL) Engineering by specifying variability in models and generating model variants as products of an MBSPL. Delta Modeling (DM) is a transformational approach for implementing MBSPLs by adding, removing or modifying model elements through delta modules to activate individual features. To date, the applicability of DM to real-world MBSPLs is severely hindered due to the resulting complex network of interrelated delta modules in which errors are hard to identify and fix without unintentionally harming overall consistency. To address this challenge, we present a set of analyses to identify problems in a network of delta modules as well as a construction kit to assemble refactorings to remedy these problems and simplify the network. We give a modeling-language independent formalization of delta modules based on graph transformation concepts. This is the basis for our analyses which, in turn, build the basis for our refactorings to prevent unintended side-effects. © 2019 Copyright held by the owner/author(s).",Conference paper,Final,Scopus
Mokaddem C.E.; Sahraoui H.; Syriani E.,57191428653; 57196894039; 25522760800,Recommending model refactoring rules from refactoring examples,2018,"Proceedings - 21st ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS 2018",,,,257,266,9,11,10.1145/3239372.3239406,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056892342&doi=10.1145%2f3239372.3239406&partnerID=40&md5=d2aad474e0ee118e568c8d1cf9084966,"Models, like other first-class artifacts such as source code, are maintained and may be refactored to improve their quality and, consequently, one of the derived artifacts. Considering the size of the manipulated models, automatic support is necessary for refactoring tasks. When the refactoring rules are known, such a support is simply the implementation of these rules in editors. However, for less popular and proprietary modeling languages, refactoring rules are generally difficult to define. Nevertheless, their knowledge is often embedded in practical examples. In this paper, we propose an approach to recommend refactoring rules that we lean automatically from refactoring examples. The evaluation of our approach on three modeling languages shows that, in general, the learned rules are accurate. © 2018 Copyright held by the owner/author(s). Publication rights licensed to the Association for Computing Machinery.",Conference paper,Final,Scopus
Mumtaz H.; Alshayeb M.; Mahmood S.; Niazi M.,57200160465; 6506030177; 8644998900; 14045585000,A survey on UML model smells detection techniques for software refactoring,2019,Journal of Software: Evolution and Process,31,3,e2154,,,,20,10.1002/smr.2154,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063376990&doi=10.1002%2fsmr.2154&partnerID=40&md5=91ac340181675459d08c6bc86335dbfe,"Bad smells tend to have a negative impact on software by degrading its quality. It is beneficial to detect model smells to avoid their propagation to later stages of software development. The objective of this paper is to present the state-of-the-art research on techniques for detecting UML model bad smells. The detection techniques are compared and evaluated using a proposed evaluation framework. The framework consists of two parts. The first part of the framework compares the techniques in terms of the implemented approach, the investigated model, and the explored model smells, while the experimental design is explored in the second part of the framework. We found that the detection of bad smells in class and sequence diagrams is accomplished via design patterns, software metrics, and predefined rules, while model smells in use cases are detected using metrics and predefined rules. We also found that the class diagram is the most investigated UML model in the context of model smell detection, whereas there is a lack of work on other UML models. In addition, there is a scarcity of independent studies on sequence diagrams. Furthermore, the studies investigating class diagrams are mostly validated, whereas use case diagrams and sequence diagrams are rarely validated. © 2019 John Wiley & Sons, Ltd.",Review,Final,Scopus
Liu G.; Hu C.; Chen S.; Zhang Y.; Chen X.,52163967800; 57210376063; 57208589054; 55888825400; 57015781300,Refactoring Java Code for Automatic API Generation,2018,"International Conference on Cloud Computing, Big Data and Blockchain, ICCBB 2018",,,8756413,,,,0,10.1109/ICCBB.2018.8756413,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85070517557&doi=10.1109%2fICCBB.2018.8756413&partnerID=40&md5=5a6c787afecb8e3a5e1731721fa4378a,"With the development of the Internet, a large number of computer applications have emerged, and the quantity is still growing rapidly. These applications contain a lot of useful data and functions, however, as most of them are not available and couldn't interact with each other, so the data and functions are difficult to shared and reused, resulting in a huge waste of resources. In order to solve this problem, secondary development is needed on the basis of the source system. For example, it is necessary to collect data from client applications or integrate their functions. Therefore, a framework of automatic encapsulation API based on the client system is proposed in this paper. Firstly, using a design pattern to reconstruct the runtime software architecture. Secondly, an algorithm is proposed for parameter matching to automatically construct API template. Thirdly, a framework is implemented to support design patterns and matching algorithms. In conclusion, we experimented with a real client system, and the results show that in most cases our method can effectively encapsulate and reduce the execution time of the functions. © 2018 IEEE.",Conference paper,Final,Scopus
Mohan M.; Greer D.,57189345360; 35228903500,Using a many-objective approach to investigate automated refactoring,2019,Information and Software Technology,112,,,83,101,18,15,10.1016/j.infsof.2019.04.009,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064835658&doi=10.1016%2fj.infsof.2019.04.009&partnerID=40&md5=708a9904e9560028415d0c6eb446b77d,"Context: Software maintenance is expensive and so anything that can be done to reduce its cost is potentially of huge benefit. However, it is recognised that some maintenance, especially refactoring, can be automated. Given the number of possible refactorings and combinations of refactorings, a search-based approach may provide the means to optimise refactorings. Objective: This paper describes the investigation of a many-objective genetic algorithm used to automate software refactoring, implemented as a Java tool, MultiRefactor. Method: The approach and tool is evaluated using a set of open source Java programs. The tool contains four separate measures of software looking at the software quality as well as measures of code priority, refactoring coverage and element recentness. The many-objective algorithm combines the four objectives to improve the software in a holistic manner. An experiment has been constructed to compare the many-objective approach against a mono-objective approach that only uses a single objective to measure software quality. Different permutations of the objectives are also tested and compared to see how well the different objectives can work together in a multi-objective refactoring approach. The eight approaches are tested on six different open source Java programs. Results: The many-objective approach is found to give better objective scores on average than the mono-objective approach and in less time. However, the priority and element recentness objectives are both found to be less successful in multi/many-objective setups when they are used together. Conclusion: A many-objective approach is suitable and effective for optimising automated refactoring to improve quality. Including other objectives does not unduly degrade the quality improvements, but is less effective for those objectives than if they were used in a mono-objective approach. © 2019 Elsevier B.V.",Article,Final,Scopus
Rochimah S.; Gautama B.; Akbar R.J.,24476646200; 57209005594; 56437975500,Refactoring the anemic domain model using pattern of enterprise application architecture and its impact on maintainability: A case study,2019,IAENG International Journal of Computer Science,46,2,,275,290,15,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85066278598&partnerID=40&md5=632ec4afff67bb04a7e1eec1e8c3fffb,"Design pattern is a set of solutions that is used to solve software development common problems. The purpose of design pattern utilization is to improve software quality. Various design patterns have been proposed. One of them is Patterns of Enterprise Application Architecture (PoEAA) which are specified for enterprise application. However, there are lacks of literature that discuss these patterns. This research conducts a quantitative study to assess the impact of design pattern on software maintainability. We use Academic Information System of Institut Teknologi Sepuluh Nopember as a case study. It is an enterprise software which has Anemic Domain Model. We perform refactoring into the existing systems using suitable PoEAA. We measure its maintainability using C&K and three additional metrics, prior and after the refactoring process. The measurement results are then evaluated to obtain the impact. Based on the experiments, we clearly observe that PoEAA utilization could significantly restructure the anemic domain model of AIS. The maintainability is increased especially in presentation layer. PoEAA also eliminates duplicated methods in service and repository layer of the existing version of AIS. However, there are several drawbacks of the improvements. © International Association of Engineers.",Article,Final,Scopus
Kchaou M.; Khlif W.; Gargouri F.,57211218432; 35766583000; 6602113319,"Temporal, semantic and structural aspects-based transformation rules for refactoring BPMN model",2019,ICETE 2019 - Proceedings of the 16th International Joint Conference on e-Business and Telecommunications,1,,,133,144,11,4,10.5220/0007925401270138,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073016311&doi=10.5220%2f0007925401270138&partnerID=40&md5=229b4bc800e4c0203d25c76628258d0a,"Refactoring a business process model (BPM) may improve its usability (understandability, modifiability) performance, and/or ease its maintainability. So-far proposed refactoring approaches have used either refactoring which focuses on structural aspects and/or semantic information. Nevertheless, these aspects provide a partial view of the model. As we show in this paper, combining the semantic and structural aspects with the temporal aspect decreases further the complexity of a business process modelled in BPMN and enhances its performance. Our method uses a set of transformation rules. We illustrate their efficiency through well-established performance measures (temporal and cost) and structural measures (complexity). Copyright © 2019 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Vassallo C.; Grano G.; Palomba F.; Gall H.C.; Bacchelli A.,56875283500; 57191410336; 55321369000; 56223438700; 25924697100,A large-scale empirical exploration on refactoring activities in open source software projects,2019,Science of Computer Programming,180,,,1,15,14,37,10.1016/j.scico.2019.05.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85065542163&doi=10.1016%2fj.scico.2019.05.002&partnerID=40&md5=0aa675929b8fce697b1de4ff272bb33b,"Refactoring is a well-established practice that aims at improving the internal structure of a software system without changing its external behavior. Existing literature provides evidence of how and why developers perform refactoring in practice. In this paper, we continue on this line of research by performing a large-scale empirical analysis of refactoring practices in 200 open source systems. Specifically, we analyze the change history of these systems at commit level to investigate: (i)whether developers perform refactoring operations and, if so, which are more diffused and (ii)when refactoring operations are applied, and (iii)which are the main developer-oriented factors leading to refactoring. Based on our results, future research can focus on enabling automatic support for less frequent refactorings and on recommending refactorings based on the developer's workload, project's maturity and developer's commitment to the project. © 2019 Elsevier B.V.",Article,Final,Scopus
Damiani F.; Lienhardt M.; Paolini L.,8072103800; 23485786600; 6602743423,Automatic refactoring of delta-oriented SPLs to remove-free form and replace-free form,2019,International Journal on Software Tools for Technology Transfer,21,6,,691,707,16,2,10.1007/s10009-019-00534-2,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073964870&doi=10.1007%2fs10009-019-00534-2&partnerID=40&md5=c49fb8b49ad192cf773f8b42dfe0731f,"Delta-oriented programming (DOP) is a flexible transformational approach to implement software product lines (SPLs). In delta-oriented SPLs, variants are generated by applying operations contained in delta modules to a base program. These operations can add, remove or modify named elements in a program (e.g. classes, methods and fields in a Java program). This paper presents two notions of normal form for delta-oriented SPLs. Both normal forms do not contain the remove operation. Additionally, the second normal form enforces a limitation on the use of the method-modify operation. For each of the proposed normal forms an algorithm for refactoring a delta-oriented SPL into one that satisfies that normal form is described. The algorithms are formalized for a core calculus for delta-oriented SPLs of Java programs. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.",Article,Final,Scopus
Silva Freire E.S.; Passos A.F.D.O.; Sant'Anna C.; Spínola R.O.; De Mendonça Neto M.G.,57218934676; 57211267689; 17435516600; 36176546300; 7005160540,Influence of model refactoring on code debt: A replicated study,2019,ACM International Conference Proceeding Series,,,,452,456,4,0,10.1145/3350768.3350793,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073255791&doi=10.1145%2f3350768.3350793&partnerID=40&md5=676de25a34469db895b77f929d4f88b6,"Context: The term Technical Debt (TD) is associated with the effect of immature artifacts in the development of software. Although TD may incur in different stages of development, few pieces of research have addressed the relationship between TD in models and its influence on their respective source codes. Goal: To investigate the influence of model refactoring on code debt and vice-versa. Method: A replicated study was conducted considering the refactoring of a Unified Modeling Language (UML) class diagram for the removal of model smells, code issues, and code debt items. Besides, a different round-trip engineering tool was used, other than that employed in the original study. Findings: The findings of the original study were confirmed, but the usage of different engineering tools may influence the quantification of code debt. Conclusion: New replicated studies are necessary to further investigate the influence of model refactoring on code debt, considering other code issues, detection tools and class diagrams. © 2019 Association for Computing Machinery.",Conference paper,Final,Scopus
Devi U.; Kesswani N.; Sharma A.,57214544909; 56464247200; 57214355695,An efficient model for measuring maintainability from code cloning and refactoring using regression,2019,International Journal of Scientific and Technology Research,8,12,,4019,4023,4,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85077195095&partnerID=40&md5=6189fa7ec042562a4bd1d1d57fb5c981,"SPL has been developed to control variability and commonality among the system. Object Oriented paradigm suffers with the problem of Code Clones which adversely affects the software qualities especially Maintainability. Literature survey reveals that this problem persists in FOP too. As the Software Product Line expands, unknowingly lot of Code Clones is introduced in the source code. Code Clones are the codes which are repeated or duplicated in other parts of the source code as the functionality of program increases. Thus Code Clones deteriorates the performance and functionality and introduces errors which adversely affects the Software Product Lines. In the existent literature, we have found that Feat ure Oriented Programming was able to remove Object Oriented Code Clones but in effect it introduced Feature Oriented Programming related Code Clones. Till now, no such evidence has been found in the literature which has justified the occurrence of Code Clones in Delta Oriented Programming. Hence, the focus here is on the Code Clones in Feature Oriented Programming. Maintainability is an important factor which we are considering here since the more Code Clones are found in the source code for any Software Product Lines, the more difficult it becomes to maintain Software Product Lines which in turn leads to higher cost and increased lines of source code. Thus, it becomes crucial to address the code clones as the SPL evolves, since as the SPL grows, its maintainability also becomes important and cost factor can considerably be reduced if the clones are nipped at the early stages. © IJSTR 2019.",Article,Final,Scopus
Haendler T.,57163856400,A card game for learning software-refactoring principles,2019,CEUR Workshop Proceedings,2497,,,,,,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075099301&partnerID=40&md5=2b8e41a26dd9d25614b783c60212c4dd,"While software refactoring is considered important to keep a software system maintainable and extensible, it is often neglected in practice due to several reasons. Besides the associated costs, software developers often perceive refactoring as a difficult and risky activity. However, apart from textbooks that document rules and best practices for identifying bad smells and applying appropriate refactoring techniques, learning and teaching refactoring poses multiple challenges. The application of these rules and techniques to code examples requires (advanced) skills in programming as well as an adequate handling of the programming environment. These circumstances can distract the focus and set barriers to the introduction of refactoring. In this paper, we present REFACTORY, a non-digital multi-player card game for learning principles of software refactoring without the development-related complexities. In our game, the players simulate a software-development team confronted with bad code smells. The players learn to combine refactoring techniques to remove the smells and to balance costs and value of refactoring. We specify the game design and illustrate the game workflow. In addition, experiences and lessons learned from a first game-play study are presented, e.g. regarding game fun and mediation of competences. Finally, we discuss limitations and further potential for improving the game. Copyright © 2019 for this paper by its authors.",Conference paper,Final,Scopus
Alizadeh V.; Ouali M.A.; Kessentini M.; Chater M.,57193014530; 57933834400; 25653537200; 57213518683,RefBot: Intelligent software refactoring bot,2019,"Proceedings - 2019 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019",,,8952287,823,834,11,25,10.1109/ASE.2019.00081,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078915242&doi=10.1109%2fASE.2019.00081&partnerID=40&md5=71f3d519f05eda82f8ed2c59573c3c43,"The adoption of refactoring techniques for continuous integration received much less attention from the research community comparing to root-canal refactoring to fix the quality issues in the whole system. Several recent empirical studies show that developers, in practice, are applying refactoring incrementally when they are fixing bugs or adding new features. There is an urgent need for refactoring tools that can support continuous integration and some recent development processes such as DevOps that are based on rapid releases. Furthermore, several studies show that manual refactoring is expensive and existing automated refactoring tools are challenging to configure and integrate into the development pipelines with significant disruption cost. In this paper, we propose, for the first time, an intelligent software refactoring bot, called RefBot. Integrated into the version control system (e.g. GitHub), our bot continuously monitors the software repository, and it is triggered by any 'open' or 'merge' action on pull requests. The bot analyzes the files changed during that pull request to identify refactoring opportunities using a set of quality attributes then it will find the best sequence of refactorings to fix the quality issues if any. The bot recommends all these refactorings through an automatically generated pull-request. The developer can review the recommendations and their impacts in a detailed report and select the code changes that he wants to keep or ignore. After this review, the developer can close and approve the merge of the bot's pull request. We quantitatively and qualitatively evaluated the performance and effectiveness of RefBot by a survey conducted with experienced developers who used the bot on both open source and industry projects © 2019 IEEE.",Conference paper,Final,Scopus
Antezana A.S.,57210918453,TOAD: A tool for recommending auto-refactoring alternatives,2019,"Proceedings - 2019 IEEE/ACM 41st International Conference on Software Engineering: Companion, ICSE-Companion 2019",,,8802787,174,176,2,2,10.1109/ICSE-Companion.2019.00071,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071859572&doi=10.1109%2fICSE-Companion.2019.00071&partnerID=40&md5=7a9e86268fca10d7dd90097397800049,"Developers often face usability problems when trying to adopt refactoring tools. We replicate a user study to identify and categorize these problems, and we propose a tool that guides the developer to select the correct piece of code for Extract Method refactoring. Our tool works during the workflow of refactoring activities and selects candidate selections that (i) are syntactically correct and (ii) meet the necessary preconditions for Extract Method. © 2019 IEEE.",Conference paper,Final,Scopus
Xu K.; Song Z.; Chan Y.; Wang S.; Meng X.; Liu W.; Xue W.,57190284610; 35115649600; 56449920800; 57210599920; 7401629599; 57209524051; 57226077905,Refactoring and optimizing WRF model on sunway taihulight,2019,ACM International Conference Proceeding Series,,,a72,,,,5,10.1145/3337821.3337923,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071077108&doi=10.1145%2f3337821.3337923&partnerID=40&md5=d7ee4892707ccce6de6a95b0e771996b,"The Weather Research and Forecasting (WRF) Model is one of the widely-used mesoscale numerical weather prediction system and is designed for both atmospheric research and operational forecasting applications. However, it is an extremely time-consuming application: running a single simulation takes researchers days to weeks as the simulation size scales up and computing demands grow. In this paper, we port and optimize the whole WRF model to the Sunway TaihuLight supercomputer at a large scale. For the dynamic core in WRF, we present a domain-specific tool, namely, SWSLL, which is a directive-based compiler tool for the Sunway many-core architecture to convert the stencil computation into optimized parallel code. We also apply a decomposition strategy for SWSLL to improve the memory locality and decrease the number of off-chip memory accesses. For physical parameterizations, we explore the thread-level parallelization using OpenACC directives via reorganizations of data layouts and loops to achieve high performance. We present the algorithms and implementations and demonstrate the optimizations of a real-world complicated atmospheric modeling on the Sunway TaihuLight supercomputer. Evaluation results reveal that for the widely used benchmark with a horizontal resolution of 2.5 km, the speedup of 4.7 can be achieved by using the proposed algorithm and optimization strategies for the whole WRF model. In terms of strong scalability, our implementation scales well to hundreds of thousands of heterogeneous cores on Sunway TaihuLight. © 2019 ACM.",Conference paper,Final,Scopus
Moesus N.; Scholze M.; Schlesinger S.; Herber P.,57210786209; 57210792250; 57072959500; 26424642900,Automated selection of software refactorings that improve performance,2019,ICSOFT 2018 - Proceedings of the 13th International Conference on Software Technologies,,,,33,44,11,1,10.5220/0006837900330044,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071448059&doi=10.5220%2f0006837900330044&partnerID=40&md5=64383f47fa299270745d84ef7f9649f7,"Performance is a critical property of a program. While there exist refactorings that have the potential to significantly increase the performance of a program, it is hard to decide which refactorings effectively yield improvements. In this paper, we present a novel approach for the automated detection and selection of refactorings that are promising candidates to improve performance. Our key idea is to provide a heuristics that utilizes software properties determined by both static code analyses and dynamic software analyses to compile a list of concrete refactorings sorted by their assessed potential to improve performance. The expected performance improvement of a concrete refactoring depends on two factors: the execution frequency of the respective piece of code, and the effectiveness of the refactoring itself. To assess the latter, namely the general effectiveness of a given set of refactorings, we have implemented a set of micro benchmarks and measured the effect of each refactoring on computation time and memory consumption. We demonstrate the practical applicability of our overall approach with experimental results. Copyright © 2018 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Sidhu B.K.; Singh K.; Sharma N.,57201698524; 7404762931; 58378327000,A Catalogue of Model Smells and Refactoring Operations for Object-Oriented Software,2018,"Proceedings of the International Conference on Inventive Communication and Computational Technologies, ICICCT 2018",,,8473027,313,319,6,9,10.1109/ICICCT.2018.8473027,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85059866952&doi=10.1109%2fICICCT.2018.8473027&partnerID=40&md5=67b40e5e25df2edd9549abfc46f71ed2,"The advent of Model Driven Engineering has promoted software quality assurance activities to a higher level of abstraction than code, i.e. architectural models. Early quality assessment facilitates better design, reduces maintenance costs, manages requirement volatility and leads to faster software development. Less than optimal design decisions made during development and subsequent evolution introduce smells in the software. Model Refactoring uncovers smells at architectural level and transforms graphical representations of software to enhance design without affecting its observable behaviour. Focusing on object-oriented software systems, this paper presents a catalogue of smells and refactoring operations for UML class diagrams. The paper concludes by highlighting challenges in model refactoring and the potential of learning-based approach in automating the process. © 2018 IEEE.",Conference paper,Final,Scopus
Anwar H.; Pfahl D.; Srirama S.N.,57197748207; 6603033193; 14632859900,Evaluating the Impact of Code Smell Refactoring on the Energy Consumption of Android Applications,2019,"Proceedings - 45th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2019",,,8906734,82,86,4,19,10.1109/SEAA.2019.00021,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076040036&doi=10.1109%2fSEAA.2019.00021&partnerID=40&md5=9d6cb392d169ba087339d95f5d00c13b,"Energy consumption of mobile apps is receiving a lot of attention from researchers. Recent studies indicate that energy consumption of mobile devices could be lowered by improving the quality of mobile apps. Frequent refactoring is one way of achieving this goal. We explore the performance and energy impact of several common code refactorings in Android apps. Experimental results indicate that some code smell refactorings positively impact the energy consumption of Android apps. Refactoring of the code smells 'Duplicated code' and 'Type checking' reduce energy consumption by up to 10.8%. Significant reduction in energy consumption, however, does not seem to be directly related to the increase or decrease of execution time. In addition, the energy impact over permutations of code smell refactorings in the selected Android apps was small. When analyzing the order in which refactorings were made across code smell types, it turned out that some permutations resulted in a reduction and some in an increase of energy consumption for the analyzed apps. © 2019 IEEE.",Conference paper,Final,Scopus
Abadi M.; Keidar-Barner S.; Pidan D.; Veksler T.,36917927400; 22733281600; 55208123800; 15729691800,Verifying Parallel Code After Refactoring Using Equivalence Checking,2019,International Journal of Parallel Programming,47,1,,59,73,14,5,10.1007/s10766-017-0548-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040061469&doi=10.1007%2fs10766-017-0548-4&partnerID=40&md5=801b3968558375864c87b6db18aab314,"To take advantage of multi-core systems, programmers are replacing sequential software with parallel software. Software engineers often avoid writing their parallel software from scratch and prefer refactoring their legacy application, either manually or with the help of a refactoring tool. In either case, it is extremely challenging to produce correct parallel code, taking into account all synchronization issues. Furthermore, the complexity of parallel code makes its verification extremely difficult. We introduce a method for the verification of parallel code after refactoring. Our method, which is based on symbolic interpretation, leverages the original sequential code that in most cases was already tested and/or verified, and checks whether it is equivalent to the code after refactoring. The advantage of this method is that it can generically find any problem in the parallel code that does not exist in the original sequential code. As a result, it can help create higher quality and safer parallel code. © 2018, Springer Science+Business Media, LLC, part of Springer Nature.",Article,Final,Scopus
O'Neal J.; Weide K.; Dubey A.,58708265000; 15076261000; 7103176471,"Experience report: Refactoring the mesh interface in FLASH, a multiphysics software",2018,"2018 IEEE 7th World Conference on Photovoltaic Energy Conversion, WCPEC 2018 - A Joint Conference of 45th IEEE PVSC, 28th PVSEC and 34th EU PVSEC",2018-January,,8643450,511,516,5,4,10.1109/eScience.2018.00141,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85062073358&doi=10.1109%2feScience.2018.00141&partnerID=40&md5=a9ffc1ebfec0909bc67d6696a16e5851,"FLASH is a highly-configurable multiphysics software designed for solving a large class of problems that involve fluid flows and need adaptive mesh refinement (AMR). FLASH has been in existence for two decades and has undergone four major revisions. It is now undergoing its fifth major revision to deal with increasingly heterogeneous platforms. The architecture of previous versions of the code and the AMR package at its core, Paramesh, are inadequate to meet the challenges posed by heterogeneity. In this paper we describe our experience with refactoring the mesh interface of the code to work with a more modern AMR library, AMReX. The focus of the paper is the refactoring methodology and the attendant software process that we have found useful to ensure that code quality is maintained during the transition. © 2018 IEEE.",Conference paper,Final,Scopus
Baez A.; Fabelo H.; Ortega S.; Florimbi G.; Torti E.; Hernandez A.; Leporati F.; Danese G.; Callico G.M.; Sarmiento R.,57201288242; 56405568500; 57189334144; 57118346500; 56091390500; 58113500500; 55937698500; 6604051702; 56006321500; 35609452100,High-level synthesis of multiclass SVM using code refactoring to classify brain cancer from hyperspectral images,2019,Electronics (Switzerland),8,12,1494,,,,8,10.3390/electronics8121494,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85079182271&doi=10.3390%2felectronics8121494&partnerID=40&md5=1e1dd3be0cb993f6b49cbb492f11ad70,"Currently, high-level synthesis (HLS) methods and tools are a highly relevant area in the strategy of several leading companies in the field of system-on-chips (SoCs) and field programmable gate arrays (FPGAs). HLS facilitates the work of system developers, who benefit from integrated and automated design workflows, considerably reducing the design time. Although many advances have been made in this research field, there are still some uncertainties about the quality and performance of the designs generated with the use of HLS methodologies. In this paper, we propose an optimization of the HLS methodology by code refactoring using Xilinx SDSoCTM (Software-Defined System-On-Chip). Several options were analyzed for each alternative through code refactoring of a multiclass support vector machine (SVM) classifier written in C, using two different Zynq®-7000 SoC devices from Xilinx, the ZC7020 (ZedBoard) and the ZC7045 (ZC706). The classifier was evaluated using a brain cancer database of hyperspectral images. The proposed methodology not only reduces the required resources using less than 20% of the FPGA, but also reduces the power consumption ?23% compared to the full implementation. The speedup obtained of 2.86× (ZC7045) is the highest found in the literature for SVM hardware implementations. © 2019 the authors. Licensee MDPI, Basel, Switzerland.",Article,Final,Scopus
Panigrahi R.; Padhy N.; Satapathy S.C.,56417995400; 56417506600; 57203283325,Software reusability metrics estimation from the social media by using evolutionary algorithms: Refactoring prospective,2019,International Journal of Open Source Software and Processes,10,2,,21,36,15,8,10.4018/IJOSSP.2019040102,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85081712125&doi=10.4018%2fIJOSSP.2019040102&partnerID=40&md5=0cf4f946d6da3dc27075a82b5cf0ff1c,"Software expansion is rising with the help of the standard paradigm in the 21st century. The maximum contribution of software growth focuses mainly on object-oriented development methodologies. This paradigm helps the developer to develop code quickly and makes sure that the platform assists in producing a quality product. The software reusability metrics play a crucial role for software development. To overcome the scalability issues, researchers and developers both adopt a CK metrics suite to extract the software metrics to extract the features from the repositories. The main objective of this article is to extract the set of metrics from social media by using novel evolutionary techniques. Dissimilar features within this area are examined with a suitable research query that discovers the potential and extent. Copyright © 2019, IGI Global. Copying or distributing in print or electronic forms without written permission of IGI Global is prohibited.",Article,Final,Scopus
Arcelli D.; Cortellessa V.; Di Pompeo D.,55317293800; 6603764364; 57188727238,A metamodel for the specification and verification of model refactoring actions,2018,"IWoR 2018 - Proceedings of the 2nd International Workshop on Refactoring, co-located with ASE 2018",,,,14,21,7,3,10.1145/3242163.3242167,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063651170&doi=10.1145%2f3242163.3242167&partnerID=40&md5=713543cf4b15ddfa4c2f5e8df4791834,"Refactoring has become a valuable activity during the software development lifecycle, because it can be induced by different causes, like new requirements or quality improvement. In code-based development contexts this activity has been widely studied, whereas in model-driven ones, where models are first-class development entities, there are many issues yet to be tackled. In this paper we present a metamodel that supports the specification of pre- and post-conditions of model refactoring actions, and the automated derivation and verification of such conditions in specific modeling languages. Our work is aimed at helping users to implement refactoring actions in the adopted modelling language by providing an environment for guaranteeing the feasibility of refactoring actions. Our primary focus is on the definition of applicable sequences of refactoring actions, rather than on the user-driven step-by-step application of refactoring actions. As an example, we illustrate the applicability of our metamodel for UML models refactoring. © 2018 ACM.",Conference paper,Final,Scopus
Nyamawe A.S.; Liu H.; Niu Z.; Wang W.; Niu N.,57203496218; 56862404100; 23393033800; 56602035200; 36856329200,Recommending refactoring solutions based on traceability and code metrics,2018,IEEE Access,6,,8456513,49460,49475,15,20,10.1109/ACCESS.2018.2868990,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052863832&doi=10.1109%2fACCESS.2018.2868990&partnerID=40&md5=a85f2b684dddc66eabff6c63338b49db,"Software refactoring has been extensively used to rectify the design flaws and improve software quality without affecting its observable behaviors. For a given code smell, it is common that there exist multiple refactoring solutions. However, it is challenging for developers to select the best one from such potential solutions. Consequently, a number of approaches have been proposed to facilitate the selection. Such approaches compare and select among alternative refactoring solutions based on their impact on metrics of source code. However, their impact on the traceability between source code and requirements is ignored although the importance of such traceability has been well recognized. To this end, we select among alternative refactoring solutions according to how they improve the traceability as well as source code design. To quantify the quality of traceability and source code design we leverage the use of entropy-based and traditional coupling and cohesion metrics respectively. We virtually apply alternative refactoring solutions and measure their effect on the traceability and source code design. The one leading to greatest improvement is recommended. The proposed approach has been evaluated on a well-known data set. The evaluation results suggest that on up to 71% of the cases, developers prefer our recommendation to the traditional recommendation based on code metrics. © 2013 IEEE.",Article,Final,Scopus
Yue R.; Gao Z.; Meng N.; Xiong Y.; Wang X.; Morgenthaler J.D.,57200270284; 57205019764; 42161811400; 35744243000; 57196447716; 23018966700,Automatic clone recommendation for refactoring based on the present and the past,2018,"Proceedings - 2018 IEEE International Conference on Software Maintenance and Evolution, ICSME 2018",,,8530022,115,126,11,27,10.1109/ICSME.2018.00021,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058301424&doi=10.1109%2fICSME.2018.00021&partnerID=40&md5=9af25e2dba084e79ef736b21c5cfc39d,"When many clones are detected in software programs, not all clones are equally important to developers. To help developers refactor code and improve software quality, various tools were built to recommend clone-removal refactorings based on the past and the present information, such as the cohesion degree of individual clones or the co-evolution relations of clone peers. The existence of these tools inspired us to build an approach that considers as many factors as possible to more accurately recommend clones. This paper introduces CREC, a learning-based approach that recommends clones by extracting features from the current status and past history of software projects. Given a set of software repositories, CREC first automatically extracts the clone groups historically refactored (R-clones) and those not refactored (NR-clones) to construct the training set. CREC extracts 34 features to characterize the content and evolution behaviors of individual clones, as well as the spatial, syntactical, and co-change relations of clone peers. With these features, CREC trains a classifier that recommends clones for refactoring. We designed the largest feature set thus far for clone recommendation, and performed an evaluation on six large projects. The results show that our approach suggested refactorings with 83% and 76% F-scores in the within-project and cross-project settings. CREC significantly outperforms a state-of-The-Art similar approach on our data set, with the latter one achieving 70% and 50% F-scores. We also compared the effectiveness of different factors and different learning algorithms. © 2018 IEEE.",Conference paper,Final,Scopus
Holmes T.; Zdun U.,24469746000; 55908948800,Refactoring architecture models for compliance with custom requirements,2018,"Proceedings - 21st ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS 2018",,,,267,277,10,5,10.1145/3239372.3239379,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056854251&doi=10.1145%2f3239372.3239379&partnerID=40&md5=3d069ec10eda68514c596eef50d276bb,"In the process of software-intensive systems engineering, architectures need to be designed that are compliant to the requirements. For this, architects need to examine those requirements with regard to their architectural impact. Accessing and interpreting the requirements is however not always possible, for instance if custom requirements are yet unknown at the time when the architecture is modeled. Ideally, architectural knowledge as derived from custom requirements could be imposed upon architecture models. This paper proposes a novel concept for automated refactoring of architecture models in order to meet such requirements by formalizing architectural knowledge using model verification and model transformations. Industrial application within a telecommunications service provider is demonstrated in the domain of cloud application orchestration: service providers are enabled to autonomously customize solutions predefined by vendors according to their own internal requirements. © 2018 Association for Computing Machinery.",Conference paper,Final,Scopus
Pérez-Castillo R.; Fernández-Ropero M.; Piattini M.,34977424500; 54683892800; 7004203473,Business process model refactoring applying IBUPROFEN. An industrial evaluation,2019,Journal of Systems and Software,147,,,86,103,17,18,10.1016/j.jss.2018.10.012,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85054565285&doi=10.1016%2fj.jss.2018.10.012&partnerID=40&md5=79d19b9bf803f3e26ca622fcdd69e001,"Business process models are recognized as being important assets for companies, since appropriate management of them provides companies with a competitive advantage. Quality assurance of business process models has become a critical issue, especially when companies carry out reverse engineering techniques to retrieve their business process models. Thus, companies have to deal with several quality faults, such as unmeaningful elements, fine-grained granularity or incompleteness, which seriously affect understandability and modifiability of business process models. The most widely-used method to reduce these faults is refactoring. Although several refactoring operators exist in the literature, there are no refactoring techniques specially developed for business process models obtained by process mining and other reverse engineering techniques. Therefore, this paper presents the use of IBUPROFEN, a business process model refactoring technique for those models obtained by reverse engineering. IBUPROFEN is applied in an in-depth case study with a real-life information system belonging to a European bank company. The goal of this industrial evaluation is to prove that the refactoring operators improve the understandability and modifiability of the business process model after being refactored. In addition, the scalability of the technique is assessed to demonstrate the feasibility of its application. © 2018",Article,Final,Scopus
Mohan M.; Greer D.,57189345360; 35228903500,Automated Multi-objective Refactoring Based on Quality and Code Element Recentness,2019,Communications in Computer and Information Science,1023,,,334,351,17,1,10.1007/978-3-030-22559-9_15,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85069164606&doi=10.1007%2f978-3-030-22559-9_15&partnerID=40&md5=5d6715e64e702806d54d884cb31776d7,"Search-Based Software Engineering (SBSE) has been used to automate various aspects of the software development cycle. One particular case is refactoring, especially to improve software quality. However, often there are other factors that influence the refactoring process. One such factor, the recentness of the code elements, is identified in this paper as important. The paper describes the use of a multi-objective genetic algorithm to automate software refactoring based on a metric function for software quality and a second objective to measure the recentness of the code elements being refactored. The recentness measure is calculated from data on previous versions of the software. The multi-objective setup refactors the input program to improve its quality using the quality objective, while also focusing on the recentness of the code elements inspected. The approach is implemented in a tool, MultiRefactor and validated using a set of six open source Java programs. An experiment is described that compares the multi-objective approach against an alternative mono-objective approach that uses only the quality function. The results show that the multi-objective approach gives significantly better recentness scores without greatly degrading improvements in the quality score. © 2019, Springer Nature Switzerland AG.",Conference paper,Final,Scopus
Deryugina O.; Nikulchev E.; Ryadchikov I.; Sechenev S.; Shmalko E.,36805556800; 6504081534; 57193380784; 57193382639; 57194220616,Analysis of the anywalker software architecture using the UML refactoring tool,2019,Procedia Computer Science,150,,,743,750,7,3,10.1016/j.procs.2019.02.005,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064431259&doi=10.1016%2fj.procs.2019.02.005&partnerID=40&md5=c42753e5361363522e6c94619d022a34,"Refactoring (restructuring of a system, which keeps its functionality invariant) of the software can be aimed at the optimization of such characteristics as modifiability, maintainability and understandability. Model refactoring can be conducted not only at the code level, but also at the model level. According to the MDA approach models are described using the Unified Modelling Language (UML). UML class diagrams are used to specify software architecture. UML Refactoring is a software tool, which provides UML class diagram analysis and refactoring. This article proposes results of AnyWalker project UML class diagram refactoring using the UML Refactoring tool. © 2019 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY-NC-ND license (https://creativecommons.org/licenses/by-nc-nd/4.0/) Peer-review under responsibility of the scientific committee of the 13th International Symposium “Intelligent Systems” (INTELS'18).",Conference paper,Final,Scopus
Lin B.; Nagy C.; Bavota G.; Lanza M.,57195074521; 26667913000; 57220148228; 56760055000,On the Impact of Refactoring Operations on Code Naturalness,2019,"SANER 2019 - Proceedings of the 2019 IEEE 26th International Conference on Software Analysis, Evolution, and Reengineering",,,8667992,594,598,4,13,10.1109/SANER.2019.8667992,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064175154&doi=10.1109%2fSANER.2019.8667992&partnerID=40&md5=4e1a1fd86eaede0120a167a1338ee866,"Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. Also, previous studies suggested the existence of a relationship between code quality and its naturalness, presenting empirical evidence showing that buggy code is 'less natural' than non-buggy code. We conjecture that this qualitynaturalness relationship could be exploited to support refactoring activities (e.g., to locate source code areas in need of refactoring). We perform a first step in this direction by analyzing whether refactoring can improve the naturalness of code. We use state-of-The-Art tools to mine a large dataset of refactoring operations performed in open source systems. Then, we investigate the impact of different types of refactoring operations on the naturalness of the impacted code. We found that (i) code refactoring does not necessarily increase the naturalness of the refactored code; and (ii) the impact on the code naturalness strongly depends on the type of refactoring operations. © 2019 IEEE.",Conference paper,Final,Scopus
Haendler T.; Neumann G.,57163856400; 7202631028,A framework for the assessment and training of software refactoring competences,2019,"IC3K 2019 - Proceedings of the 11th International Joint Conference on Knowledge Discovery, Knowledge Engineering and Knowledge Management",3,,,307,316,9,6,10.5220/0008350803070316,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85074176822&doi=10.5220%2f0008350803070316&partnerID=40&md5=6be41f451e278b108b84c73024187255,"Long-living software systems are becoming increasingly complex and difficult to maintain. Software refactoring is considered important to achieve maintainability and extensibility of a software system over time. In practice, it is still often neglected, partly because of costs, the perceived risks of collateral damage and difficulties of individuals working on certain components of complex software. It is therefore important for software projects that software developers have the appropriate skills and competences to efficiently perform software refactoring. However, so far there is no systematization of competences in software refactoring to guide in the assessment or training of competences, e.g., for planning or evaluating training activities and paths. In this paper, we address this need by presenting a competence framework for software refactoring by applying Bloom's revised taxonomy for educational objectives. In particular, we specify competence levels by combining knowledge and cognitive-process dimensions. Via a case study with two existing training environments (i.e. a tutoring system and a serious game), we demonstrate by example that the framework can support (1) in analyzing the competence levels addressed by the training environments and (2) in reflecting training paths for software refactoring. Finally, we discuss the limitations and the further potential of the framework. Copyright © 2019 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Othman Z.S.; Kaya M.,57203226988; 55515553000,Refactoring code clone detection,2019,"7th International Symposium on Digital Forensics and Security, ISDFS 2019",,,8757479,,,,0,10.1109/ISDFS.2019.8757479,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85070504428&doi=10.1109%2fISDFS.2019.8757479&partnerID=40&md5=678556e1e546d3d7e6101ad87fc65ec6,"Refactoring duplicate code is an important issue and is one of the most important smells in software maintenance. There is an important relationship between clones and code quality. Most programmers use clones because they are cheaper and faster than typing the program code. A cloning code is created by copying and pasting the existing code fragments of the source code with or without slight modifications. A major part (5% to 10%) of the source code for large computer programs consists of copy codes. Since cloning is believed to reduce the possibility of software maintenance, many techniques and cloning detection tools have been recommended for this purpose. The basic goal of clone detection is to identify the clone code and replace it with a single call to the function, where the function simulates the behavior of one instance of the clone group. This research provides an overview of the refactoring IDE. The aspects of cloning and detection of cloning are explained. In the copy detection algorithm, the source code is created in XML format. © 2018 IEEE.",Conference paper,Final,Scopus
Liu Y.; An K.; Tilevich E.,57204051928; 57203415734; 6507251807,RT-Trust: Automated refactoring for trusted execution under real-time constraints,2018,"GPCE 2018 - Proceedings of the 17th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences, co-located with SPLASH 2018",,,,175,187,12,12,10.1145/3278122.3278137,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85059043099&doi=10.1145%2f3278122.3278137&partnerID=40&md5=284fc5e9cb7ea29c8629d81f7ab55357,"Real-time systems must meet strict timeliness requirements. These systems also often need to protect their critical program information (CPI) from adversarial interference and intellectual property theft. Trusted execution environments (TEE) execute CPI tasks on a special-purpose processor, thus providing hardware protection. However, adapting a system written to execute in environments without TEE requires partitioning the code into the regular and trusted parts. This process involves complex manual program transformations that are not only laborious and intellectually tiresome, but also hard to validate and verify for the adherence to real-time constraints. To address these problems, this paper presents novel program analyses and transformation techniques, accessible to the developer via a declarative meta-programming model. The developer declaratively specifies the CPI portion of the system. A custom static analysis checks CPI specifications for validity, while probe-based profiling helps identify whether the transformed system would continue to meet the original real-time constraints, with a feedback loop suggesting how to modify the code, so its CPI can be isolated. Finally, an automated refactoring isolates the CPI portion for TEE-based execution, communicated with through generated calls to the TEE API. We have evaluated our approach by successfully enabling the trusted execution of the CPI portions of several microbenchmarks and a drone autopilot. Our approach shows the promise of declarative meta-programming in reducing the programmer effort required to adapt systems for trusted execution under real-time constraints. © 2018 Association for Computing Machinery.",Conference paper,Final,Scopus
Kim J.; Batory D.; Gligoric M.,54397162600; 7004911762; 26221765900,Code transformation issues in move-instance-method refactorings,2019,"Proceedings - 2019 IEEE/ACM 3rd International Workshop on Refactoring, IWOR 2019",,,8844413,17,22,5,3,10.1109/IWoR.2019.00011,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073428569&doi=10.1109%2fIWoR.2019.00011&partnerID=40&md5=a11687608e38d032336fb821958f786a,"Refactorings, by definition, preserve the behavior of a target program. Such a strong semantic property is encoded by a set of preconditions for each refactoring. Only if all preconditions are satisfied will a target program be transformed. The code transformation that implements the refactoring follows another set of rules to produce syntactically-correct, refactored code. Consequently, it is easy to believe that most behavior-changing violations in refactorings are induced by incorrect preconditions or lack of required checks. In this paper, however, we show that code transformations for Move-Instance-Method Refactoring available in several popular Java Integrated Development Environments do not preserve program behavior. We report these errors and propose solutions for each identified problem. © 2019 IEEE.",Conference paper,Final,Scopus
Nakagawa T.; Higo Y.; Matsumoto J.; Kusumoto S.,57214088239; 7004831134; 57202892758; 7102741360,How Compact Will My System Be? A Fully-Automated Way to Calculate LoC Reduced by Clone Refactoring,2019,"Proceedings - Asia-Pacific Software Engineering Conference, APSEC",2019-December,,8945738,284,291,7,2,10.1109/APSEC48747.2019.00046,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078099743&doi=10.1109%2fAPSEC48747.2019.00046&partnerID=40&md5=894fadf5d9c8a85b37e53eecbbaea55f,"A code clone (in short, clone) is a code fragment that is identical or similar to other code fragments in source code. The presence of clone is known as bad smell, which is phenomena of source code to be refactored. A motivation of refactoring (merging) clones is to reduce the size of source code. An existing study proposed a technique to estimate reduced lines of code by merging clones; however, there are two issues in the existing technique: (1) the existing technique does not consider the refactorability of clones in spite that it is difficult or even impossible to merge some clones due to the limitation of programming languages; (2) in the case that multiple clones are overlapping, the existing technique only considers one of them can be merged. Due to the above issues, estimated reducible LoC is occasionally different from the actual number. Consequently, in this research, we propose a new technique to calculate a reducible LoC. The proposed technique is free from the two issues, and it calculates a reducible LoC fully automatically. The proposed technique performs a loop processing of (a) detecting clones, (b) merging them, (c) compiling the edited source files, and (d) testing them. After finishing the loop, reducible LoC is calculated from the edited source files. This paper also includes comparison results of the proposed technique and the existing one. In the comparisons, we confirmed that a reducible LoC which was calculated with considering refactorability is 25% of a reducible LoC which was estimated without considering refactorability. We also confirmed that the proposed technique was able to merge clones that were not counted in the existing technique. © 2019 IEEE.",Conference paper,Final,Scopus
Moesus N.; Scholze M.; Schlesinger S.; Herber P.,57210786209; 57210792250; 57072959500; 26424642900,A Rating Tool for the Automated Selection of Software Refactorings that Remove Antipatterns to Improve Performance and Stability,2019,Communications in Computer and Information Science,1077,,,28,54,26,1,10.1007/978-3-030-29157-0_2,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071681750&doi=10.1007%2f978-3-030-29157-0_2&partnerID=40&md5=f9c232f7ab5a63efcd5557485709f957,"Antipatterns are known to be bad solutions for recurring design problems. To detect and remove antipatterns has proven to be a useful mean to improve the quality of software. While there exist several approaches to detect antipatterns automatically, existing work on antipattern detection often does not solve the detected design problems automatically. Although there exist refactorings that have the potential to significantly increase the quality of a program, it is hard to decide which refactorings effectively yield improvements with respect to performance and stability. In this paper, we present a rating tool that makes use of static antipattern detection together with software profiling for the automated selection of refactorings that remove antipatterns and are promising candidates to improve performance and stability. Our key idea is to extend a previously proposed heuristics that utilizes software properties determined by both static code analyses and dynamic software analyses to compile a list of concrete refactorings sorted by their assessed potential to improve performance with an approach to identify refactorings that may improve stability. We do not impose an order on the refactorings that may improve stability. We demonstrate the practical applicability of our overall approach with experimental results. © 2019, Springer Nature Switzerland AG.",Conference paper,Final,Scopus
Zhao J.; Zhang M.; Yang H.,55516416900; 57208130416; 35070638900,Code refactoring from openmp to mapreduce model for big data processing,2019,"Proceedings - 2019 IEEE SmartWorld, Ubiquitous Intelligence and Computing, Advanced and Trusted Computing, Scalable Computing and Communications, Internet of People and Smart City Innovation, SmartWorld/UIC/ATC/SCALCOM/IOP/SCI 2019",,,9060346,930,935,5,4,10.1109/SmartWorld-UIC-ATC-SCALCOM-IOP-SCI.2019.00186,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85083582100&doi=10.1109%2fSmartWorld-UIC-ATC-SCALCOM-IOP-SCI.2019.00186&partnerID=40&md5=15b7eae1c54c97e8ba02e637318ab999,"In the multi-core era, much software has been developed using parallel programming technology, such as OpenMP, to take full advantage of the CPU cores. Nevertheless, in the era of big data, ubiquitous systems have enabled data collection on an unprecedented scale, the existing computing power and storage capacity can no longer effectively satisfy the needs of big data processing. MapReduce is a parallel programming model in cloud computing, which provides a new way to cope with the problem of OpenMP program's resource limitations for processing big data. In order to enable the legacy OpenMP-based program to take advantage of the virtue of cloud computing for processing big data, it is worth studying how to refactor it into MapReduce model. A detailed approach for refactoring OpenMP to MapReduce is proposed, and a prototype tool O2MR was developed in this paper. Two experiments show that the refactoring approach is efficient and the tool is helpful to refactoring process. In addition, the program execution times before and after refactoring were compared by five data sets, and the results demonstrate that the refactored program has better performance than the original in the face of big data, and the performance of the refactored program will be better as the amount of data increases. © 2019 IEEE.",Conference paper,Final,Scopus
Jaradat A.; Qusef A.,57215665312; 36675659700,Automatic recovery of unit tests after code refactoring,2019,"Proceedings - 2019 International Arab Conference on Information Technology, ACIT 2019",,,8990974,202,208,6,2,10.1109/ACIT47987.2019.8990974,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85081595108&doi=10.1109%2fACIT47987.2019.8990974&partnerID=40&md5=0e2a485dcb4aac52b3b32ad4811117eb,"Unit testing allows developers to refactor their code confidently, these tests act as a safety net against producing bugs and provide immediate feedback during the refactoring process and furthermore help developers overcome the fear of change. When performing refactoring, the design of code is changed or restructured according to a predefined plan, after refactoring is applied, the alignment between source code and its corresponding unit tests could be broken which creates a problem that needs to be solved.This paper introduces an approach in which code refactoring can maintain the integrity of the previous unit tests; the tool called GreenRef demonstrates this work. This tool supports an automatic recovery for the unit tests after performing of three particular refactoring types for Java programming language: Rename Method, Add Parameter and Remove Parameter.The achieved results indicate that GreenRef facilitates consistent use of refactoring and unit tests, and save about 43% of the time required to recover broken unit tests manually. © 2019 IEEE.",Conference paper,Final,Scopus
Longo M.; Rodriguez A.; Mateos C.; Zunino A.,57188561320; 56972631600; 24171844000; 8688799600,Reducing energy usage in resource-intensive java-based scientific applications via micro-benchmark based code refactorings,2019,Computer Science and Information Systems,16,2,,541,561,20,4,10.2298/CSIS180608009L,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071275038&doi=10.2298%2fCSIS180608009L&partnerID=40&md5=f3be937816bc4495c4474cb8f7a0f862,"In-silico research has grown considerably. Today’s scientific code involves long-running computer simulations and hence powerful computing infrastructures are needed. Traditionally, research in high-performance computing has focused on executing code as fast as possible, while energy has been recently recognized as another goal to consider. Yet, energy-driven research has mostly focused on the hardware and middleware layers, but few efforts target the application level, where many energy-aware optimizations are possible. We revisit a catalog of Java primitives commonly used in OO scientific programming, or micro-benchmarks, to identify energy-friendly versions of the same primitive. We then apply the micro-benchmarks to classical scientific application kernels and machine learning algorithms for both single-thread and multi-thread implementations on a server. Energy usage reductions at the micro-benchmark level are substantial, while for applications obtained reductions range from 3.90% to 99.18%. © 2019, ComSIS Consortium. All rights reserved.",Article,Final,Scopus
Vedurada J.; Krishna Nandivada V.,57195278189; 57215270284,Identifying refactoring opportunities for replacing type code with subclass and state,2018,Proceedings of the ACM on Programming Languages,2,OOPSLA,138,,,,5,10.1145/3276508,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85080365668&doi=10.1145%2f3276508&partnerID=40&md5=0eecd7a7bc7bf488cbc7c481f841f77f,"Code with Subclass and State JYOTHI VEDURADA, IIT Madras, India V. KRISHNA NANDIVADA, IIT Madras, India 138 Refactoring is a program transformation that restructures existing code without altering its behaviour and is a key practice in popular software design movements, such as Agile. Identification of potential refactoring opportunities is an important step in the refactoring process. In large systems, manual identification of useful refactoring opportunities requires a lot of effort and time. Hence, there is a need for automatic identification of refactoring opportunities. However, this problem has not been addressed well for many non-trivial refactorings. Two such non-trivial, yet popular refactorings are ?Replace Type Code with Subclass"" (SC) and ?Replace Type Code with State"" (ST) refactorings. In this paper, we present new approaches to identify SC and ST refactoring opportunities. Our proposed approach is based around the notion of control-fields. A control-field is a field of a class that exposes the different underlying behaviors of the class. Each control-field can lead to a possible SC/ST refactoring of the associated/interacting classes. We first present a formal definition of control-fields and then present algorithms to identify and prune them; each of these pruned control-fields represents a refactoring opportunity. Further, we present a novel flow- and context-sensitive analysis to classify each of these refactoring opportunities into one of the SC and ST opportunities. We have implemented our proposed approach in a tool called Auto-SCST, and demonstrated its effectiveness by evaluating it against eight open-source Java applications. © 2018 Copyright held by the owner/author(s).",Article,Final,Scopus
Dao T.-H.; Nguyen X.-T.; Truong N.-T.,58334381300; 55610976800; 12753859100,Preservation of Class Invariants in Refactoring UML Models,2019,International Journal of Software Engineering and Knowledge Engineering,29,2,,221,244,23,0,10.1142/S0218194019500104,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85062349658&doi=10.1142%2fS0218194019500104&partnerID=40&md5=ba9cd74d3a9109c11af10e3f08331826,"In the field of software engineering, the term class invariants is known as a valuable term employed to delineate the semantic of UML class diagram elements (attributes and relationships) and must be held throughout the life-time of instances of the class. Refactoring, the activities of re-distributing classes, attributes and methods across the class hierarchy, is a powerful technique that is used to improve the quality of software systems. Performing refactoring on UML class diagrams obviously requires a special investigation of invariant-preserving on the refactored models. In this paper, we propose an approach to preserve class invariants in refactoring UML models. In order to achieve this aim, we first formalize the class diagram along with class invariants by mathematical notations. We then constitute the rules for five refactoring operations (deal with class hierarchies) in such a way to guarantee class invariants as well as proving correctness of the refactoring rules. Finally, the paper also makes provision of the proposed approach for practical applications in software re-engineering development process. © 2019 World Scientific Publishing Company.",Article,Final,Scopus
Volanschi N.,18038683000,Stereo: Editing clones refactored as code generators,2018,"Proceedings - 2018 IEEE International Conference on Software Maintenance and Evolution, ICSME 2018",,,8530072,595,604,9,1,10.1109/ICSME.2018.00069,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058331140&doi=10.1109%2fICSME.2018.00069&partnerID=40&md5=b1d2237701b653b55d74500c805ea2b0,"Clone detection is a largely mature technology able to detect many code duplications, also called clones, in software systems of practically any size. The classic approaches to clone management are either clone removal, which consists in refactoring clones as an available language abstraction, or clone tracking, using a so-called linked editor, able to propagate changes between clone instances. However, past studies have shown that clone removal is not always feasible due to the limited expressiveness of language abstractions, or not desirable because of the abstraction overhead or the risks inherent to the refactoring. Linked editors, on the other hand, provide costless abstraction at no risk, but have their own issues, such as limited expressiveness, scalability, and controllability. This paper presents a new approach in which clones are safely refactored as code generators, but the unmodified code is presented to the maintainers with the same look-And-feel as in a linked editor. This solution has good expressiveness, scalability, and controllability properties. A prototype such editor is presented along with a first application within an industrial project. © 2018 IEEE.",Conference paper,Final,Scopus
Botelho G.; Bezerra L.; Britto A.; Silva L.,56712504000; 37078903900; 55369544800; 8396257100,A Many-Objective Estimation Distributed Algorithm Applied to Search Based Software Refactoring,2018,"2018 IEEE Congress on Evolutionary Computation, CEC 2018 - Proceedings",,,8477896,,,,2,10.1109/CEC.2018.8477896,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056255603&doi=10.1109%2fCEC.2018.8477896&partnerID=40&md5=525a2b545098b05b1c1ae884ea58de4e,"Refactoring is a modification in the internal structure of software, in order to improve quality, understandability and maintainability, without changing its observable behavior. Search Based Software Refactoring (SBSR) deals with automatic software refactoring processes using optimization algorithms. In this context, here we investigate the problem of finding a sequence of refactorings that provides code improvement, according to software quality attributes, expressed by a combination of software metrics. There are multiple criteria to define the quality of a solution, therefore this problem is defined as a Many-Objective Combinatorial Optimization Problem. There is a lack of works that focus on Many-Objective Discrete Problems in SBSR. In this direction, this work proposes a Many-Objective Estimation Distributed Algorithm to find a sequence of refactorings on an object-oriented software. The algorithm explores archiving methods and probabilistic models. A set of experiments is performed, with the aim of investigating which is the best algorithm configuration, regarding the probabilistic model and selection procedure. © 2018 IEEE.",Conference paper,Final,Scopus
Blouin A.; Lelli V.; Baudry B.; Coulon F.,23134699800; 55843279500; 57203847520; 57202487052,User interface design smell: Automatic detection and refactoring of Blob listeners,2018,Information and Software Technology,102,,,49,64,15,6,10.1016/j.infsof.2018.05.005,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047814624&doi=10.1016%2fj.infsof.2018.05.005&partnerID=40&md5=35794f43a62dd07e1c60ec23981fc65c,"Context. User Interfaces (UIs) intensively rely on event-driven programming: interactive objects send UI events, which capture users’ interactions, to dedicated objects called controllers. Controllers use several UI listeners that handle these events to produce UI commands. Objective. First, we reveal the presence of design smells in the code that describes and controls UIs. Second, we demonstrate that specific code analyses are necessary to analyze and refactor UI code, because of its coupling with the rest of the code. Method. We conducted an empirical study on four large Java software systems. We studied to what extent the number of UI commands that a UI listener can produce has an impact on the change- and fault-proneness of the UI listener code. We developed a static code analysis for detecting UI commands in the code. Results. We identified a new type of design smell, called Blob listener, that characterizes UI listeners that can produce more than two UI commands. We proposed a systematic static code analysis procedure that searches for Blob listener that we implement in InspectorGuidget. We conducted experiments on the four software systems for which we manually identified 53 instances of Blob listener. InspectorGuidget successfully detected 52 Blob listeners out of 53. The results exhibit a precision of 81.25% and a recall of 98.11%. We then developed a semi-automatically and behavior-preserving refactoring process to remove Blob listeners. 49.06% of the 53 Blob listeners were automatically refactored. Patches have been accepted and merged. Discussions with developers of the four software systems assess the relevance of the Blob listener. Conclusion. This work shows that UI code also suffers from design smells that have to be identified and characterized. We argue that studies have to be conducted to find other UI design smells and tools that analyze UI code must be developed. © 2018 Elsevier B.V.",Article,Final,Scopus
Malathi S.; Sudhakar P.,57195331995; 58760104000,Implementation of Software Refactoring Using FODA Tool,2018,"Proceedings of the 3rd International Conference on Communication and Electronics Systems, ICCES 2018",,,8723986,839,842,3,0,10.1109/CESYS.2018.8723986,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85067508463&doi=10.1109%2fCESYS.2018.8723986&partnerID=40&md5=ba21ea575980bfbffb3bd985f75257a2,"Enhancing software maintenance productivity is very important in the modern information society, which demands for software surges. In this paper propose Feature Oriented Domain Analysis (FODA) tool support is necessary to enhance productivity of software. Especially, a refactoring tool that can alter the internal system in such a way that, it does not alter the external behavior of the code which improves the internal structure. New developed FODA tool for refactoring the text editor that is Notepad++. FODA tool is used to support software refactoring for improving quality of the software. We can reuse after refactoring the software. The developers can easily access and handle source code. The implementation method of software refactoring using FODA tool is discussed in this paper and also realizes the refactoring in simple application software that is text editor in Notepad++. Refactoring is also applicable to Automobiles spare parts. © 2018 IEEE.",Conference paper,Final,Scopus
Baars S.; Oprescu A.,57210634519; 23392924800,Towards automated refactoring of code clones in object-oriented programming languages,2019,CEUR Workshop Proceedings,2510,,,,,,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076470050&partnerID=40&md5=c588070463d45d28eb156e437c3c0526,"Duplication in source code can have a major negative impact on the maintainability of source code, as it creates implicit dependencies between fragments of code. Such implicit dependencies often cause bugs and increase maintenance efforts. In this study, we look into the opportunities to automatically refactor these duplication problems for object-oriented programming languages. We propose a method to detect clones that are suitable for refactoring. This method focuses on the context and scope of clones, ensuring our refactoring improves the design and does not create side effects. Our intermediate results indicate that more than half of the duplication in code is related to each other through inheritance, making it easier to refactor these clones in a clean way. About 40 percent of the duplication can be refactored through method extraction, while other clones require other refactoring techniques or further transformations. Future measurements will provide further insight into what clones should be refactored to improve the design of software systems. Copyright © 2019 for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).",Conference paper,Final,Scopus
Haendler T.; Neumann G.,57163856400; 7202631028,Ontology-based analysis of game designs for software refactoring,2019,CSEDU 2019 - Proceedings of the 11th International Conference on Computer Supported Education,1,,,24,35,11,6,10.5220/0007878300240035,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85067130623&doi=10.5220%2f0007878300240035&partnerID=40&md5=fa7e8ebdac0ebee4b55ec1d9047ffc9a,"Acquiring practical competences in computer programming and software engineering is challenging. Software refactoring, in particular, is considered an important and useful quality-assurance technique, but due to the perceived difficulties and risks of performing it, often neglected in practice. Still, it received little attention by software engineering education and training so far. Games are a popular means for fostering motivation as well as mediating and improving practical competences by providing an enjoyable and playful environment. However, for instructors it is challenging to develop and apply game designs that address certain learning objectives, which is important for integrating the game into existing or planned learning and training paths, e.g., in the framework of university courses or training units for (experienced) software developers. In this paper, we propose an ontology that aims to support the analysis and design of games in the field of software refactoring. We apply a structured process for creating a unifying domain ontology bridging core concepts from three related fields, i.e. game design (a), software refactoring (b), and competence management (c). The resulting ontology is then represented as a meta-model in terms of a UML class diagram and reflects concepts important for refactoring-game designs. We describe ontology-based options for game design and illustrate the use of the ontology by analyzing existing refactoring-gaming approaches. In addition, we reflect applying the ontology for reasoning about novel game designs and discuss further potential of the approach. Copyright © 2019 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved.",Conference paper,Final,Scopus
Regulwar G.B.; Tugnayat R.M.,36667447900; 36070007400,Detection of bad smell code for software refactoring,2019,Lecture Notes in Networks and Systems,32,,,143,152,9,2,10.1007/978-981-10-8201-6_16,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061716371&doi=10.1007%2f978-981-10-8201-6_16&partnerID=40&md5=d66eb9230fe5989ffdcd0a69d3d82ea4,"Software refactoring is the process that requires modification in the source code to avoid bad smell. Professional has reviewed typical situations that may need refactoring call it bad smells, indicating that a few piece of the existing code stink dreadful. Bad smells are linked to consequent refactoring policy that can aid dismissing bad smells. Code smell is indication which representing some part is incorrect. It shows that code supposed to refractor or overall design should reconsider. Important is, where to refractor within in existing software is somewhat challenge to recognize region of bad design. Bad design is branded as “bad smells” in existing code. The detection of bad smell code can be done by parsing the particular code and store the related data in database, to detect the bad smell code, display result and provide solution. © Springer Nature Singapore Pte Ltd 2019.",Book chapter,Final,Scopus
Ikhsan I.N.; Catur Candra M.Z.,57208839337; 55846200400,Automatically: An Automated Refactoring Method and Tool for Improving Web Accessibility,2018,"Proceedings of 2018 5th International Conference on Data and Software Engineering, ICoDSE 2018",,,8705894,,,,6,10.1109/ICODSE.2018.8705894,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85065916071&doi=10.1109%2fICODSE.2018.8705894&partnerID=40&md5=83b2b020ef81e7212e7c2f58001b6717,"Website is one of the major sources of information today and should be accessible to everyone including people with disabilities. Web accessibility becomes an important aspect of accessing a web that is set in the Web Content Accessibility Guidelines (WCAG) standard. However, so many websites that have not implemented the WCAG standard. Some of the reasons are the length of time to learn about it and difficult to understand. Therefore, many studies have been done to improve this web accessibility. The solution offered by previous researchers still uses manual code fixes. The problem that arises is time-consuming code changes because there are many web pages need to fix. The automated refactoring method is believed to be able to solve the problem. We develop a method and tool that can improve web accessibility automatically (automated refactoring), also improve the accessibility faster than refactoring manually. The implementation of Automatically is done by modifying the existing automated evaluation tool, namely HTML Code Sniffer and implementing 40 techniques from WCAG standard that can be automated. From the functional testing performed, 5 websites chosen to be tested successfully to reduce errors in the source code. Comparison of manual refactoring methods and Automatically tools is also conducted to 5 websites. Total changes or parameters performed using manual refactoring is more than using Automatically. It can be concluded that the tool is able to increase web accessibility automatically and successfully improve the web faster than manual refactoring. © 2018 IEEE.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; D'Emidio M.; Di Pompeo D.,55317293800; 6603764364; 57207254487; 57188727238,EASIER: An Evolutionary Approach for Multi-objective Software ArchItecturE Refactoring,2018,"Proceedings - 2018 IEEE 15th International Conference on Software Architecture, ICSA 2018",,,8417143,105,114,9,15,10.1109/ICSA.2018.00020,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051139603&doi=10.1109%2fICSA.2018.00020&partnerID=40&md5=94f5a4bc0dadfc3488e9e009b1784a61,"Multi-objective optimization has demonstrated, in the last few years, to be an effective paradigm to tackle different architectural problems, such as service selection, composition and deployment. In particular, multi-objective approaches for searching architectural configurations that optimize quality properties (such as performance, reliability and cost) have been introduced in the last decade. However, a relevant amount of complexity is introduced in this context when performance are considered, often due to expensive iterative generation of performance models and interpretation of results. In this paper we introduce EASIER (Evolutionary Approach for multi-objective Software archItecturE Refactoring), that is an approach for optimizing architecture refactoring based on performance and on the intensity of changes. We focus on the actionable aspects of architectural optimization, instead of merely searching over a set of alternatives. We also start to investigate on the potential influence of performance antipatterns on such process. We have implemented our approach on AEmilia ADL, so to carry out performance analysis and architecture refactoring within the same environment. We demonstrate the effectiveness and applicability of our approach through its experimentation on a case study. © 2018 IEEE.",Conference paper,Final,Scopus
Haendler T.; Neumann G.; Smirnov F.,57163856400; 7202631028; 57209270114,An interactive tutoring system for training software refactoring,2019,CSEDU 2019 - Proceedings of the 11th International Conference on Computer Supported Education,2,,,177,188,11,6,10.5220/0007801101770188,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85067112894&doi=10.5220%2f0007801101770188&partnerID=40&md5=31db5ff2bdca9336407aa7804ba63642,"Although considered useful and important, software refactoring is often neglected in practice because of the perceived risks and difficulties of performing it. A way to address these challenges can be seen in promoting developers’ practical competences. In this paper, we propose an approach for an interactive training environment for addressing practical competences in software refactoring. In particular, we present a tutoring system that provides interactive feedback to the users (e.g., university students or software developers) regarding the software-design quality and the functional correctness of the (modified) source code. After each code modification (refactoring step), the user can review the results of run-time regression tests and compare the actual software design (as-is) with the targeted design (to-be) in order to check quality improvement. For this purpose, structural and behavioral diagrams of the Unified Modeling Language (UML2) representing the as-is software design are automatically reverse-engineered from source code. The to-be design diagrams (also in UML) can be pre-specified by the instructor. We illustrate the usability of the approach for training competences in refactoring via short application scenarios and describe exemplary learning paths. Moreover, we provide a web-based software-technical implementation in Java (called refacTutor) to demonstrate the technical feasibility of the approach. Finally, limitations and further potential of the approach are discussed. Copyright © 2019 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved.",Conference paper,Final,Scopus
Wyrich M.; Bogner J.,57197756646; 57189261793,Towards an autonomous bot for automatic source code refactoring,2019,"Proceedings - 2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering, BotSE 2019",,,8823629,24,28,4,45,10.1109/BotSE.2019.00015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072925071&doi=10.1109%2fBotSE.2019.00015&partnerID=40&md5=0f8442e1490f56458ca00ccc7aa92b66,"Continuous refactoring is necessary to maintain source code quality and to cope with technical debt. Since manual refactoring is inefficient and error-prone, various solutions for automated refactoring have been proposed in the past. However, empirical studies have shown that these solutions are not widely accepted by software developers and most refactorings are still performed manually. For example, developers reported that refactoring tools should support functionality for reviewing changes. They also criticized that introducing such tools would require substantial effort for configuration and integration into the current development environment. In this paper, we present our work towards the Refactoring-Bot, an autonomous bot that integrates into the team like a human developer via the existing version control platform. The bot automatically performs refactorings to resolve code smells and presents the changes to a developer for asynchronous review via pull requests. This way, developers are not interrupted in their workflow and can review the changes at any time with familiar tools. Proposed refactorings can then be integrated into the code base via the push of a button. We elaborate on our vision, discuss design decisions, describe the current state of development, and give an outlook on planned development and research activities. © 2019 IEEE.",Conference paper,Final,Scopus
Malhotra R.; Jain J.,15758058000; 57207990516,Analysis of refactoring effect on software quality of object-oriented systems,2019,Lecture Notes in Networks and Systems,56,,,197,212,15,4,10.1007/978-981-13-2354-6_22,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063490920&doi=10.1007%2f978-981-13-2354-6_22&partnerID=40&md5=65ab8f7a33903a1a659afc7e2fe8de79,"Software industry primarily recognizes the significance of high quality, robust, reliable, and maintainable software. The industry always demands for efficient solutions that can improve the quality of software. Refactoring is one such potential solution; however, literature shows varied results of the application of refactoring techniques on software quality attributes. There are number of refactoring techniques that still needs to be empirically validated. This paper focuses on analyzing the effect of four unexplored refactoring techniques on different software quality attributes like coupling, cohesion, complexity, inheritance, reusability, and testability on object-oriented softwares. Impact analysis is performed by calculating Chidamber-Kemerer (CK) metrics of the projects, both before and after applying the refactoring techniques, and the results are statistically validated. Empirical analysis of results revealed that different refactoring techniques have different effects on internal and external quality attributes of object-oriented systems. © Springer Nature Singapore Pte Ltd. 2019.",Book chapter,Final,Scopus
Coelho F.; Massoni T.; Alves E.L.G.,57211325628; 8327557600; 35185930600,Refactoring-aware code review: A systematic mapping study,2019,"Proceedings - 2019 IEEE/ACM 3rd International Workshop on Refactoring, IWOR 2019",,,8844414,63,66,3,9,10.1109/IWoR.2019.00019,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073426121&doi=10.1109%2fIWoR.2019.00019&partnerID=40&md5=a731a8f454014cf6402431854c415e1b,"Modern Code Review (MCR) demands enhancements in the way change logs are presented to reviewers. Their task benefits from higher-level descriptions about the intention behind commits; for instance, evolution tasks, such as refactorings, could be more effectively reviewed in the presence of the intended transformation - better if automatically detected by MCR tool support. This paper presents a systematic literature mapping (combining results from search strings, snowballing and a two-phase classification scheme) on refactoring-aware solutions to support MCR. We could observe that, since 2015, interest in tools and techniques for automatic detection of refactorings has been steadily growing. Most publications refer to new development methods or carry out characterisation studies. As a consequence of this overview, we point out a few potential research topics for the next years. In special, detection of multiple refactoring types in a mixed change log (in which refactorings are combined with other kinds of changes), or the need for case studies or experiments in applying refactoring detection in MCR, on distinct application domains and development environments. © 2019 IEEE.",Conference paper,Final,Scopus
Nyamawe A.S.; Liu H.; Niu N.; Umer Q.; Niu Z.,57203496218; 56862404100; 36856329200; 55520728200; 23393033800,Automated recommendation of software refactorings based on feature requests,2019,Proceedings of the IEEE International Conference on Requirements Engineering,2019-September,,8920694,187,198,11,18,10.1109/RE.2019.00029,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076927644&doi=10.1109%2fRE.2019.00029&partnerID=40&md5=8be6490bf033c02561902b96605f0bd9,"During software evolution, developers often receive new requirements expressed as feature requests. To implement the requested features, developers have to perform necessary modifications (refactorings) to prepare for new adaptation that accommodates the new requirements. Software refactoring is a well-known technique that has been extensively used to improve software quality such as maintainability and extensibility. However, it is often challenging to determine which kind of refactorings should be applied. Consequently, several approaches based on various heuristics have been proposed to recommend refactorings. However, there is still lack of automated support to recommend refactorings given a feature request. To this end, in this paper, we propose a novel approach that recommends refactorings based on the history of the previously requested features and applied refactorings. First, we exploit the stateof-the-art refactoring detection tools to identify the previous refactorings applied to implement the past feature requests. Second, we train a machine classifier with the history data of the feature requests and refactorings applied on the commits that implemented the corresponding feature requests. The machine classifier is then used to predict refactorings for new feature requests. We evaluate the proposed approach on the dataset of 43 open source Java projects and the results suggest that the proposed approach can accurately recommend refactorings (average precision 73%). © 2019 IEEE.",Conference paper,Final,Scopus
Techapalokul P.; Tilevich E.,57189044783; 6507251807,Code Quality Improvement for All: Automated Refactoring for Scratch,2019,"Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing, VL/HCC",2019-October,,8818950,117,125,8,16,10.1109/VLHCC.2019.8818950,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078098118&doi=10.1109%2fVLHCC.2019.8818950&partnerID=40&md5=381c4171527ca3efb5c7dd7942506d19,"Block-based programming has been overwhelmingly successful in revitalizing introductory computing education and in facilitating end-user development. However, poor code quality makes block-based programs hard to understand, modify, and reuse, thus hurting the educational and productivity effectiveness of blocks. There is great potential benefit in empowering programmers in this domain to systematically improve the code quality of their projects. Refactoring-improving code quality while preserving its semantics-has been widely adopted in traditional software development. In this work, we introduce refactoring to Scratch. We define four new Scratch refactorings: Extract Custom Block, Extract Parent Sprite, Extract Constant, and Reduce Variable Scope. To automate the application of these refactorings, we enhance the Scratch programming environment with powerful program analysis and transformation routines. To evaluate the utility of these refactorings, we apply them to remove the code smells detected in a representative dataset of 448 Scratch projects. We also conduct a between-subjects user study with 24 participants to assess how our refactoring tools impact programmers. Our results show that refactoring improves the subjects' code quality metrics, while our refactoring tools help motivate programmers to improve code quality. © 2019 IEEE.",Conference paper,Final,Scopus
Kobayashi T.; Ishikawa F.; Honiden S.,56241467500; 33367760100; 7003825164,Consistency-preserving refactoring of refinement structures in Event-B models,2019,Formal Aspects of Computing,31,3,,287,320,33,3,10.1007/s00165-019-00478-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85061398103&doi=10.1007%2fs00165-019-00478-z&partnerID=40&md5=391118c86585d41ad25434a903005ba0,"Event-B has been attracting much interest because it supports a flexible refinement mechanism that reduces the complexity of constructing and verifying models of complicated target systems by taking into account multiple abstraction layers of the models. Although most previous studies on Event-B focused on model construction, the constructed models need to be maintained. Moreover, parts of existing models are often reused to construct other models. In this paper, a method is introduced that improves the maintainability and reusability of existing Event-B models. It automatically reconstructs the refinement structure of existing models by constructing models about different sets of variables than that used in the original models, while maintaining the consistencies checked in the original models. The method automatically decomposes each refinement step into multiple steps by taking certain predicates from existing models and deriving additional predicates from the consistency conditions of existing models to create new models consistent with the original ones. By combining the decomposing of refinement steps with the composing of refinement steps, this method automatically restructures a refinement step in accordance with given sets of variables to be taken into account in refinement steps of the refactored models. The results of case studies in which large refinement steps in existing models were decomposed and existing models were restructured to extract reusable parts for constructing other models demonstrated that the proposed method facilitates effective use of the refinement mechanism of Event-B. © 2019, British Computer Society.",Article,Final,Scopus
De Lara J.; Guerra E.,6604098453; 14051863600,Refactoring multi-level models,2018,ACM Transactions on Software Engineering and Methodology,27,4,17,,,,18,10.1145/3280985,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85060848726&doi=10.1145%2f3280985&partnerID=40&md5=f7cfd5e59823bde30cca69286f63feb4,"Multi-level modelling promotes flexibility in modelling by enabling the use of several meta-levels instead of just two, as is the case in mainstream two-level modelling approaches. While this approach leads to simpler models for some scenarios, it introduces an additional degree of freedom as designers can decide the meta-level where an element should reside, having to ascertain the suitability of such decisions. In this respect, model refactorings have been successfully applied in the context of two-level modelling to rearrange the elements of a model while preserving its meaning. Following this idea, we propose a catalogue of 17 novel refactorings specific to multi-level models. Their objective is to help designers in rearranging elements across and within meta-levels and exploring the consequences. In this article, we detail each refactoring in the catalogue, show a classification across different dimensions, and describe the support we provide in our MetaDepth tool. We present two experiments to assess two aspects of our refactorings. The first one validates the predicted semantic side effects of the refactorings on the basis of more than 210.000 refactoring applications. The second one measures the impact of refactorings on three quality attributes of multi-level models. © 2018 Association for Computing Machinery.",Article,Final,Scopus
Arcelli D.; Cortellessa V.; Pompeo D.D.,55317293800; 6603764364; 57188727238,Automating Performance Antipattern Detection and Software Refactoring in UML Models,2019,"SANER 2019 - Proceedings of the 2019 IEEE 26th International Conference on Software Analysis, Evolution, and Reengineering",,,8667967,639,643,4,10,10.1109/SANER.2019.8667967,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064168173&doi=10.1109%2fSANER.2019.8667967&partnerID=40&md5=4ab3d504db2ce58613f6eac832c2d71a,"The satisfaction of ever more stringent performance requirements is one of the main reasons for software evolution. However, it is complex to determine the primary causes of performance degradation, because they may depend on the joint combination of multiple factors (e.g., workload, software deployment, hardware utilization). With the increasing complexity of software systems, classical bottleneck analysis shows limitations in capturing complex performance problems. Hence, in the last decade, the detection of performance antipatterns has gained momentum as an effective way to identify performance degradation causes. We introduce PADRE (Performance Antipattern Detection and REfactoring), that is a tool for: (i) detecting performance antipattern in UML models, and (ii) refactoring models with the aim of removing the detected antipatterns. PADRE has been implemented within Epsilon, an open-source platform for model-driven engineering. It is based on a methodology that allows performance antipattern detection and refactoring within the same implementation context. © 2019 IEEE.",Conference paper,Final,Scopus
Badri M.; Badri L.; Hachemane O.; Ouellet A.,57203205678; 57204223568; 57202465120; 57198860179,Measuring the effect of clone refactoring on the size of unit test cases in object-oriented software: an empirical study,2019,Innovations in Systems and Software Engineering,,,,,,,8,10.1007/s11334-019-00334-6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85064277915&doi=10.1007%2fs11334-019-00334-6&partnerID=40&md5=a4f53e79583ccfc98f401bdee0e568ed,"This paper aims at empirically measuring the effect of clone refactoring on the size of unit test cases in object-oriented software. We investigated various research questions related to the: (1) impact of clone refactoring on source code attributes (particularly size, complexity and coupling) that are related to testability of classes, (2) impact of clone refactoring on the size of unit test cases, (3) correlations between the variations observed after clone refactoring in both source code attributes and the size of unit test cases and (4) variations after clone refactoring in the source code attributes that are more associated with the size of unit test cases. We used different metrics to quantify the considered source code attributes and the size of unit test cases. To investigate the research questions, and develop predictive and explanatory models, we used various data analysis and modeling techniques, particularly linear regression analysis and five machine learning algorithms (C4.5, KNN, Naïve Bayes, Random Forest and Support Vector Machine). We conducted an empirical study using data collected from two open-source Java software systems (ANT and ARCHIVA) that have been clone refactored. Overall, the paper contributions can be summarized as: (1) the results revealed that there is a strong and positive correlation between code clone refactoring and reduction in the size of unit test cases, (2) we showed how code quality attributes that are related to testability of classes are significantly improved when clones are refactored, (3) we observed that the size of unit test cases can be significantly reduced when clone refactoring is applied, and (4) complexity/size measures are commonly associated with the variations of the size of unit test cases when compared to coupling. © 2019, Springer-Verlag London Ltd., part of Springer Nature.",Article,Article in press,Scopus
Zhao H.; Rao Y.; Li D.; Tang J.; Liu S.,57212166194; 57212173860; 57212167544; 57237574500; 58740040600,A DAG Refactor Based Automatic Execution Optimization Mechanism for Spark,2019,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),11783 LNCS,,,338,344,6,1,10.1007/978-3-030-30709-7_30,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85076093290&doi=10.1007%2f978-3-030-30709-7_30&partnerID=40&md5=308c53a2d9cc0b53e9b31f42266d3cdc,"In today’s big data era, traditional disk-based MapReduce big data framework encountered bottlenecks due to its lower memory utilization and inefficient orchestration of complex tasks. With the advantage of fully use memory resources, Spark provides a lot of data manipulate operators and use DAG to express the dependences. Spark split entire job to multi-stage according to DAG and schedule them in a distributed execution environment, which better adapted to the new characteristic of big data processing. However, Spark didn’t consider the resource requirement of different operators and schedule them indiscriminately, which could cause load imbalances on different nodes in the cluster and cause some node become bottlenecks due to its extraordinary resource consumption. In the past, solve this problem need developers to have a lot of experience of Spark and write code sophisticated. In this paper, we proposed a DAG refactor based automatic execution optimization mechanism for Spark. The experimental results show that the DAG refactor mechanism can greatly improve Spark performance by up to 8.8X without misinterpretation of original program semantics. © 2019, IFIP International Federation for Information Processing.",Conference paper,Final,Scopus
Krüger J.; Al-Hajjaji M.; Schulze S.; Saake G.; Leich T.,57191578129; 57204343420; 35225243700; 7004621677; 13005454000,Towards automated test refactoring for software product lines,2018,ACM International Conference Proceeding Series,1,,,143,148,5,9,10.1145/3233027.3233040,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85055539590&doi=10.1145%2f3233027.3233040&partnerID=40&md5=9c87331f1849736b31671364be9e176d,"In practice, organizations often rely on the clone-and-own approach to reuse and customize existing systems. While increasing maintenance costs encourage some organizations to adopt their development processes towards more systematic reuse, others still avoid migrating to a reusable platform. Based on our experiences, a barrier preventing the adoption of software product lines is the fear of introducing new and more problematic bugs-during the migration or later on. We are aware of several works that automate software-product-line adoption, but they neglect the migration and maintenance of test cases. Automating the refactoring of tests can help to facilitate the adoption barrier, compare the quality after migrations, and support maintenance. In this vision paper, we i) discuss open research challenges that are based on our experiences and ii) sketch a first framework to develop automated solutions. Overall, we aim to illustrate our idea and initiate further research to facilitate the adoption and maintenance of software product lines. © 2018 Copyright held by the owner/author(s).",Conference paper,Final,Scopus
Marinke R.; Guerra E.M.; Fagundes Silveira F.; Azevedo R.M.; Nascimento W.; de Almeida R.S.; Rodrigues Demboscki B.; da Silva T.S.,15846283300; 24476299600; 36011954300; 57209749467; 57209748496; 57209746107; 57209746785; 57225378846,Towards an Extensible Architecture for Refactoring Test Code,2019,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),11622 LNCS,,,456,471,15,2,10.1007/978-3-030-24305-0_34,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85068604132&doi=10.1007%2f978-3-030-24305-0_34&partnerID=40&md5=7b43036d09ff0d9828c0803b31c90947,"As the software evolves, new codes are written, and many other codes are refactored. Refactoring also involves the test code, to ensure that it continues performed, and adequately verifying the behavior of the software. This work proposes the creation of an extensible architecture named EARTC to perform refactoring safely in test code. The coding of a specific refactoring for the test code is hampered by coupling to the unit testing automation framework so that it becomes desirable to eliminate this coupling from the refactoring code. The architecture proposed in this work implements extension points, which allows refactoring to be performed regardless of the test framework to be used, that is, other refactorings can be added to the architecture without the need to change the test code. Additionally, the architecture enables other testing frameworks to be coupled without interfering with their internal structure. To validate the independence among architecture modules, a Design Structure Matrix was done, which shows that the objectives were achieved. Also, to analyze the results of the proposed architecture in an experiment, a tool called Neutrino was implemented. The results obtained with Neutrino are satisfactory and show that the architecture meets the objectives described for the accomplishment of this work. © 2019, Springer Nature Switzerland AG.",Conference paper,Final,Scopus
El-Attar M.; Nasser N.,16030278200; 9638688800,Refactoring misuse case diagrams using model transformation,2019,ENASE 2019 - Proceedings of the 14th International Conference on Evaluation of Novel Approaches to Software Engineering,,,,249,256,7,1,10.5220/0007675502490256,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85067436257&doi=10.5220%2f0007675502490256&partnerID=40&md5=3e65bf3ee0fd921dea342a8c1387032c,"Secure software engineering entails that security concerns needs to be considered from the early phases of development, as early as the requirements engineering phase. Misuse cases is a well-known security analysis and specifications techniques, based on the popular use case modeling technique, that takes place in the requirements engineering phase. Similar to use case modeling, misuse case modellers are prone to committing modeling mistakes and applying antipatterns. As a result, misuse case models need to be analysed to determine if they contain fallacious design decisions. Changes, known as refactoring, to the misuse case diagrams are then required to remedy any design issues and such changes which would normally be manually applied. However, manual application of such changes in misuse case models are prone to human error, further compounding the design issues in a given misuse case model. To this end, this paper presents a model transformation approach to systematically apply changes to misuse case models. A case study related to a book store is presented to illustrate the application and feasibility of the approach. Copyright © 2019 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Chen Z.; Kwon Y.-W.; Song M.,57190860338; 57208480210; 32868182400,Clone refactoring inspection by summarizing clone refactorings and detecting inconsistent changes during software evolution,2018,Journal of Software: Evolution and Process,30,10,e1951,,,,7,10.1002/smr.1951,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045832656&doi=10.1002%2fsmr.1951&partnerID=40&md5=a18f70d136e98253ad298429b5142045,"It has been broadly assumed that removing code clones by refactorings would solve the problems of code duplication. Despite recent empirical studies on the benefit of refactorings, contradicting evidence shows that it is often difficult or impossible to remove clones by using standard refactoring techniques. Developers cannot easily determine which clones can be refactored or how they should be maintained scattered throughout a large code base in evolving systems. We propose pattern-based clone refactoring inspection (PRI), a technique for managing clone refactorings. PRI summarizes refactorings of clones and detects clones that are not consistently refactored. To help developers refactor these anomalies, PRI also visualizes clone evolution and refactorings and fixes refactoring anomalies to prevent the clone group from being left in an inconsistent state. We evaluated PRI on 6 open-source projects and showed that it identifies clone refactorings with 94.1% accuracy and detects inconsistent refactorings with 98.4% accuracy, tracking clone change histories. In a study with 10 student developers, the participants reported that flexible PRI's summarization and detection features can be valuable for novice developers to learn about refactorings to clones. These results show that PRI should improve developer productivity in inspecting clone refactorings distributed across multiple files in evolving systems. Copyright © 2018 John Wiley & Sons, Ltd.",Article,Final,Scopus
Bibiano A.C.; Fernandes E.; Oliveira D.; Garcia A.; Kalinowski M.; Fonseca B.; Oliveira R.; Oliveira A.; Cedrim D.,57202890121; 37123675100; 57211276861; 7404608626; 8288075800; 36175426900; 57188679629; 56851872700; 57194528845,A Quantitative Study on Characteristics and Effect of Batch Refactoring on Code Smells,2019,International Symposium on Empirical Software Engineering and Measurement,2019-Septemer,,8870183,,,,33,10.1109/ESEM.2019.8870183,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85074270841&doi=10.1109%2fESEM.2019.8870183&partnerID=40&md5=df5598d0ff10e3bbca81f17068c82bc6,"Background: Code refactoring aims to improve code structures via code transformations. A single transformation rarely suffices to fully remove code smells that reveal poor code structures. Most transformations are applied in batches, i.e. sets of interrelated transformations, rather than in isolation. Nevertheless, empirical knowledge on batch application, or batch refactoring, is scarce. Such scarceness helps little to improve current refactoring practices. Aims: We analyzed 57 open and closed software projects. We aimed to understand batch application from two perspectives: characteristics that typically constitute a batch (e.g., the variety of transformation types employed), and the batch effect on smells. Method: We analyzed 19 smell types and 13 transformation types. We identified 4,607 batches, each applied by the same developer on the same code element (method or class); we expected to have batches whose transformations are closely interrelated. We computed (1) the frequency in which five batch characteristic manifest, (2) the probability of each batch characteristics to remove smells, and (3) the frequency in which batches introduce and remove smells. Results: Most batches are quite simple: although most batches are applied on more than one method (90%), they are usually composed of the same transformation type (72%) and only two transformations (57%). Batches applied on a single method are 2.6 times more prone to fully remove smells than batches affecting more than one method. Surprisingly, batches mostly ended up introducing (51%) or not fully removing (38%) smells. Conclusions: The batch simplicity suggests that developers have sub-explored the combinations of transformations within a batch. We summarized some batches that may fully remove smells, so that developers can incorporate them into current refactoring practices. © 2019 IEEE.",Conference paper,Final,Scopus
Bryksin T.; Novozhilov E.; Shpilman A.,55916625600; 57208034652; 57202467847,Automatic recommendation of move method refactorings using clustering ensembles,2018,"IWoR 2018 - Proceedings of the 2nd International Workshop on Refactoring, co-located with ASE 2018",,,,42,45,3,6,10.1145/3242163.3242171,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063647323&doi=10.1145%2f3242163.3242171&partnerID=40&md5=b5b7b96c0cb9dad2d34e543607f36209,"In this paper, we are approaching the problem of automatic refactoring recommendation for object-oriented systems. An approach based on clustering ensembles is proposed, several heuristics to existing algorithms and to filtering and combining their results are discussed. Experimental validation of the proposed approach on an open source project is presented. The obtained preliminary results illustrate that the introduced approach could be successfully used to improve existing integrated development environments, providing developers with one more tool to reduce the complexity of their projects. The paper concludes with a discussion on the applicability of such automatic refactoring recommendation approaches to real-world software developed using common object-oriented techniques. © 2018 ACM.",Conference paper,Final,Scopus
Khatchadourian R.; Tang Y.; Bagherzadeh M.; Ahmed S.,24469948000; 57202887655; 36674592400; 57216098388,Safe Automated Refactoring for Intelligent Parallelization of Java 8 Streams,2019,Proceedings - International Conference on Software Engineering,2019-May,,8811925,619,630,11,23,10.1109/ICSE.2019.00072,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071934163&doi=10.1109%2fICSE.2019.00072&partnerID=40&md5=25ce9ddba505cdcabfc185a5f6df6dfa,"Streaming APIs are becoming more pervasive in mainstream Object-Oriented programming languages. For example, the Stream API introduced in Java 8 allows for functional-like, MapReduce-style operations in processing both finite and infinite data structures. However, using this API efficiently involves subtle considerations like determining when it is best for stream operations to run in parallel, when running operations in parallel can be less efficient, and when it is safe to run in parallel due to possible lambda expression side-effects. In this paper, we present an automated refactoring approach that assists developers in writing efficient stream code in a semantics-preserving fashion. The approach, based on a novel data ordering and typestate analysis, consists of preconditions for automatically determining when it is safe and possibly advantageous to convert sequential streams to parallel and unorder or de-parallelize already parallel streams. The approach was implemented as a plug-in to the Eclipse IDE, uses the WALA and SAFE analysis frameworks, and was evaluated on 11 Java projects consisting of ?642K lines of code. We found that 57 of 157 candidate streams (36.31%) were refactorable, and an average speedup of 3.49 on performance tests was observed. The results indicate that the approach is useful in optimizing stream code to their full potential. © 2019 IEEE.",Conference paper,Final,Scopus
Garcia J.D.,7406130225,Refactoring software to heterogeneous parallel platforms,2019,Journal of Supercomputing,75,8,,3997,4000,3,1,10.1007/s11227-019-02942-2,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85073012126&doi=10.1007%2fs11227-019-02942-2&partnerID=40&md5=cc363e45034c8c62b9c4f70bdfaa7df4,[No abstract available],Editorial,Final,Scopus
Chug A.; Gupta S.,56168650500; 57208880920,Enhancing the life of legacy software through refactoring based systematic transformation,2019,"IMCIC 2019 - 10th International Multi-Conference on Complexity, Informatics and Cybernetics, Proceedings",2,,,216,221,5,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85066046651&partnerID=40&md5=e6642734a50749c292eb7aeccbb72f19,"Refactoring process enhances, improves and restructures an existing code by manipulating its interior structure without influencing its outer conduct. The legacy codes are outdated application software which are difficult to maintain due to the change in technology, however, retiring them is not feasible sometimes due to their historic significance. Reconstructing large legacy software becomes more and more intricate due to the complexity developed in it as it evolves over time. The current paper presents a refactoring-based systematic transformation technique which is applied to the existing legacy code in order to enhance its life. In this empirical investigation, an open source system, Trip-Service-Kata is used and certain software metrics are measured and further used as an indicator of deterioration in software quality. This empirical study successfully exhibits how refactoring can improve the software quality of a legacy code and enhance its life. Copyright 2019. © by the International Institute of Informatics and Systemics. All rights reserved.",Conference paper,Final,Scopus
Sidhu B.K.; Singh K.; Sharma N.,57201698524; 7404762931; 58378327000,Refactoring UML Models of Object-Oriented Software: A Systematic Review,2018,International Journal of Software Engineering and Knowledge Engineering,28,9,,1287,1319,32,7,10.1142/S0218194018500365,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85054021708&doi=10.1142%2fS0218194018500365&partnerID=40&md5=7279af830d7e3df21986635ae2ba58dd,"Model refactoring enhances the platform-independent design models of software aiming at smoother impact of requirement changes, thereby improving the design quality and assisting in their evolution and maintenance. This study reports a systematic literature review of refactoring techniques particularly in the domain of models of object-oriented software systems. The study used the standard systematic literature review method based on a comprehensive set of 58 articles from a total of 1200 articles published in leading journals, premier conferences, workshops and books. The primary studies were thoroughly analyzed on various aspects of model refactoring process. Identification of methodologies and classification on the basis of model transformation systems, refactoring operations and their application, model behavior specification and preservation, model quality expression, model consistency management and automation of process is reported. This study shows that inadequate model-based approaches for behavior preservation, synchronized model enhancement and empirical evaluation of the proposed refactoring techniques are major obstacles in fully automated model refactoring process. © 2018 World Scientific Publishing Company.",Conference paper,Final,Scopus
Kaur S.; Singh P.,57213734425; 57202959177,How does object-oriented code refactoring influence software quality? Research landscape and challenges,2019,Journal of Systems and Software,157,,110394,,,,41,10.1016/j.jss.2019.110394,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071483107&doi=10.1016%2fj.jss.2019.110394&partnerID=40&md5=d59edcfb8685632e0dcd8d2ce99b7a0f,"Context: Software refactoring aims to improve software quality and developer productivity. Numerous empirical studies investigating the impact of refactoring activities on software quality have been conducted over the last two decades. Objective: This study aims to perform a comprehensive systematic mapping study of existing empirical studies on evaluation of the effect of object-oriented code refactoring activities on software quality attributes. Method: We followed a multi-stage scrutinizing process to select 142 primary studies published till December 2017. The selected primary studies were further classified based on several aspects to answer the research questions defined for this work. In addition, we applied vote-counting approach to combine the empirical results and their analysis reported in primary studies. Results: The findings indicate that studies conducted in academic settings found more positive impact of refactoring on software quality than studies performed in industries. In general, refactoring activities caused all quality attributes to improve or degrade except for cohesion, complexity, inheritance, fault-proneness and power consumption attributes. Furthermore, individual refactoring activities have variable effects on most quality attributes explored in primary studies, indicating that refactoring does not always improve all quality attributes. Conclusions: This study points out several open issues which require further investigation, e.g., lack of industrial validation, lesser coverage of refactoring activities, limited tool support, etc. © 2019",Article,Final,Scopus
Meng F.; Su X.,55426663000; 7402181881,WCET optimization strategy based on source code refactoring,2019,Cluster Computing,22,,,5563,5572,9,2,10.1007/s10586-017-1369-3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034661447&doi=10.1007%2fs10586-017-1369-3&partnerID=40&md5=ef24c8b18cee15ae50cd1176026d0663,"For safety-critical real-time software, if worst-case execution time (WCET) violates a time constraint, it is considered having a timeliness defect. To fix the defect early with lower cost, a WCET optimization strategy is proposed based on source code refactoring. The strategy guides programmers to search refactoring opportunities in the correct positions and perform refactorings by a reasonable sequence. To this end, the worst-case execution path (WCEP) of a target program is firstly extracted from its control flow graph. Then the WCEP is mapped onto source code by the back-annotation technique. An abstract syntax tree-based invariant path identification algorithm is developed for recognizing the invariant paths from the source-level WCEP. According to the invariant paths and loop statements, the source code is divided into four optimization regions with different priorities. Thus the searching scopes are reduced, and invalid refactorings are avoided. On the basis, the refactoring which has the lowest cost in the same region is performed first. To support the strategy, a cost model of source code refactoring is designed. It mainly considers adverse effects of refactorings on the maintainability of source code. The experimental results showed that the optimization strategy reduced WCET effectively and maximally kept the maintainability. Therefore it is more suitable for WCET optimization in an early programming phase. It is helpful to fix the defects early and then guarantee the timeliness safety of the software. © 2017, Springer Science+Business Media, LLC, part of Springer Nature.",Article,Final,Scopus
Zhang Y.; Dong S.; Zhang X.; Liu H.; Zhang D.,55816561700; 57220768683; 57220771839; 57209292502; 35303919200,Automated Refactoring for Stampedlock,2019,IEEE Access,7,,8781844,104900,104911,11,9,10.1109/ACCESS.2019.2931953,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85078105714&doi=10.1109%2fACCESS.2019.2931953&partnerID=40&md5=249b16d3c9db84c718bd83fe44e0f2e6,"StampedLock, proposed in JDK 1.8, provides many interesting features, such as optimistic read locks and upgrading/downgrading locks to improve the design of concurrent programs instead of employing pure read/write locks. Existing refactorings have proposed algorithms to convert locks, but there are a few refactorings that use these promising features of StampedLock. To illustrate a possible refactoring, this paper first shows three code transformations based on StampedLock. Then, this paper presents CLOCK, an automated refactoring tool that helps developers convert the synchronized lock into the StampedLock. An algorithm for reentrance analysis is proposed for the precondition validation. The write lock, read lock, optimistic read lock, and upgrading/downgrading lock are inferred and refactored. CLOCK is evaluated with the SPECjbb2005 benchmark and two real-world applications, Xalan and FOP. A total of 66 classes are modified by searching approximately 395KSLOC and applying the refactoring, achieving an average of 22 classes per benchmark. The experimental results show that CLOCK can help developers with refactoring for StampedLock and save developer effort. © 2019 Institute of Electrical and Electronics Engineers Inc.. All rights reserved.",Article,Final,Scopus
Lu H.; Wang S.; Yue T.; Ali S.; Nygard J.F.,57126555700; 55885224500; 25651096400; 56962801700; 7003875061,Automated refactoring of OCL constraints with search,2019,IEEE Transactions on Software Engineering,45,2,8114267,148,170,22,8,10.1109/TSE.2017.2774829,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85035112846&doi=10.1109%2fTSE.2017.2774829&partnerID=40&md5=fd930682d2a62b320563bfd28813dc04,"Object Constraint Language (OCL) constraints are typically used to provide precise semantics to models developed with the Unified Modeling Language (UML). When OCL constraints evolve regularly, it is essential that they are easy to understand and maintain. For instance, in cancer registries, to ensure the quality of cancer data, more than one thousand medical rules are defined and evolve regularly. Such rules can be specified with OCL. It is, therefore, important to ensure the understandability and maintainability of medical rules specified with OCL. To tackle such a challenge, we propose an automated search-based OCL constraint refactoring approach (SBORA) by defining and applying four semantics-preserving refactoring operators (i.e., Context Change, Swap, Split and Merge) and three OCL quality metrics (Complexity, Coupling, and Cohesion) to measure the understandability and maintainability of OCL constraints. We evaluate SBORA along with six commonly used multi-objective search algorithms (e.g., Indicator-Based Evolutionary Algorithm (IBEA)) by employing four case studies from different domains: healthcare (i.e., cancer registry system from Cancer Registry of Norway (CRN)), Oil&Gas (i.e., subsea production systems), warehouse (i.e., handling systems), and an open source case study named SEPA. Results show: 1) IBEA achieves the best performance among all the search algorithms and 2) the refactoring approach along with IBEA can manage to reduce on average 29.25 percent Complexity and 39 percent Coupling and improve 47.75 percent Cohesion, as compared to the original OCL constraint set from CRN. To further test the performance of SBORA, we also applied it to refactor an OCL constraint set specified on the UML 2.3 metamodel and we obtained positive results. Furthermore, we conducted a controlled experiment with 96 subjects and results show that the understandability and maintainability of the original constraint set can be improved significantly from the perspectives of the 96 participants of the controlled experiment. © 1976-2012 IEEE.",Article,Final,Scopus
Rafique M.Z.; Alam K.A.; Iqbal U.,57215966254; 56504833200; 57192977479,Multi-Objective Optimization Techniques for Software Refactoring: A Systematic Literature Review,2019,"MACS 2019 - 13th International Conference on Mathematics, Actuarial Science, Computer Science and Statistics, Proceedings",,,9024773,,,,0,10.1109/MACS48846.2019.9024773,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85082438239&doi=10.1109%2fMACS48846.2019.9024773&partnerID=40&md5=ee11f234aa935fde311b9ce61089a1df,"Software Refactoring is an essential activity of software maintenance. It aims at improving the internal structure of the program without affecting its external functionalities which not only aids in improving maintainability and readability but also helps in reducing overall software complexity. Many different manuals and automated software refactoring tools are available but most of these tools focus single objective refactoring i.e. improving the quality or reducing the code lines. Software refactoring involves many factors so different authors have proposed different multi-objective software refactoring approaches. We have performed systematic literature to classify and analyzed the studies published in the field of multi-objective software refactoring. The main objectives of our research are to categorize the studies on multi-objective software refactoring according to 4 criteria. We have considered studies from electronics databases from 2014 to 2019. A total of 19 studies were finalized based on our inclusion-exclusion and quality assessment criteria. The results of our research show that NSGA-II is a widely popular technique in the domain of multi-objective software refactoring whereas NSGA-III is popular when many objectives were considered. Furthermore, 11 most widely uses open source and industrial projects are identified which are used to evaluate the multi-objective software refactoring approaches. It was also observed that Precision, Recall and Inverse Generation Distance are commonly used evaluation metrics. The chronological distribution of studies shows that 2016 was the most productive research year in this field. Our results show that 76% of studies are ranked high based on our predefined quality assessment criteria. Based on our results we have concluded that multiobjective software refactoring is still an emerging field and there is a need to apply the latest state-of-the-art multi-objective approaches to get better results. © 2019 IEEE.",Conference paper,Final,Scopus
Bukowitz Beluzzo L.; Nasser Matos S.; Henrique Pacher T.,57210801102; 23485839700; 57210795759,A refactoring architecture for measuring and identifying spots of design patterns insertion in source code,2019,ICSOFT 2018 - Proceedings of the 13th International Conference on Software Technologies,,,,632,639,7,0,10.5220/0006868006320639,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071516266&doi=10.5220%2f0006868006320639&partnerID=40&md5=a65c93966b4d306ffd1b67949c2f7be0,"This work presents an architecture for detecting insertion spots of design patterns in an object-oriented source code. The proposed architecture contains a Service that implements Detection Methods (DMS) present in the literature such as identification of precursors, prolog rules and facts, among others. The DMS notifies the Metrics Service (MS) which patterns can be used. The evaluation of the application of the patterns undertaken by the MS is performed by means of quality metrics such as maintainability, flexibility, and so forth. The MS notifies the Client App (CA) of the advantages and disadvantages of using the eligible patterns. The CA interacts with the user to retrieve decisions about which changes to perform in source code according to the design pattern real benefit and notifies the Applier Service (AS), that applies the patterns in the source code. The difference between the proposed architecture and the literature is that it allows a thorough interaction with the user and it creates an extendable environment to cover several pattern detection/insertion methods. The architecture allows automated support to users engaged in the refactoring process based on design patterns. Copyright © 2018 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Khatchadourian R.; Tang Y.; Bagherzadeh M.; Ahmed S.,24469948000; 57202887655; 36674592400; 57216098388,A tool for optimizing Java 8 stream software via automated refactoring,2018,"Proceedings - 18th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2018",,,8530715,34,39,5,11,10.1109/SCAM.2018.00011,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058310579&doi=10.1109%2fSCAM.2018.00011&partnerID=40&md5=75ab78846b78e412845db1920cc42b25,"Streaming APIs are pervasive in mainstream Object-Oriented languages and platforms. For example, the Java 8 Stream API allows for functional-like, MapReduce-style operations in processing both finite, e.g., collections, and infinite data structures. However, using this API efficiently involves subtle considerations like determining when it is best for stream operations to run in parallel, when running operations in parallel can be less efficient, and when it is safe to run in parallel due to possible lambda expression side-effects. In this paper, we describe the engineering aspects of an open source automated refactoring tool called Optimize Streams that assists developers in writing optimal stream software in a semantics-preserving fashion. Based on a novel ordering and typestate analysis, the tool is implemented as a plug-in to the popular Eclipse IDE, using both the WALA and SAFE frameworks. The tool was evaluated on 11 Java projects consisting of ~642 thousand lines of code, where we found that 36.31% of candidate streams were refactorable, and an average speedup of 1.55 on a performance suite was observed. We also describe experiences gained from integrating three very different static analysis frameworks to provide developers with an easy-to-use interface for optimizing their stream code to its full potential. © 2018 IEEE.",Conference paper,Final,Scopus
Santos B.M.; De Guzmán I.G.-R.; De Camargo V.V.; Piattini M.; Ebert C.,56428612600; 6602985950; 25654526700; 7004203473; 56406144100,Software Refactoring for System Modernization,2018,IEEE Software,35,6,8552634,62,67,5,6,10.1109/MS.2018.4321236,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058038840&doi=10.1109%2fMS.2018.4321236&partnerID=40&md5=bace70f46dc714b4295e041bbc62b2e5,"Unlike their authors, software systems tend to live much longer than was ever intended or thought possible. Companies thus must modernize their software systems to keep them productive in new environments with new technology, within acceptable levels of costs. Refactoring tools can help with this process. © 2018 IEEE.",Article,Final,Scopus
Almogahed A.; Omar M.; Zakaria N.H.,16232670900; 36608821700; 24529316600,Categorization refactoring techniques based on their effect on software quality attributes,2019,International Journal of Innovative Technology and Exploring Engineering,8,8SpecialIssue,,439,445,6,12,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85070075254&partnerID=40&md5=10d21ac51909f5d36c65099a72f021e8,"Refactoring techniques don't always improve all aspects of software quality attributes. Different types of refactoring techniques have different types of effect on different software quality attributes. consequently, software practitioners encounter challenges in selecting appropriate refactoring techniques to enhance the quality of software design in support of particular design goals. Therefore, categorization refactoring techniques depending on their influence on quality attributes is significant to enable software practitioners in improving software quality by selecting suitable refactoring techniques. A systematic review has been accomplished to determine and analyze studies which tightly related to categorize the refactoring techniques depending on their influence on quality attributes.14 primary studies have been found and selected for analysis. The obtained results showed that there is a lack of studies regarding the categorization of the refactoring techniques and the current works are insufficient to solve the challenges facing software practitioners. Several recommendations have been suggested to address these gaps. © BEIESP.",Article,Final,Scopus
Haendler T.; Neumann G.,57163856400; 7202631028,Serious games for software refactoring,2019,"Lecture Notes in Informatics (LNI), Proceedings - Series of the Gesellschaft fur Informatik (GI)",P-292,,,181,182,1,1,10.18420/se2019-58,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072124452&doi=10.18420%2fse2019-58&partnerID=40&md5=6e7d0a79603e4716953fb6716a2da113,"This summary refers to the paper Serious Refactoring Games published as a full research paper in the proceedings of the 52nd Hawaü International Conference on System Sciences (HICSS 2019) [HN19]. Software design issues can severely impede software development and maintenance. Thus, it is important for the success of software projects that developers are aware of bad smells in code artifacts and improve their skills to reduce these issues via refactoring. However, software refactoring is a complex activity and involves multiple tasks and aspects. Therefore, imparting competences for identifying bad smells and refactoring code efficiently is challenging for software engineering education and training. The approaches proposed for teaching software refactoring in recent years mostly concentrate on small and artificial tasks and fall short in terms of higher level competences, such as analysis and evaluation. In this paper, we investigate the possibilities and challenges of designing serious games for software refactoring on real-world code artifacts. In particular, we propose a game design, where students can compete either against a predefined benchmark (technical debt) or against each other. In addition, we describe a lightweight architecture as the technical foundation for the game design that integrates pre-existing analysis tools such as test frameworks and software-quality analyzers. Finally, we provide an exemplary game scenario to illustrate the application of serious games in a learning setting. © 2019 Gesellschaft fur Informatik (GI). All rights reserved.",Conference paper,Final,Scopus
Kebir S.; Borne I.; Meslati D.,57190378426; 23392088100; 6507707445,A genetic algorithm-based approach for automated refactoring of component-based software,2017,Information and Software Technology,88,,,17,36,19,20,10.1016/j.infsof.2017.03.009,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85015986827&doi=10.1016%2fj.infsof.2017.03.009&partnerID=40&md5=0f645a97f59e8f9bf9c137c3cf006278,"Context: During its lifecycle, a software system undergoes repeated modifications to quickly fulfill new requirements, but its underlying design is not properly adjusted after each update. This leads to the emergence of bad smells. Refactoring provides a de facto behavior-preserving approach to eliminate these anomalies. However, manually determining and performing useful refactorings is a formidable challenge, as stated in the literature. Therefore, framing object-oriented automated refactoring as a search-based technique has been proposed. However, the literature shows that search-based refactoring of component-based software has not yet received proper attention. Objective: This paper presents a genetic algorithm-based approach for the automated refactoring of component-based software. This approach consists of detecting component-relevant bad smells and eliminating these bad smells by searching for the best sequence of refactorings using a genetic algorithm. Method: Our approach consists of four steps. The first step includes studying the literature related to component-relevant bad smells and formulating bad smell detection rules. The second step involves proposing a catalog of component-relevant refactorings. The third step consists of constructing a source code model by extracting facts from the source code of a component-based software. The final step seeks to identify the best sequence of refactorings to apply to reduce the presence of bad smells in the source code model using a genetic algorithm. The latter uses bad smell detection rules as a fitness function and the catalog of refactorings as a means to explore the search space. Results: As a case study, we conducted experiments on an unbiased set of four real-world component-based applications. The results indicate that our approach is able to efficiently reduce the total number of bad smells by more than one half, which is an acceptable value compared to the recent literature. Moreover, we determined that our approach is also accurate in refactoring only components suffering from bad smells while leaving the remaining components untouched whenever possible. Furthermore, a statistical analysis shows that our genetic algorithm outperforms random search and local search in terms of efficiency and accuracy on almost all the systems investigated in this work. Conclusion: This paper presents a search-based approach for the automated refactoring of component-based software. To the best of our knowledge, our approach is the first to focus on component-based refactoring, whereas the state-of-the-art approaches focus only on object-oriented refactoring. © 2017 Elsevier B.V.",Article,Final,Scopus
Ge X.; Sarkar S.; Witschey J.; Murphy-Hill E.,42161436200; 57198931976; 55936636400; 16307910100,Refactoring-Aware code review,2017,"Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing, VL/HCC",2017-October,,8103453,71,79,8,27,10.1109/VLHCC.2017.8103453,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041016378&doi=10.1109%2fVLHCC.2017.8103453&partnerID=40&md5=f9b3dab577066fefb0f2b1bc50082bf2,"Code review, where developers manually inspect one another's code changes, improves software quality and transfers knowledge in a team. Unfortunately, tools that support code review treat behavior-preserving changes, or refactorings, and behavior-Altering changes, or non-refactorings, the same way, so developers have to spend effort differentiating between the two before they can evaluate the impact of a change set. In this paper, we describe a formative study of 35 developers that motivates the need for separating refactorings from non-refactorings during code review. Then, we present a refactoring-Aware code review tool, called ReviewFactor, that differentiates between refactoring and non-refactoring, and allows developers to focus on one of them at a time. Finally, a case study of two open source projects suggests that ReviewFactor detects refactorings in 39% of the commits, and identifies 4.6% of the total lines of code change as refactorings. Our results also show that the precision and recall of ReviewFactor's refactoring detection algorithm are 92.5% and 94.2%, respectively. © 2017 IEEE.",Conference paper,Final,Scopus
Carvalho L.P.S.; Novais R.L.; Salvador L.N.; Neto M.G.M.,55314668100; 54405730900; 55360518800; 7005160540,An approach for semantically-enriched recommendation of refactorings based on the incidence of code smells,2018,Lecture Notes in Business Information Processing,321,,,313,335,22,1,10.1007/978-3-319-93375-7_15,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85048976185&doi=10.1007%2f978-3-319-93375-7_15&partnerID=40&md5=8775f3cada76033175aa246bfd5ef045,"Code smells are symptoms of bad decisions on the design and development of software. The occurrence of code smells in software can lead to costly consequences. Refactorings are considered adequate resources when it comes to reducing or removing the undesirable effects of smells in software. Ontologies and semantics can play a substantial role in reducing the interpretation burden of software engineers as they have to decide about adequate refactorings to mitigate the impact of smells. However, related work has given little attention to associating the recommendation of refactorings with the use of ontologies and semantics. Developers can benefit from the combination of code smells detection with a semantically-oriented approach for recommendation of refactorings. To make this possible, we expand the application of our previous ontology, ONTOlogy for Code smEll ANalysis (ONTOCEAN), to combine it with a new one, Ontology for SOftware REfactoring (OSORE). We also introduce a new tool, our REfactoring REcommender SYStem (RESYS) which is capable of binding our two ontologies. As a result, refactorings are automatically chosen and semantically linked to their respective code smells. We also conducted a preliminary evaluation of our approach in a real usage scenario with four open-source software projects. © Springer International Publishing AG, part of Springer Nature 2018.",Conference paper,Final,Scopus
Morales R.; Soh Z.; Khomh F.; Antoniol G.; Chicano F.,56601136800; 49862200700; 24724747600; 35619034000; 19638250500,On the use of developers’ context for automatic refactoring of software anti-patterns,2017,Journal of Systems and Software,128,,,236,251,15,26,10.1016/j.jss.2016.05.042,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85028248184&doi=10.1016%2fj.jss.2016.05.042&partnerID=40&md5=c7768526a3d9ed2be2f9d5eae855e209,"Anti-patterns are poor solutions to design problems that make software systems hard to understand and extend. Entities involved in anti-patterns are reported to be consistently related to high change and fault rates. Refactorings, which are behavior preserving changes are often performed to remove anti-patterns from software systems. Developers are advised to interleave refactoring activities with their regular coding tasks to remove anti-patterns, and consequently improve software design quality. However, because the number of anti-patterns in a software system can be very large, and their interactions can require a solution in a set of conflicting objectives, the process of manual refactoring can be overwhelming. To automate this process, previous works have modeled anti-patterns refactoring as a batch process where a program provides a solution for the total number of classes in a system, and the developer has to examine a long list of refactorings, which is not feasible in most situations. Moreover, these proposed solutions often require that developers modify classes on which they never worked before (i.e., classes on which they have little or no knowledge). To improve on these limitations, this paper proposes an automated refactoring approach, ReCon (Refactoring approach based on task Context), that leverages information about a developer's task (i.e., the list of code entities relevant to the developer's task) and metaheuristics techniques to compute the best sequence of refactorings that affects only entities in the developer's context. We mine 1705 task contexts (collected using the Eclipse plug-in Mylyn) and 1013 code snapshots from three open-source software projects (Mylyn, PDE, Eclipse Platform) to assess the performance of our proposed approach. Results show that ReCon can remove more than 50% of anti-patterns in a software system, using fewer resources than the traditional approaches from the literature. © 2016 Elsevier Inc.",Article,Final,Scopus
Kim J.; Batory D.; Dig D.,54397162600; 7004911762; 13404654100,Refactoring Java software product lines,2017,ACM International Conference Proceeding Series,1,,,59,68,9,8,10.1145/3106195.3106201,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85032262776&doi=10.1145%2f3106195.3106201&partnerID=40&md5=30fae71d6e71ab563060faa2dc294ed1,"Refactoring is a staple of Object-Oriented (OO) program development. It should be a staple of OO Software Product Line (SPL) development too. X15 is the first tool to support the refactoring of Java SPL codebases. X15 (1) uses Java custom annotations to encode variability in feature-based Java SPLs, (2) projects a view of an SPL product (a program that corresponds to a legal SPL configuration), and (3) allows programmers to edit and refactor the product, propagating changes back to the SPL codebase. Case studies apply 2316 refactorings in 8 public Java SPLs and show that X15 is as efficient, expressive, and scalable as a state-of-the-art feature-unaware Java refactoring engine. © 2017 ACM.",Conference paper,Final,Scopus
Xu S.; Guo C.; Liu L.; Xu J.,57118556200; 35731095300; 57120245800; 35778130600,A log-linear probabilistic model for prioritizing extract method refactorings,2017,"2017 3rd IEEE International Conference on Computer and Communications, ICCC 2017",2018-January,,,2503,2507,4,0,10.1109/CompComm.2017.8322986,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049694111&doi=10.1109%2fCompComm.2017.8322986&partnerID=40&md5=7c68d08da88cd2b5f35fad3bef08d35a,"'Extract Method' has been one of the most widely used refactorings, which extracts a piece of code to form a new method. Approaches that automatically recommend Extract Method refactorings have been investigated to facilitate this process. These approaches usually generate candidate Extract Method refactorings, and rank them according to a specific software metric. However, software developers conduct Extract Method refactorings for various reasons. In this paper, we propose an approach that combines method-level software metrics to learns a probabilistic model from real-world refactorings. Experiments compared with two state-of-art approaches have shown the effectiveness of our approach. © 2017 IEEE.",Conference paper,Final,Scopus
Cassol I.; Arévalo G.,56703337700; 8706527300,A methodology to infer and refactor an object-oriented model from C applications,2018,Software - Practice and Experience,48,3,,550,577,27,0,10.1002/spe.2549,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85031508426&doi=10.1002%2fspe.2549&partnerID=40&md5=ebc3014ee9b345930705bfc9ef597906,"When analyzing legacy code, generating a high-level model of an application during the reverse engineering process helps the developers understand how the application is structured and how the dependencies relate the different software entities. Within the context of procedural programming languages (such as C), the existing approaches to get a model of the code require documentation and/or implicit knowledge that stakeholders acquire during the software building. These approaches use the code itself to build a syntactic model where we see the different software artifacts, such as variables, functions, and modules. However, there is no supporting methodology to detect and analyze if there are relationships/dependencies between those artifacts, such as which variable in a module is declared using an abstract data type described in another one, or which are the functions that are using parameters typed with an abstract data type; or any design decision taken by original developers, such as how the developer has implemented functions in different modules. On the other hand, current developers use object-oriented (OO) paradigm to implement not only business applications but also useful methodologies/tools that allow semiautomatic analysis of any application. We must remark the legacy procedural code still has worth and is working in several industries, and as any evolving code, the developers have to be able to perform maintenance tasks minimizing the limitations offered by the language. Based on useful properties that the OO paradigm (and their supporting analysis tools) provide, such as UML models, we propose M2K as a methodology to generate a high-level model from legacy procedural code, mainly written in Ansi C. To understand how C-based applications were implemented is not a new problem in software reengineering. However, our contribution is based on building an OO model and suggesting different refactorings that help the developer to improve it and to eventually guide a new implementation of the target application. Specifically, the methodology builds cohesive software entities mapped from procedural code and makes the coupling between C entities explicit in the high-level model. The result of our methodology is a set of refactored class candidates: a structure that groups a set of variables and a set of functions obtained from the C applications. Based on the class candidate model, we propose refactorings based on OO design principles to improve the design of the application. The most relevant design improvements were obtained with algorithm abstraction by applying the strategy pattern, attributes/methods relocalization, variables types generalization, and removing/renaming methods/attributes. Besides a methodology and the supporting tool, we provide 14 case studies based on real projects implemented in C, and we showed how the results validate our proposal. Copyright © 2017 John Wiley & Sons, Ltd.",Article,Final,Scopus
Gaddam R.T.; Nandhini M.,57195359243; 58892697900,An analysis of various snort based techniques to detect and prevent intrusions in networks: Proposal with code refactoring snort tool in Kali Linux environment,2017,"Proceedings of the International Conference on Inventive Communication and Computational Technologies, ICICCT 2017",,,7975177,10,15,5,27,10.1109/ICICCT.2017.7975177,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027466001&doi=10.1109%2fICICCT.2017.7975177&partnerID=40&md5=30bb39dd8d1aa2a02b23c7e79ea3f8cc,"Security and reliability are the major concern of our daily life usage of any network. But with the swift advancements in network technology, attacks are becoming more sophisticated than defenses. Although firewalls and router-based packet filtering are essential elements of an overall network security topology, they are not enough on their own. So, to brace the network from unauthorized access the idea of Intrusion Detection System (IDS) and Intrusion Prevention System (IPS) is attracting security experts. This paper briefs various trends in Intrusion Detection & Prevention. To understand various techniques in IDS, this paper analyses various approaches proposed by security researchers specifically using popular open source software Snort as their IDS tool. Being an open source IDS, Snort can be easily configured and deployed in any environment. To assess the efficiency, these research papers are analyzed in various performance aspects like Detection Accuracy, Scalability and Capability of detecting unknown attacks. To overcome various challenges like low detection rate, incapable of handling huge traffic, unsupported automated tuning, etc. that are identified during literature review, this paper proposes a level based architecture. All the levels are designed as incremental i.e. capable of providing the desired functionality and also its lower levels. To prove the efficiency of the proposed architecture, it can be integrated into Snort Tool using Code Refactoring. Also proposed an environment setup to evaluate the modified Snort Tool performance in future. © 2017 IEEE.",Conference paper,Final,Scopus
Heged?s P.; Kádár I.; Ferenc R.; Gyimóthy T.,25926433300; 56529171400; 6603559878; 6603266536,Empirical evaluation of software maintainability based on a manually validated refactoring dataset,2018,Information and Software Technology,95,,,313,327,14,31,10.1016/j.infsof.2017.11.012,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85035227892&doi=10.1016%2fj.infsof.2017.11.012&partnerID=40&md5=e725113cf22d12776d9a0df72bca010b,"Context: Refactoring is a technique for improving the internal structure of software systems. It has a solid theoretical background while being used in development practice also. However, we lack empirical research results on the real effect of code refactoring and its application. Objective: This paper presents a manually validated subset of a previously published dataset containing the refactorings extracted by the RefFinder tool, code metrics, and maintainability of 7 open-source systems. We found that RefFinder had around 27% overall average precision on the subject systems, thus our manually validated subset has substantial added value. Using the dataset, we studied several aspects of the refactored and non-refactored source code elements (classes and methods), like the differences in their maintainability and source code metrics. Method: We divided the source code elements into a group containing the refactored elements and a group with non-refactored elements. We analyzed the elements’ characteristics in these groups using correlation analysis, Mann–Whitney U test and effect size measures. Results: Source code elements subjected to refactorings had significantly lower maintainability than elements not affected by refactorings. Moreover, refactored elements had significantly higher size related metrics, complexity, and coupling. Also these metrics changed more significantly in the refactored elements. The results are mostly in line with our previous findings on the not validated dataset, with the difference that clone metrics had no strong connection with refactoring. Conclusions: Compared to the preliminary analysis using a not validated dataset, the manually validated dataset led to more significant results, which suggests that developers find targets for refactorings based on some internal quality properties of the source code, like their size, complexity or coupling, but not clone related metrics as reported in our previous studies. They do not just use these properties for identifying targets, but also control them with refactorings. © 2017 Elsevier B.V.",Article,Final,Scopus
Alves E.L.G.; Massoni T.; Machado P.D.D.L.,35185930600; 8327557600; 8340882100,Test coverage of impacted code elements for detecting refactoring faults: An exploratory study,2017,Journal of Systems and Software,123,,,223,238,15,12,10.1016/j.jss.2016.02.001,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84959125153&doi=10.1016%2fj.jss.2016.02.001&partnerID=40&md5=ee22a473614dc1f6b432d42b992e6268,"Refactoring validation by testing is critical for quality in agile development. However, this activity may be misleading when a test suite is insufficiently robust for revealing faults. Particularly, refactoring faults can be tricky and difficult to detect. Coverage analysis is a standard practice to evaluate fault detection capability of test suites. However, there is usually a low correlation between coverage and fault detection. In this paper, we present an exploratory study on the use of coverage data of mostly impacted code elements to identify shortcomings in a test suite. We consider three real open source projects and their original test suites. The results show that a test suite not directly calling the refactored method and/or its callers increases the chance of missing the fault. Additional analysis of branch coverage on test cases shows that there are higher chances of detecting a refactoring fault when branch coverage is high. These results give evidence that a combination of impact analysis with branch coverage could be highly effective in detecting faults introduced by refactoring edits. Furthermore, we propose a statistic model that evidences the correlation of coverage over certain code elements and the suite's capability of revealing refactoring faults. © 2016 Elsevier Inc.",Article,Final,Scopus
Ghannem A.; El Boussaidi G.; Kessentini M.,55871956200; 13104902500; 25653537200,On the use of design defect examples to detect model refactoring opportunities,2016,Software Quality Journal,24,4,,947,965,18,33,10.1007/s11219-015-9271-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924347991&doi=10.1007%2fs11219-015-9271-9&partnerID=40&md5=e2f568e1b04a88c98f622f45f303c26d,"Design defects are symptoms of design decay, which can lead to several maintenance problems. To detect these defects, most of existing research is based on the definition of rules that represent a combination of software metrics. These rules are sometimes not enough to detect design defects since it is difficult to find the best threshold values; the rules do not take into consideration the programming context, and it is challenging to find the best combination of metrics. As an alternative, we propose in this paper to identify design defects using a genetic algorithm based on the similarity/distance between the system under study and a set of defect examples without the need to define detection rules. We tested our approach on four open-source systems to identify three potential design defects. The results of our experiments confirm the effectiveness of the proposed approach. © 2015, Springer Science+Business Media New York.",Article,Final,Scopus
Dooley J.F.,8954285100,"Software development, design and coding: With patterns, debugging, unit testing, and refactoring second edition",2017,"Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring",,,,1,320,319,5,10.1007/978-1-4842-3153-1,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85046394994&doi=10.1007%2f978-1-4842-3153-1&partnerID=40&md5=78a5645c42d8a368d9b56f7279951431,"Learn the principles of good software design, and how to turn those principles into great code. This book introduces you to software engineering - from the application of engineering principles to the development of software. You’ll see how to run a software development project, examine the different phases of a project, and learn how to design and implement programs that solve specific problems. It’s also about code construction - how to write great programs and make them work. Whether you’re new to programming or have written hundreds of applications, in this book you’ll re-examine what you already do, and you’ll investigate ways to improve. Using the Java language, you’ll look deeply into coding standards, debugging, unit testing, modularity, and other characteristics of good programs. With Software Development, Design and Coding, author and professor John Dooley distills his years of teaching and development experience to demonstrate practical techniques for great coding. © 2017 by John F. Dooley.",Book,Final,Scopus
Wang Y.; Yu H.; Zhu Z.; Zhang W.; Zhao Y.,57022068000; 13408303800; 55549832300; 57206986787; 36811022400,Automatic Software Refactoring via Weighted Clustering in Method-Level Networks,2018,IEEE Transactions on Software Engineering,44,3,,202,236,34,30,10.1109/TSE.2017.2679752,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85044160935&doi=10.1109%2fTSE.2017.2679752&partnerID=40&md5=3a9c5629617e3a45e37e844b133921d8,"In this study, we describe a system-level multiple refactoring algorithm, which can identify the move method, move field, and extract class refactoring opportunities automatically according to the principle of 'high cohesion and low coupling.' The algorithm works by merging and splitting related classes to obtain the optimal functionality distribution from the system-level. Furthermore, we present a weighted clustering algorithm for regrouping the entities in a system based on merged method-level networks. Using a series of preprocessing steps and preconditions, the 'bad smells' introduced by cohesion and coupling problems can be removed from both the non-inheritance and inheritance hierarchies without changing the code behaviors. We rank the refactoring suggestions based on the anticipated benefits that they bring to the system. Based on comparisons with related research and assessing the refactoring results using quality metrics and empirical evaluation, we show that the proposed approach performs well in different systems and is beneficial from the perspective of the original developers. Finally, an open source tool is implemented to support the proposed approach. © 2017 IEEE.",Article,Final,Scopus
Ouni A.; Kessentini M.; Ó Cinnéide M.,50761492200; 25653537200; 55890614500,Introduction to the special section on Software Refactoring,2018,Information and Software Technology,95,,,328,,,0,10.1016/j.infsof.2017.12.015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041546808&doi=10.1016%2fj.infsof.2017.12.015&partnerID=40&md5=34a0f931744b2da8472c79bda604d914,[No abstract available],Editorial,Final,Scopus
Takahashi M.; Nanba R.; Anang Y.; Uchiyama T.; Watanabe Y.,55767274000; 16040046700; 57189005918; 57192819843; 57192820693,A method of program refactoring based on code clone detection and impact analysis,2016,"2016 55th Annual Conference of the Society of Instrument and Control Engineers of Japan, SICE 2016",,,7749180,673,678,5,1,10.1109/SICE.2016.7749180,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85008253016&doi=10.1109%2fSICE.2016.7749180&partnerID=40&md5=d81b31f98bc9280da019a2697b2f51f1,"This paper proposes a method that aggregates similar portions in a program into one common portion and redesigns current program structure to appropriate program structure. When a new function is added to an existing program, the function tends to be developed by copying & pasting a portion in the program and modifying its portion. As a result, it becomes to exist many similar portions in the program. In the case that error modifications or changes occurs in the similar portion, appropriate modifications are required to the all similar portions. It would be considered that the quality and efficiency of those tasks are decreased. So that, this paper proposes a method that detect similar portions with minor modifications and a method that aggregates those similar portions to one appropriate common portion with well-defined program structure. As a result, current program becomes to be refined to the program that can accommodate future modification or changes properly. © 2016 The Society of Instrument and Control Engineers - SICE.",Conference paper,Final,Scopus
Tang W.; Yamaguchi S.; Ahmadon M.A.B.,57193066022; 56036805400; 57211430198,Reduction of redundant tasks and its application to refactoring in consumer electronics software,2017,"2017 IEEE 6th Global Conference on Consumer Electronics, GCCE 2017",2017-January,,,1,4,3,0,10.1109/GCCE.2017.8229450,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045741583&doi=10.1109%2fGCCE.2017.8229450&partnerID=40&md5=1271df67d45d9eebb9b97b372f44fdbe,"In this paper, we discussed redundant tasks in consumer electronics software in terms of Petri nets. We first defined redundant tasks formally. Next we proposed sufficient conditions and necessary conditions to find redundant tasks in consumer electronics software. Then we showed the efficiency of the proposed reduction by using an application example to smart refrigerator. © 2017 IEEE.",Conference paper,Final,Scopus
Saca M.A.,57203063075,Refactoring improving the design of existing code,2017,"2017 IEEE 37th Central America and Panama Convention, CONCAPAN 2017",2018-January,,,1,3,2,8,10.1109/CONCAPAN.2017.8278488,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050394215&doi=10.1109%2fCONCAPAN.2017.8278488&partnerID=40&md5=556b3a6281ca39c46f524c2df4692f20,"The present document contains the most relevant results obtained in the study of refactoring. Mainly it addresses the general aspects of refactoring and the basic concepts that make it up, then it details the how, why and when to apply refactoring in computer systems that have been poorly designed, this in order to a better performance and maintenance of the constituent components. Finally, it is emphasized the importance of the refactoring process as such in software development. © 2017 IEEE.",Conference paper,Final,Scopus
Meananeatra P.; Rongviriyapanish S.; Apiwattanapong T.,46161484600; 46161612500; 6505975796,Refactoring opportunity identification methodology for removing long method smells and improving code analyzability,2018,IEICE Transactions on Information and Systems,E101D,7,,1766,1779,13,3,10.1587/transinf.2017KBP0026,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049395535&doi=10.1587%2ftransinf.2017KBP0026&partnerID=40&md5=fc0a4d2c34cb1d45a6a232c1dea550e6,"An important step for improving software analyzability is applying refactorings during the maintenance phase to remove bad smells, especially the long method bad smell. Long method bad smell occurs most frequently and is a root cause of other bad smells. However, no research has proposed an approach to repeating refactoring identification, suggestion, and application until all long method bad smells have been removed completely without reducing software analyzability. This paper proposes an effective approach to identifying refactoring opportunities and suggesting an effective refactoring set for complete removal of long method bad smell without reducing code analyzability. This approach, called the long method remover or LMR, uses refactoring enabling conditions based on program analysis and code metrics to identify four refactoring techniques and uses a technique embedded in JDeodorant to identify extract method. For effective refactoring set suggestion, LMR uses two criteria: code analyzability level and the number of statements impacted by the refactorings. LMR also uses side effect analysis to ensure behavior preservation. To evaluate LMR, we apply it to the core package of a real world Java application. Our evaluation criteria are 1) the preservation of code functionality, 2) the removal rate of long method characteristics, and 3) the improvement on analyzability. The result showed that the methods that apply suggested refactoring sets can completely remove long method bad smell, still have behavior preservation, and have not decreased analyzability. It is concluded that LMR meets the objectives in almost all classes. We also discussed the issues we found during evaluation as lesson learned. © Copyright 2018 The Institute of Electronics Information and Communication Engineers.",Conference paper,Final,Scopus
Wahler M.; Drofenik U.; Snipes W.,31967865700; 6602691960; 8261920500,Improving code maintainability: A case study on the impact of refactoring,2017,"Proceedings - 2016 IEEE International Conference on Software Maintenance and Evolution, ICSME 2016",,,7816501,493,501,8,9,10.1109/ICSME.2016.52,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013037478&doi=10.1109%2fICSME.2016.52&partnerID=40&md5=154fe30aa5179a08c2e6978952b28744,"It is a fact that a lot of software is written by people without a formal education in software engineering. As an example, material scientists often capture their knowledge in the form of simulation software that contains sophisticated algorithms representing complex physical concepts. Since software engineering is typically not a core skill of these scientists, there is a risk that their software becomes unmaintainable once it reaches a substantial size or structural complexity. This paper reports on a case study in which software engineers consulted magnetics researchers in refactoring their simulation software. This software had grown to 30 kloc of Java and was considered unmaintainable by the stakeholders of the research project The case study describes the process of refactoring a system under the guidance of a software engineer with results supported by static analysis and software metrics. It shows how software engineers evaluated and selected refactorings to apply to the system using their expert judgment with input from static analysis tools and discusses the outcome of refactoring as evaluated by code owners and reported via static analysis metrics. © 2016 IEEE.",Conference paper,Final,Scopus
Rodriguez A.,56972631600,Reducing energy consumption of resource-intensive scientific mobile applications via code refactoring,2017,"Proceedings - 2017 IEEE/ACM 39th International Conference on Software Engineering Companion, ICSE-C 2017",,,7965391,475,476,1,2,10.1109/ICSE-C.2017.33,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026772446&doi=10.1109%2fICSE-C.2017.33&partnerID=40&md5=b7ffb2ce48ae91d2f2c99591dee7398b,"The advent of new computing paradigms such as Mobile Grids and Mobile-edge Clouds, and the increasing number of mobile devices with ever-growing capabilities makes them attractive to users running scientific and HPC applications. However, mobile devices still have limited capabilities when compared to non-mobile devices. More importantly, mobile devices rely on batteries for their power supply. To overcome this problem, this PhD research studies how to reduce energy consumption in mobile devices via code refactoring for such kind of applications. © 2017 IEEE.",Conference paper,Final,Scopus
Rodriguez A.; Mateos C.; Zunino A.,56972631600; 24171844000; 8688799600,Improving scientific application execution on android mobile devices via code refactorings,2017,Software - Practice and Experience,47,5,,763,796,33,13,10.1002/spe.2419,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84977545674&doi=10.1002%2fspe.2419&partnerID=40&md5=c451ef3f9e7e4ec6f9895ab5a164f2d3,"The increasing number of mobile devices with ever-growing capabilities makes them useful for running scientific applications. However, these applications have high computational demands, whereas mobile devices have limited capabilities when compared with non-mobile devices. More importantly, mobile devices rely on batteries for their power supply. We initially measure the battery consumption of different versions of known micro-benchmarks representing common programming primitives found in scientific applications. Then, we analyze the performance of such micro-benchmarks in CPU-intensive mobile applications. We apply good programming practices and code refactorings to reduce battery consumption of scientific mobile applications. Our results show the reduction in energy usage from applying these refactorings to three scientific applications, and we consequently propose guidelines for high-performance computing applications. Our focus is on Android, the dominant mobile operating system. As a long-term contribution, our results represent one more step in the progress towards hybrid distributed infrastructures comprising fixed and mobile nodes, that is, the so-called mobile grids. Copyright © 2016 John Wiley & Sons, Ltd. Copyright © 2016 John Wiley & Sons, Ltd.",Article,Final,Scopus
Kim D.; Hong J.-E.; Yoon I.; Lee S.-H.,56947571000; 7404117852; 25923179800; 56152301200,Code refactoring techniques for reducing energy consumption in embedded computing environment,2016,Cluster Computing,21,1,,1079,1095,16,10,10.1007/s10586-016-0691-5,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85046687691&doi=10.1007%2fs10586-016-0691-5&partnerID=40&md5=e4e951aac764e0fbf8af3d8e98820133,"Code refactoring is the process of restructuring existing computer code without changing its external behavior to enhance reusability and maintainability of software components through improving nonfunctional attributes of the software. However, when we refactor source codes using existing refactoring techniques, those techniques do not consider energy consumption as one of the nonfunctional attributes. Reducing energy consumption is one of the important factors to develop embedded and/or mobile software because it is difficult to provide sustainable services based on limited power resources. This paper suggests newrefactoring techniques for reducing energy consumption to support the restructuring of existing source codes. Especially we define energy-consuming constructs as suspicious codes that are predicted to consume a lot of energy, and then develop the techniques to remove these constructs. Our techniques can improve the performance as well as the energy efficiency of legacy codes. © Springer Science+Business Media New York 2018.",Article,Final,Scopus
Chen Z.; Mohanavilasam M.; Kwon Y.-W.; Song M.,57190860338; 57196117940; 57208480210; 32868182400,Tool Support for Managing Clone Refactorings to Facilitate Code Review in Evolving Software,2017,Proceedings - International Computer Software and Applications Conference,1,,8029620,288,297,9,8,10.1109/COMPSAC.2017.242,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85031938842&doi=10.1109%2fCOMPSAC.2017.242&partnerID=40&md5=dd1dea243a91cbdd86839bdf76064ca1,"Developers often perform copy-and-paste activities. This practice causes the similar code fragment (aka code clones) to be scattered throughout a code base. Refactoring for clone removal is beneficial, preventing clones from having negative effects on software quality, such as hidden bug propagation and unintentional inconsistent changes. However, recent research has provided evidence that factoring out clones is not always to reduce the risk of introducing defects, and it is often difficult or impossible to remove clones using standard refactoring techniques. To investigate which or how clones can be refactored, developers typically spend a significant amount of their time managing individual clone instances or clone groups scattered across a large code base. To address the problem, this paper presents a technique for managing clone refactorings, Pattern-based clone Refactoring Inspection (PRI), using refactoring pattern templates. By matching the refactoring pattern templates against a code base, it summarizes refactoring changes of clones, and detects the clone instances not consistently factored out as potential anomalies. PRI also provides novel visualization user interfaces specifically designed for inspecting clone refactorings. In the evaluation, PRI analyzes clone instances in six open source projects. It identifies clone refactorings with 94.1% accuracy and detects inconsistent refactorings with 98.4% accuracy. Our results show that PRI should help developers effectively inspect evolving clones and correctly apply refactorings to clone groups. © 2017 IEEE.",Conference paper,Final,Scopus
Kanwal J.; Inoue K.; Maqbool O.,55234249400; 7601540520; 56028915800,Refactoring patterns study in code clones during software evolution,2017,"IWSC 2017 - 11th IEEE International Workshop on Software Clones, co-located with SANER 2017",,,7880508,,,,4,10.1109/IWSC.2017.7880508,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85017244945&doi=10.1109%2fIWSC.2017.7880508&partnerID=40&md5=da1f76b6a9a4bad54fe5e4fb244c92e1,"To investigate how code clones are handled by de-velopers when they perform refactorings during software releas-es, we performed a longitudinal study on different versions of five Java systems. Our results show that a small proportion of code clones are refactored during the releases and code clones of same clone class are refactored consistently. © 2017 IEEE.",Conference paper,Final,Scopus
Paravan C.A.,57203582111,Impact Assessment of Refactoring Presentation Models in E-Commerce Sites,2018,"2018 IEEE Biennial Congress of Argentina, ARGENCON 2018",,,8646285,,,,0,10.1109/ARGENCON.2018.8646285,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063427900&doi=10.1109%2fARGENCON.2018.8646285&partnerID=40&md5=2e487728eebc9f52b5ccbe2bfcebff73,"El comercio electrónico es hoy una realidad creciente en la Web, ya que continuos estudios de campo realizados en éstos confirman el creciente uso de los mismos para realizar compras. En este contexto, es imprescindible analizar los diferentes modelos que definen una aplicación web de manera de mejorar la usabilidad de cada uno para brindar una mejor experiencia de usuario a los clientes de los sitios.(/p)(p)En este trabajo se presentan conceptos relacionados a una aplicación web y los tres modelos que la componen (el de la aplicación o contenido, el modelo de navegación, y el modelo de presentación), se define genéricamente qué es un refactoring, caracterizando específicamente la refactorización del modelo de presentación, se repasa el catálogo de refactoring específico del modelo de presentación de sitios de comercio electrónico presentado en un trabajo anterior, y se muestran y analizan los resultados de la evaluación de usabilidad de los mismos. © 2018 IEEE.",Conference paper,Final,Scopus
Zhao J.; Zhang M.,55516416900; 57208130416,Refactoring OpenMP code based on MapReduce Model,2018,"Proceedings - 16th IEEE International Symposium on Parallel and Distributed Processing with Applications, 17th IEEE International Conference on Ubiquitous Computing and Communications, 8th IEEE International Conference on Big Data and Cloud Computing, 11th IEEE International Conference on Social Computing and Networking and 8th IEEE International Conference on Sustainable Computing and Communications, ISPA/IUCC/BDCloud/SocialCom/SustainCom 2018",,,8672303,1040,1041,1,3,10.1109/BDCloud.2018.00153,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063893349&doi=10.1109%2fBDCloud.2018.00153&partnerID=40&md5=790c782a8d4c3d2c91b36160e7d55806,"In multi-core era, much software has been developed using parallel programming technology, such as OpenMP. However, with the rise of the Internet, the data is growing dramatically. Due to the limitation of computing power and memory capacity, OpenMP applications cannot satisfy the needs of user efficiently. The flexibility and scalability of the cloud provide a new way to solve this problem. MapReduce, a parallel programming model in cloud computing, provides a solution for massive data processing. So, it needs to be considered that how to refactor the legacy OpenMP code to MapReduce model. A related refactoring approach was proposed, and a prototype tool, O2MR, was developed for the above-mentioned problem in this paper. Through experiment validation, the approach is effective, and the tool is helpful in the process of refactoring. © 2018 IEEE.",Conference paper,Final,Scopus
Sehgal R.; Mehrotra D.; Bala M.,56016029300; 36699870600; 57202211888,Analysis of code smell to quantify the refactoring,2017,International Journal of System Assurance Engineering and Management,8,,,1750,1761,11,5,10.1007/s13198-017-0658-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85035028735&doi=10.1007%2fs13198-017-0658-9&partnerID=40&md5=128d36596d1a46267bad9a3165bd4b34,"During development process software may encounter design flaws which are referred as “code smell”. These code smells are potential faults that can be handled using suitable refactoring approach. Refactoring being an expensive process is a thought provocation task, and there is a need to identify the relationship between code smells and design metrics by considering expert’s opinion. The approach adopted in this paper ranks the design metrics, according to their criticality and need using AHP. This method helps to identify refactoring approach that may be used to improve the code and needs to be implemented before the execution phase. The proposed approach is explained considering a case study of medium sized software. © 2017, The Society for Reliability Engineering, Quality and Operations Management (SREQOM), India and The Division of Operation and Maintenance, Lulea University of Technology, Sweden.",Article,Final,Scopus
Zafeiris V.E.; Poulias S.H.; Diamantidis N.A.; Giakoumakis E.A.,15752340900; 57191479986; 6506193987; 6601998278,Automated refactoring of super-class method invocations to the Template Method design pattern,2017,Information and Software Technology,82,,,19,35,16,14,10.1016/j.infsof.2016.09.008,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84990940968&doi=10.1016%2fj.infsof.2016.09.008&partnerID=40&md5=dc07a4e02eda5677134f94917fb608d3,"Context: Implementation inheritance, i.e., overriding of concrete method implementations through subtyping, is prone to potential class contract violations. Call Super is a code pattern that employs implementation inheritance for extending a method's behaviour. In Call Super the overriding method includes in its body an invocation to the overridden method. TEMPLATE METHOD is a design pattern that enables extensions to a multi-step procedure without overriding its concrete implementation. Instead, subclasses provide different variants of the template method's behaviour through implementation of abstract method definitions (interface inheritance). Objective: This work studies the automated refactoring of Call Super to TEMPLATE METHOD, contributing, thus, to replacement of implementation inheritance with interface inheritance. Method: We introduce an algorithm for the discovery of refactoring candidates that is based on an extensive set of refactoring preconditions. Moreover, we specify the source code transformation for refactoring a Call Super instance to TEMPLATE METHOD. An implementation of the proposed approach is evaluated on a set of open source Java projects. Results: The evaluation results highlight (a) the frequent occurrence of the Call Super pattern among method overridings, (b) the potential provided by our method for discovery and elimination of several non-trivial Call Super instances and (c) the resulting code improvement, as reflected by the Specialization Index metric and the alignment of refactored code with the programmer's intent. The application of all refactorings identified on a set of benchmark projects and the successful execution of their test suites provide empirical evidence on the soundness of the refactoring procedure. Runtime performance results support the scalability of the proposed method. Conclusion: The proposed method automates the replacement of implementation inheritance with interface inheritance through refactoring Call Super instances to TEMPLATE METHOD. The empirical evaluation of the method supports its applicability, soundness and runtime efficiency. © 2016 Elsevier B.V.",Article,Final,Scopus
Silva I.P.S.C.; Alves E.L.G.; Andrade W.L.,57195280921; 35185930600; 18036483300,Analyzing automatic test generation tools for refactoring validation,2017,"Proceedings - 2017 IEEE/ACM 12th International Workshop on Automation of Software Testing, AST 2017",,,7962330,38,44,6,6,10.1109/AST.2017.9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026775305&doi=10.1109%2fAST.2017.9&partnerID=40&md5=42291a1307e687a1a53f81038cb659de,"Refactoring edits are very common during agile development. Due to their inherent complexity, refactorings are know to be error prone. In this sense, refactoring edits require validation to check whether no behavior change was introduced. A valid way for validating refactorings is the use of automatically generated regression test suites. However, although popular, it is not certain whether the tools for generating tests (e.g., Randoop and EvoSuite) are in fact suitable in this context. This paper presents an exploratory study that investigated the efficiency of suites generated by automatic tools regarding their capacity of detecting refactoring faults. Our results show that both Randoop and EvoSuite suites missed more than 50% of all injected faults. Moreover, their suites include a great number of tests that could not be run integrally after the edits (obsolete test cases). © 2017 IEEE.",Conference paper,Final,Scopus
Mkaouer M.W.; Kessentini M.; Bechikh S.; Ó Cinnéide M.; Deb K.,55904259300; 25653537200; 25924742700; 55890614500; 7006019904,On the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,2016,Empirical Software Engineering,21,6,,2503,2545,42,61,10.1007/s10664-015-9414-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84951756385&doi=10.1007%2fs10664-015-9414-4&partnerID=40&md5=9b6ecf0a25cc8eb003e321aff9f5b63c,"Search-based software engineering (SBSE) solutions are still not scalable enough to handle high-dimensional objectives space. The majority of existing work treats software engineering problems from a single or bi-objective point of view, where the main goal is to maximize or minimize one or two objectives. However, most software engineering problems are naturally complex in which many conflicting objectives need to be optimized. Software refactoring is one of these problems involving finding a compromise between several quality attributes to improve the quality of the system while preserving the behavior. To this end, we propose a novel representation of the refactoring problem as a many-objective one where every quality attribute to improve is considered as an independent objective to be optimized. In our approach based on the recent NSGA-III algorithm, the refactoring solutions are evaluated using a set of 8 distinct objectives. We evaluated this approach on one industrial project and seven open source systems. We compared our findings to: several other many-objective techniques (IBEA, MOEA/D, GrEA, and DBEA-Eps), an existing multi-objective approach a mono-objective technique and an existing refactoring technique not based on heuristic search. Statistical analysis of our experiments over 31 runs shows the efficiency of our approach. © 2015, Springer Science+Business Media New York.",Article,Final,Scopus
Khatchadourian R.; Masuhara H.,24469948000; 7103057135,Proactive Empirical Assessment of New Language Feature Adoption via Automated Refactoring: The Case of Java 8 Default Methods,2018,"Art, Science, and Engineering of Programming",2,3,6,,,,7,10.22152/programming-journal.org/2018/2/6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85072285926&doi=10.22152%2fprogramming-journal.org%2f2018%2f2%2f6&partnerID=40&md5=56fe2b62a79ce3fb7b04f3e0362344d3,"Programming languages and platforms improve over time, sometimes resulting in new language features that offer many benefits. However, despite these benefits, developers may not always be willing to adopt them in their projects for various reasons. In this paper, we describe an empirical study where we assess the adoption of a particular new language feature. Studying how developers use (or do not use) new language features is important in programming language research and engineering because it gives designers insight into the usability of the language to create meaning programs in that language. This knowledge, in turn, can drive future innovations in the area. Here, we explore Java 8 default methods, which allow interfaces to contain (instance) method implementations. Default methods can ease interface evolution, make certain ubiquitous design patterns redundant, and improve both modularity and maintainability. A focus of this work is to discover, through a scientific approach and a novel technique, situations where developers found these constructs useful and where they did not, and the reasons for each. Although several studies center around assessing new language features, to the best of our knowledge, this kind of construct has not been previously considered. Despite their benefits, we found that developers did not adopt default methods in all situations. Our study consisted of submitting pull requests introducing the language feature to 19 real-world, open source Java projects without altering original program semantics. This novel assessment technique is proactive in that the adoption was driven by an automatic refactoring approach rather than waiting for developers to discover and integrate the feature themselves. In this way, we set forth best practices and patterns of using the language feature effectively earlier rather than later and are able to possibly guide (near) future language evolution. We foresee this technique to be useful in assessing other new language features, design patterns, and other programming idioms. © Raffi Khatchadourian and Hidehiko Masuhara.",Article,Final,Scopus
Schlesinger S.; Herber P.; Göthel T.; Glesner S.,57072959500; 26424642900; 35193805300; 22984923100,Proving correctness of refactorings for hybrid simulink models with control flow,2017,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),10107 LNCS,,,71,86,15,0,10.1007/978-3-319-51738-4_6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85011000193&doi=10.1007%2f978-3-319-51738-4_6&partnerID=40&md5=79a6096d0d8346a4d78e55e5efe4f688,"Hybrid models are highly relevant for the development of embedded systems because they cover both their continuous and discrete aspects. To master the increasing complexity of embedded systems design, transformation techniques such as automated refactoring play an important role, as they allow for simplifying (sub)models. In safety-critical environments, it is crucial to formally verify the behavioural equivalence of source and transformed target model. For data-flow models that contain control flow entities, this is a major challenge because small deviations of trigger values at control flow elements can yield diverging behaviour of the systems. In this paper, we present our approach that enables the semi-automated verification of the behavioural equivalence of hybrid MATLAB/Simulink models. To this end, we define a static analysis that derives proof obligations to estimate the worst case deviation between model and refactored model. Our approach can be applied to many practical applications such as in the automotive or aerospace industry where MATLAB/Simulink is a de-facto standard. © Springer International Publishing AG 2017.",Article,Final,Scopus
Paltoglou A.; Zafeiris V.E.; Giakoumakis E.A.; Diamantidis N.A.,57203242918; 15752340900; 6601998278; 6506193987,Automated refactoring of client-side JavaScript code to ES6 modules,2018,"25th IEEE International Conference on Software Analysis, Evolution and Reengineering, SANER 2018 - Proceedings",2018-March,,8330227,402,412,10,2,10.1109/SANER.2018.8330227,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051011470&doi=10.1109%2fSANER.2018.8330227&partnerID=40&md5=02b9b67e995071c34c80545babfa2598,"JavaScript (JS) is a dynamic, weakly-typed and object-based programming language that expanded its reach, in recent years, from the desktop web browser to a wide range of runtime platforms in embedded, mobile and server hosts. Moreover, the scope of functionality implemented in JS scaled from DOM manipulation in dynamic HTML pages to full-scale applications for various domains, stressing the need for code reusability and maintainability. Towards this direction, the ECMAScript 6 (ES6) revision of the language standardized the syntax for class and module definitions, streamlining the encapsulation of data and functionality at various levels of granularity. This work focuses on refactoring client-side web applications for the elimination of code smells, relevant to global variables and functions that are declared in JS files linked to a web page. These declarations 'pollute' the global namespace at runtime and often lead to name conflicts with undesired effects. We propose a method for the encapsulation of global declarations through automated refactoring to ES6 modules. Our approach transforms each linked JS script of a web application to an ES6 module with appropriate import and export declarations that are inferred through static analysis. A prototype implementation of the proposed method, based on WALA libraries, has been evaluated on a set of open source projects. The evaluation results support the applicability and runtime efficiency of the proposed method. © 2018 IEEE.",Conference paper,Final,Scopus
Cruz L.; Abreu R.,57143791700; 16479696600,Using automatic refactoring to improve energy efficiency of android apps,2018,"Avances en Ingenieria de Software a Nivel Iberoamericano, CIbSE 2018",,,,163,176,13,8,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85054101566&partnerID=40&md5=17c6ddb6a7220820853221bd95398946,"The ever-growing popularity of mobile phones has brought additional challenges to the software development lifecycle. Mobile applications (apps, for short) ought to provide the same set of features as conventional software, with limited resources: Such as, limited processing capabilities, storage, screen and, not less important, power source. Although energy efficiency is a valuable requirement, developers often lack knowledge of best practices. In this paper, we study whether or not automatic refactoring can aid developers ship energy efficient apps. We leverage a tool, Leafactor, with five energy code smells that tend to go unnoticed. We use Leafactor to analyze code smells in 140 free and open source apps. As a result, we detected and fixed code smells in 45 apps, from which 40% have successfully merged our changes into the official repository. © 2018 Conferencia Iberoamericana de Software Engineering - CIbSE. All Rights Reserved.",Conference paper,Final,Scopus
Kim J.; Batory D.; Dig D.,54397162600; 7004911762; 13404654100,X15: A tool for refactoring Java software product lines,2017,ACM International Conference Proceeding Series,2,,,28,31,3,1,10.1145/3109729.3109750,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85032298161&doi=10.1145%2f3109729.3109750&partnerID=40&md5=53b3ba4800330e6a04b4295ecb8e1d7c,X15 is the first tool that can apply common object-oriented refactorings to Java Software Product Lines (SPLs). X15 is also the first tool that programmers can write custom scripts (to call refactorings programmatically) to retrofit design patterns into Java SPLs. We motivate and illustrate X15's unique capabilities in this paper. © 2017 ACM.,Conference paper,Final,Scopus
Ferreira I.; Fernandes E.; Cedrim D.; Ucha A.; Bibiano A.C.; Garcia A.; Correia J.L.; Santos F.; Nunes G.; Barbosa C.; Fonseca B.; De Mello R.,57193160247; 37123675100; 57194528845; 57202890868; 57202890121; 7404608626; 57202890543; 57202887579; 57202893479; 57202890969; 36175426900; 37025865700,Poster: The buggy side of code refactoring: Understanding the relationship between refactorings and bugs,2018,Proceedings - International Conference on Software Engineering,,,,406,407,1,11,10.1145/3183440.3195030,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049680463&doi=10.1145%2f3183440.3195030&partnerID=40&md5=4c3f6ac1c4aff9a617e89a8396b5b9a9,"Code refactoring is widely practiced by software developers. There is an explicit assumption that code refactoring improves the structural quality of a software project, thereby also reducing its bug proneness. However, refactoring is often applied with different purposes in practice. Depending on the complexity of certain refactorings, developers might unconsciously make the source code more susceptible to have bugs. In this paper, we present a longitudinal study of 5 Java open source projects, where 20,689 refactorings, and 1,033 bug reports were analyzed. We found that many bugs are introduced in the refactored code as soon as the first immediate change is made on it. Furthermore, code elements affected by refactorings performed in conjunction with other changes are more prone to have bugs than those affected by pure refactorings. © 2018 Authors.",Conference paper,Final,Scopus
Derezi?ska A.,6508199259,A Structure-Driven Process of Automated Refactoring to Design Patterns,2018,Advances in Intelligent Systems and Computing,656,,,39,48,9,1,10.1007/978-3-319-67229-8_4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029530678&doi=10.1007%2f978-3-319-67229-8_4&partnerID=40&md5=50eda743b75a0bfc8065d4d2cd2d51d3,"Design patterns can be introduced into an existing code by a code restructuring. It is counted to one of goals of code refactoring. This paper presents a process that automates this kind of refactoring. The approach is based on a structural code analysis aimed at design pattern relevance. The process consists of three main phases: code analysis, determination of a refactoring range, and realization of code restructuring. The latter is a complex code2code transformation, which comprises a series of code refactoring steps. A decision about a range of a design pattern application is taken by a user or can be automated. In both cases, it is supported by a software relevance metric. A framework for the whole process has been implemented as an extension of Eclipse. Code refactoring to exemplary design patterns can be performed in a prototype tool for Java programs. © 2018, Springer International Publishing AG.",Conference paper,Final,Scopus
Khlif W.; Ben Ayed N.E.; Ben-Abdallah H.,35766583000; 55932710300; 57192050350,Evares: A quality-driven refactoring method for business process models,2017,ICEIS 2017 - Proceedings of the 19th International Conference on Enterprise Information Systems,3,,,409,416,7,1,10.5220/0006315504090416,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85023179884&doi=10.5220%2f0006315504090416&partnerID=40&md5=c986bb9d3071f37c1f7ea8f0ca79bb9b,"The business performance of an enterprise tightly depends on the quality of its business process model (BPM). This dependence prompted several propositions to improve quality sub-characteristics (e.g. modifiability and reusability) of a BPM through transformation operations to change the internal structure of the model while preserving its external behaviour. Each transformation may improve certain metrics related to one quality sub characteristic while degrading others. Consequently, one challenge of this model transformation-based quality improvement approach is how to identify the application order of the transformations to derive the ""best"" quality model. This paper proposes a local optimization-based, heuristic method to decide on the application order of the transformations to produce the best quality BPM. The method is guided by both the perspectives, and the impact of each transformation on the quality metrics pertinent to the perspectives as well as the quality sub characteristics of interest to the designer. The method's and an experimental evaluation are presented. © Copyright 2017 by SCITEPRESS - Science and Technology Publications, Lda.",Conference paper,Final,Scopus
Selmadji A.; Seriai A.-D.; Bouziane H.L.; Dony C.; Tibermacine C.,57203509616; 8707995100; 15921994800; 57203739761; 14051139200,Refactoring object-oriented applications for a deployment in the cloud workflow generation based on static analysis of source code,2018,ENASE 2018 - Proceedings of the 13th International Conference on Evaluation of Novel Approaches to Software Engineering,2018-March,,,111,123,12,1,10.5220/0006699101110123,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051948970&doi=10.5220%2f0006699101110123&partnerID=40&md5=ea6d7c233eba078d5c6272a1394fd7be,"Cloud Computing delivers to customers computing/storage resources as services via the internet. It is characterized by its elastic nature and its payment model (pay-as-you-go). To optimize the use of these resources, one of the requirements related to this type of environment is to dynamically configure the applications to reduce the costs of their deployment.The dynamic configuration requires the ability to determine which resources are used, as well as when and where they are utilized. This can be done using workflows. In fact, several works rely on workflows to reduce execution costs in the cloud. Unlike workflows, OO applications have an architecture which exposes little or no behavioral (temporal) aspect. Hence, to execute an OO application in the cloud, the entire application needs to be deployed and all its used resources need to be allocated during its entire execution time. To reduce execution costs, we propose a re-engineering process aiming to restructure these applications from OO architectural style to workflow style. In this paper, we focus on the first step of the process which has as a goal generating a workflow from OO source code. Copyright © 2018 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved",Conference paper,Final,Scopus
Khatchadourian R.; Masuhara H.,24469948000; 7103057135,Defaultification refactoring: A tool for automatically converting Java methods to default,2017,ASE 2017 - Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering,,,8115716,984,989,5,6,10.1109/ASE.2017.8115716,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041444951&doi=10.1109%2fASE.2017.8115716&partnerID=40&md5=a6cee923069089aca7a7508e4a893ff9,"Enabling interfaces to declare (instance) method implementations, Java 8 default methods can be used as a substitute for the ubiquitous skeletal implementation software design pattern. Performing this transformation on legacy software manually, though, may be non-trivial. The refactoring requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods. All of this is necessary to preserve type-correctness and confirm semantics preservation. We demonstrate an automated refactoring tool called MIGRATE Skeletal Implementation to Interface for transforming legacy Java code to use the new default construct. The tool, implemented as an Eclipse plug-in, is driven by an efficient, fully-automated, type constraint-based refactoring approach. It features an extensive rule set covering various corner-cases where default methods cannot be used. The resulting code is semantically equivalent to the original, more succinct, easier to comprehend, less complex, and exhibits increased modularity. A demonstration can be found at http://youtu.be/YZHIy0yePh8. © 2017 IEEE.",Conference paper,Final,Scopus
Kulkarni C.,57192553850,Notice of Removal: A qualitative approach for refactoring of code clone opportunities using graph and tree methods,2017,"2016 International Conference on Information Technology, InCITe 2016 - The Next Generation IT Summit on the Theme - Internet of Things: Connect your Worlds",,,7857608,154,159,5,0,10.1109/INCITE.2016.7857608,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85015888920&doi=10.1109%2fINCITE.2016.7857608&partnerID=40&md5=d098323962ccc5a816dc47f54e20a334,"Reusing of code has been a very common practice in software development. This practice has been implemented to reduce programming time and efforts greatly. This copying and pasting behavior of programmers leads to cloning of codes and therefore has a very serious impact on the maintenance of the software systems. Many clone detection tool has been proposed to find out the copied code. However, refactoring of code is still a challenging part as most of the ongoing tools depend on detection of clone rather than the ability to make decision on refactorability. These tools do not guarantee whether such codes can be safely refactored or not. Our aim mainly lies on detecting the possibility of refactoring a code. To find out whether the code clone can be securely refactored or not, three methods are applied: Nesting Structure Mapping, Statement Mapping and Precondition Examination. In order to refactor the code, we apply some techniques like Pull-Up Method and Push-Down Method. In our approach, we have tried to find the refactorable code using the methods and also refactored the code so as to remove the problem of code cloning. © 2016 IEEE.",Retracted,Final,Scopus
Sagardui G.; Etxeberria L.; Agirre J.A.; Arrieta A.; Nicolas C.F.; Martin J.M.,13104721400; 13105885100; 55597868500; 56514865400; 7005466536; 57194763277,A configurable validation environment for refactored embedded software: An application to the vertical transport domain,2017,"Proceedings - 2017 IEEE 28th International Symposium on Software Reliability Engineering Workshops, ISSREW 2017",,,8109240,16,19,3,8,10.1109/ISSREW.2017.9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040610532&doi=10.1109%2fISSREW.2017.9&partnerID=40&md5=da423f68b506e63cd8cb939ded748d3d,"As systems evolve, their embedded software needs constantly to be refactored. Moreover, given the different needs of different customers, embedded systems require to be customizable. The variability of these systems is large, and requires automated testing solutions. In this paper we propose a methodology that automatically generates validation environments for highly configurable embedded software that is being refactored. The method has allowed for systematically testing a real-world industrial case study involving the software in charge of controlling the doors of an elevator. Finally, we extract the lessons learned from its application. © 2017 IEEE.",Conference paper,Final,Scopus
Ouni A.; Kessentini M.; Ó Cinnéide M.; Sahraoui H.; Deb K.; Inoue K.,50761492200; 25653537200; 55890614500; 57196894039; 7006019904; 7601540520,MORE: A multi-objective refactoring recommendation approach to introducing design patterns and fixing code smells,2017,Journal of Software: Evolution and Process,29,5,e1843,,,,41,10.1002/smr.1843,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85014656546&doi=10.1002%2fsmr.1843&partnerID=40&md5=9a7e0b9b3103399b1cc81a6c5fedfab1,"Refactoring is widely recognized as a crucial technique applied when evolving object-oriented software systems. If applied well, refactoring can improve different aspects of software quality including readability, maintainability, and extendibility. However, despite its importance and benefits, recent studies report that automated refactoring tools are underused much of the time by software developers. This paper introduces an automated approach for refactoring recommendation, called MORE, driven by 3 objectives: (1) to improve design quality (as defined by software quality metrics), (2) to fix code smells, and (3) to introduce design patterns. To this end, we adopt the recent nondominated sorting genetic algorithm, NSGA-III, to find the best trade-off between these 3 objectives. We evaluated the efficacy of our approach using a benchmark of 7 medium and large open-source systems, 7 commonly occurring code smells (god class, feature envy, data class, spaghetti code, shotgun surgery, lazy class, and long parameter list), and 4 common design pattern types (visitor, factory method, singleton, and strategy). Our approach is empirically evaluated through a quantitative and qualitative study to compare it against 3 different state-of-the art approaches, 2 popular multiobjective search algorithms, and random search. The statistical analysis of the results confirms the efficacy of our approach in improving the quality of the studied systems while successfully fixing 84% of code smells and introducing an average of 6 design patterns. In addition, the qualitative evaluation shows that most of the suggested refactorings (an average of 69%) are considered by developers to be relevant and meaningful. Copyright © 2017 John Wiley & Sons, Ltd.",Article,Final,Scopus
Liu W.; Huang X.; Hu Z.; Nguyen H.P.,58362176400; 57201470428; 57203298202; 57203768149,Context-aware automatic code segment extraction and refactoring in object-oriented systems,2018,International Journal of Performability Engineering,14,7,,1493,1502,9,0,10.23940/ijpe.18.07.p13.14931502,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052885417&doi=10.23940%2fijpe.18.07.p13.14931502&partnerID=40&md5=93051858eeec4c836cdd8cc3f471c160,"Refactoring is a very important technology to improve the reusability and maintainability of existing code, and it is widely used in software development. In order to extract the code segment into a new method easily and cover the shortage of Eclipse in refactoring, the method of Context-Aware Automatic Code Segment Extraction and Refactoring (CAACSER) is proposed. By analyzing the context of the code, the input parameter class, and the output parameter class are introduced to handle complex code segments. The experimental results show that the CAACSER effectively solves some problems and drawbacks of many existing tools in code segment extraction, which acts as a basic step for realizing automatic and semi-automatic refactoring methods. The visualization tool of CAACSER can also carry out reasonable optimizations of the code without changing the systems' behaviors. © 2018 Totem Publishers Ltd. All rights reserved.",Article,Final,Scopus
Sam G.; Cameron N.; Potanin A.,57193559882; 7103056181; 37062710900,Automated refactoring of rust programs,2017,ACM International Conference Proceeding Series,,,a14,,,,2,10.1145/3014812.3014826,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85014910441&doi=10.1145%2f3014812.3014826&partnerID=40&md5=8dc089285fa1680b8ab169969d42a1cc,"Rust is a modern systems programming language developed by Mozilla Research and the Rust community. Rust supports modern constructs such as ownership, lifetimes, traits, and macros, whilst supporting systems programming idioms with low-cost abstractions and memory safety without garbage collection. We describe a new refactoring tool for Rust developers, including discussing the issues and unusual decisions encountered due to the complexities of modern systems languages. We outline lessons learned and hope our paper will help in- form design of future programming languages and refactoring tools. The resulting refactoring tool is written in Rust and available from Github under an MIT license [8] © 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.",Conference paper,Final,Scopus
,,"Retraction: Does Refactoring of Test Smells Induce Fixing Flaky Tests? (Proceedings - 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017)",2017,"Proceedings - 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017",2017-January,,,1,12,11,1,10.1109/ICSME.2017.12,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85167876189&doi=10.1109%2fICSME.2017.12&partnerID=40&md5=c627fb6dfa58afda5b507534e975d69e,[No abstract available],Erratum,Final,Scopus
Tavares C.S.; Ferreira F.; Figueiredo E.,57205444812; 57200225072; 18433988600,A systematic mapping of literature on software refactoring tools; [Um Mapeamento Sistemático da Literatura sobre Ferramentas de Refatoração de Software],2018,ACM International Conference Proceeding Series,,,,81,88,7,2,10.1145/3229345.3229357,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85060041285&doi=10.1145%2f3229345.3229357&partnerID=40&md5=5bc897f0e4336f4df00a3a2cbc4112f4,"Refactoring consists of improving the internal structure of the code without changing the external behavior of a software system. However, the task of refactoring is very costly in the development of an information system. Thus, many tools have been proposed to support refactoring the source code. In order to find tools cited in the literature, this work presents a Systematic Literature Mapping about refactoring. As a result, this paper summarizes the refactoring tools that have been published in the last 5 years in terms of the tool profiles developed, which programming languages have support for refactoring and which are the main refactoring strategies that are handled by tools. It has been identified that publications on refactoring have remained constant over the past 5 years. Also, most of the refactoring works describe tools, being they for systems written in the Java language, that perform code refactoring automatically and the main refactorings are: Move Method, Pull Up Method, Extract Class and Code Clone. Finally, we performed an analysis of the data returned by the DBLP library. As a result, it was observed that the papers returned by the DBLP have a high level of similarity with the other research bases studied. © 2018 Association for Computing Machinery.",Conference paper,Final,Scopus
Singh J.; Khilar P.M.; Mohapatra D.P.,55994544300; 22979419500; 9737930600,Code refactoring using slice-based cohesion metrics and aspect-oriented programming,2018,International Journal of Business Information Systems,27,1,,45,68,23,8,10.1504/IJBIS.2018.088570,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038621924&doi=10.1504%2fIJBIS.2018.088570&partnerID=40&md5=35a939dc5ace002ef9a701612f4426d1,"Software restructuring is essential for maintaining software quality. It is a usual practice that we first design the software and then go for coding. After coding, if there is any change in the requirement or if the output is incorrect, then we have to modify the code again. For each small code modification, it is not feasible to alter the design. These minor changes made to the code causes decay in the software design. Software refactoring is used to restructure the code to improve the design and quality of the software. In this paper, we propose an approach for performing code refactoring. We use slice-based cohesion metrics to identify the target methods that require refactoring. After identifying the target methods, we use program slicing to divide the target method into two parts. Finally, we use the concept of aspects to alter the code structure in a manner that does not change the external behaviour of the original module. Copyright © 2018 Inderscience Enterprises Ltd.",Article,Final,Scopus
Arima R.; Higo Y.; Kusumoto S.,57196403347; 7004831134; 7102741360,Toward refactoring evaluation with code naturalness,2018,Proceedings - International Conference on Software Engineering,,,,316,319,3,5,10.1145/3196321.3196362,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051667043&doi=10.1145%2f3196321.3196362&partnerID=40&md5=56c0428e9a66a8bdd2ba8c3368449652,"Refactoring evaluation is a challenging research topic because right and wrong of refactoring depend on various aspects of development context such as developers' skills, development cost, deadline and so on. Many techniques have been proposed to evaluate refactoring objectively. However, those techniques do not consider individual contexts of software development. Currently, the authors are trying to evaluate refactoring automatically and objectively with considering development contexts. In this paper, we propose to evaluate refactoring with code naturalness. Our technique is based on a hypothesis: if a given refactoring raises the naturalness of existing code, the refactoring is beneficial. In this paper, we also report our pilot study on open source software. © 2018 ACM.",Conference paper,Final,Scopus
Tarwani S.; Sureka A.,57190585453; 55922095600,Investigating the effectiveness of greedy algorithm on open source software systems for determining refactoring sequence,2017,CEUR Workshop Proceedings,2017,,,43,50,7,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040636970&partnerID=40&md5=c0e2560ccf2c033b2f4c6f201e1323fd,"The deeper problem in the source code are the bad smells that indicates something is wrong and if they are not detected timely, then they lead towards the complete deterioration of the working software causing major financial and productivity loss. Refactoring helps in removing these bad smells by improving internal quality attributes of the software without affecting its external behaviour. However refactoring needs to be applied in a controlled manner. In this study an approach has been propose for determining an optimal refactoring sequence that will maximize the source-code maintainability using greedy algorithm. The proposed approach selects the most optimum sequence at every step-in hope of finding the global optimum solution. We conduct an empirical analysis on four open-source software and select those classes that have bad smells greater than or equal to four. Further filtration is done by selecting those classes from the group that have high value of source code lines. We demonstrate the effectiveness of our approach using concrete examples of the experimental dataset and presenting summary results. Copyright © 2017 for this paper by its authors.",Conference paper,Final,Scopus
Mumtaz H.; Alshayeb M.; Mahmood S.; Niazi M.,57200160465; 6506030177; 8644998900; 14045585000,An empirical study to improve software security through the application of code refactoring,2018,Information and Software Technology,96,,,112,125,13,38,10.1016/j.infsof.2017.11.010,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041469974&doi=10.1016%2fj.infsof.2017.11.010&partnerID=40&md5=775dd57f8564b45db0182d44bf7deba5,"Context: Code bad smells indicate design flaws that can degrade the quality of software and can potentially lead to the introduction of faults. They can be eradicated by applying refactoring techniques. Code bad smells that impact the security perspective of software should be detected and removed from their code base. However, the existing literature is insufficient to support this claim and there are few studies that empirically investigate bad smells and refactoring opportunities from a security perspective. Objective: In this paper, we investigate how refactoring can improve the security of an application by removing code bad smell. Method: We analyzed three different code bad smells in five software systems. First, the identified code bad smells are filtered against security attributes. Next, the object-oriented design and security metrics are calculated for the five investigated systems. Later, refactoring is applied to remove security-related code bad smells. The correctness of detection and refactoring of investigated code smells are then validated. Finally, both traditional object-oriented and security metrics are again calculated after removing bad smells to assess its impact on the design and security attributes of systems. Results: We found ‘feature envy’ to be the most abundant security bad smell in investigated projects. The ‘move method’ and ‘move field’ are commonly applied refactoring techniques because of the abundance of feature envy. Conclusion: The results of security metrics indicate that refactoring helps improve the security of an application without compromising the overall quality of software systems. © 2017 Elsevier B.V.",Article,Final,Scopus
Stratou G.; Van Der Schalk J.; Hoegen R.; Gratch J.,39862287600; 21834707700; 56897184900; 6701390206,Refactoring facial expressions: An automatic analysis of natural occurring facial expressions in iterative social dilemma,2017,"2017 7th International Conference on Affective Computing and Intelligent Interaction, ACII 2017",2018-January,,,427,433,6,17,10.1109/ACII.2017.8273635,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047418893&doi=10.1109%2fACII.2017.8273635&partnerID=40&md5=f1e55e10d4364f15382c40e176623b81,"Many automatic facial expression recognizers now output individual facial action units (AUs), but several lines of evidence suggest that it is the combination of AUs that is psychologically meaningful: e.g., (a) constraints arising from facial morphology, (b) prior published evidence, (c) claims arising from basic emotion theory. We performed factor analysis on a large data set and recovered factors that have been discussed in the literature as psychologically meaningful. Further we show that some of these factors have external validity in that they predict participant behaviors in an iterated prisoner's dilemma task and in fact with more precision than the individual AUs. These results both reinforce the validity of automatic recognition (as these factors would be expected from accurate AU detection) and suggest the benefits of using such factors for understanding these facial expressions as social signals. © 2017 IEEE.",Conference paper,Final,Scopus
Tanhaei M.; Habibi J.; Mirian-Hosseinabadi S.-H.,36239539500; 56219524600; 24344603600,Automating feature model refactoring: A Model transformation approach,2016,Information and Software Technology,80,,,138,157,19,12,10.1016/j.infsof.2016.08.011,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84985998106&doi=10.1016%2fj.infsof.2016.08.011&partnerID=40&md5=e85f3940783925cd928b9dc1eeba1f27,"Context: Feature model is an appropriate and indispensable tool for modeling similarities and differences among products of the Software Product Line (SPL). It not only exposes the validity of the products’ configurations in an SPL but also changes in the course of time to support new requirements of the SPL. Modifications made on the feature model in the course of time raise a number of issues. Useless enlargements of the feature model, the existence of dead features, and violated constraints in the feature model are some of the key problems that make its maintenance difficult. Objective: The initial approach to dealing with the above-mentioned problems and improving maintainability of the feature model is refactoring. Refactoring modifies software artifacts in a way that their externally visible behavior does not change. Method: We introduce a method for defining refactoring rules and executing them on the feature model. We use the ATL model transformation language to define the refactoring rules. Moreover, we provide an Alloy model to check the feature model and the safety of the refactorings that are performed on it. Results: In this research, we propose a safe framework for refactoring a feature model. This framework enables users to perform automatic and semi-automatic refactoring on the feature model. Conclusions: Automated tool support for refactoring is a key issue for adopting approaches such as utilizing feature models and integrating them into the software development process of companies. In this work, we define some of the important refactoring rules on the feature model and provide tools that enable users to add new rules using the ATL M2M language. Our framework assesses the correctness of the refactorings using the Alloy language. © 2016 Elsevier B.V.",Article,Final,Scopus
Al Dallal J.,6508260263,Predicting move method refactoring opportunities in object-oriented code,2017,Information and Software Technology,92,,,105,120,15,19,10.1016/j.infsof.2017.07.013,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026779685&doi=10.1016%2fj.infsof.2017.07.013&partnerID=40&md5=e8759a94eee6264598740d917fe0afbd,"Context Refactoring is the maintenance process of restructuring software source code to improve its quality without changing its external behavior. Move Method Refactoring (MMR) refers to moving a method from one class to the class in which the method is used the most often. Manually inspecting and analyzing the source code of the system under consideration to determine the methods in need of MMR is a costly and time-consuming process. Existing techniques for identifying MMR opportunities have several limitations, such as scalability problems and being inapplicable in early development stages. Most of these techniques do not consider semantic relationships. Objective We introduce a measure and a corresponding model to precisely predict whether a class includes methods in need of MMR. The measure is applicable once a class has entered the early development stages without waiting for other classes to be developed. Method The proposed measure considers both the cohesion and coupling aspects of methods. In addition, the measure uses structural and semantic data available within the class of interest. A statistical technique is applied to construct prediction models for classes that include methods in need of MMR. The models are applied on seven object-oriented systems to empirically evaluate their abilities to predict MMR opportunities. Results The results show both that the prediction models based on the proposed measure had outstanding prediction abilities and that the measure was able to correctly detect more than 90% of the methods in need of MMR within the predicted classes. Conclusions The proposed measure and corresponding prediction models are expected to greatly assist software engineers both in locating classes that include methods in need of MMR and in identifying these methods within the predicted classes. © 2017 Elsevier B.V.",Article,Final,Scopus
Faiz F.; Easmin R.; Ul Gias A.,57193423078; 56296742100; 35434840600,Achieving better requirements to code traceability: which refactoring should be done first?,2017,"Proceedings - 2016 10th International Conference on the Quality of Information and Communications Technology, QUATIC 2016",,,7814509,9,14,5,8,10.1109/QUATIC.2016.012,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013812097&doi=10.1109%2fQUATIC.2016.012&partnerID=40&md5=9695e58bcbfe7a88ec03f08685c37d13,"During system evolution, trace links among requirements and source code could get distorted due to vocabulary mismatch problem. Nevertheless, researchers have shown that those links can be recovered by code refactoring. Moreover, it is shown that refactoring methods like rename identifier has positive impact in supporting traceability. This leads to the question that will other refactoring methods will have same impact on traceability? If yes, then which refactoring technique should be applied first? For this investigation, we used four refactoring techniques - introducing parameter object, pull up field, inline class and decompose conditional. The methods were applied on two different code bases namely iTrust and eTour. The traceability links were generated by an automated tool named TraceME. From the experiment, we observed that introducing parameter object improves requirements to code traceability. Inline class and decompose conditional show a little but positive influence. Pull up method shows no improvements in traceability. We conclude that introducing parameter object should have high priority to achieve better traceability. © 2016 IEEE.",Conference paper,Final,Scopus
Khatchadourian R.,24469948000,Automated refactoring of legacy Java software to enumerated types,2017,Automated Software Engineering,24,4,,757,787,30,8,10.1007/s10515-016-0208-8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006340197&doi=10.1007%2fs10515-016-0208-8&partnerID=40&md5=916ccd07dcbae7e601f4a37c5ae1dea8,"Modern Java languages introduce several new features that offer significant improvements over older Java technology. In this article we consider the new enum construct, which provides language support for enumerated types. Prior to recent Java languages, programmers needed to employ various patterns (e.g., the weak enum pattern) to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly-desirable properties of the enum construct, most notably, type safety. We present a novel fully-automated approach for transforming legacy Java code to use the new enumeration construct. This semantics-preserving approach increases type safety, produces code that is easier to comprehend, removes unnecessary complexity, and eliminates brittleness problems due to separate compilation. At the core of the proposed approach is an interprocedural type inferencing algorithm which tracks the flow of enumerated values. The algorithm was implemented as an open source, publicly available Eclipse plug-in and evaluated experimentally on 17 large Java benchmarks. Our results indicate that analysis cost is practical and the algorithm can successfully refactor a substantial number of fields to enumerated types. This work is a significant step towards providing automated tool support for migrating legacy Java software to modern Java technologies. © 2016, Springer Science+Business Media New York.",Article,Final,Scopus
Verdecchia R.; Saez R.A.; Procaccianti G.; Lago P.,57200754960; 57356984000; 50361812300; 56187491900,Empirical evaluation of the energy impact of refactoring code smells,2018,EPiC Series in Computing,52,,,365,383,18,25,10.29007/dz83,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85120158853&doi=10.29007%2fdz83&partnerID=40&md5=3200eaed2b01f2188a893ad2a56c96d6,"Software energy efficiency has gained the increasing attention of the research community. How to improve it, however, still lacks evidence. Specifically, the impact of code smell refactoring on energy efficiency has been scarcely investigated. In the exploratory study here reported, we investigate the impact on performance and energy consumption of refactoring well-known code smells on Java software applications. In order to understand if software metrics can be used as indicators of the energy impact of refactoring, we also measured the variation caused by refactoring on a set of well-established software metrics. We conducted a controlled experiment using state-of-the-art power measurement equipment. Statistical hypothesis testing and effect size estimation were performed on the experimental results, which show that in one out of three applications, refactoring each smell significantly impacted power-and energy consumption. E.g., refactoring Feature Envy and Long Method smells led to a 49% energy efficiency improvement. No software metric, however, significantly correlated with execution time, power or energy consumption. In conclusion, refactoring code smells resulted to be a viable process to significantly improve software energy efficiency. The magnitude of the impact may depend on application properties, e.g. size or age. Further research is needed to understand the relationship between software metrics and energy efficiency. © 2018, EasyChair. All rights reserved.",Conference paper,Final,Scopus
Kaya M.; Conley S.; Othman Z.S.; Varol A.,55515553000; 57060019200; 57203226988; 15058298400,Effective software refactoring process,2018,"6th International Symposium on Digital Forensic and Security, ISDFS 2018 - Proceeding",2018-January,,,1,6,5,7,10.1109/ISDFS.2018.8355350,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050964150&doi=10.1109%2fISDFS.2018.8355350&partnerID=40&md5=47497d458c88b2083dc9878e695db01f,"According to the plan-driven software development processes, software creation is comprised of a sequence of activities which starts with requirement analysis and continues with system design, implementation, testing and deployment and finally ends with maintenance phase. Although each phase contributes to the total development cost, research shows that more than 60% of it comes from maintenance. The quality and clarity of the system design or implementation subsequently is responsible for the cost of maintenance. Therefore, it is of great importance to detect and eliminate any design or implementation flaws to reduce the cost of development especially incurred by maintenance phase. This study discusses the importance of refactoring in software engineering and difficulties one may face with applying refactoring. We also lay out the factors that affect execution of certain refactoring. We present a discussion that takes us to a conceptual solution for more effective refactoring research and we share our observations and personal opinions in how to apply refactoring more effectively. © 2018 IEEE.",Conference paper,Final,Scopus
Singh N.; Singh P.,57203584512; 57202959177,How Do Code Refactoring Activities Impact Software Developers' Sentiments? - An Empirical Investigation into GitHub Commits,2017,"Proceedings - Asia-Pacific Software Engineering Conference, APSEC",2017-December,,,648,653,5,16,10.1109/APSEC.2017.79,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045904269&doi=10.1109%2fAPSEC.2017.79&partnerID=40&md5=b2283e4f0b679aeb5fe71365a413d6ec,"Affective software engineering deals in exploring and understanding the developers' sentiments associated with specific software development tasks with the goal to unleash various task-to-sentiment relationships. This paper empirically investigates the impact of software code refactoring on the sentiments of developers in open source projects. We perform a comprehensive analysis of sentiments attached with 15 different refactoring activities across the evolution of 60 open source Java projects through mining relevant commit messages. We investigate 3,171 refactoring related commit messages (out of total 615,625 commit messages) representing 4,891 refactoring instances. The study outcome shows that in general software developers express more negative sentiments than positive sentiments, while performing refactoring tasks. It is also found that 5 out of 15 refactoring activities are mainly responsible for this observed outcome. © 2017 IEEE.",Conference paper,Final,Scopus
Mariani T.; Vergilio S.R.,57016444500; 6506290092,A systematic review on search-based refactoring,2017,Information and Software Technology,83,,,14,34,20,70,10.1016/j.infsof.2016.11.009,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006276139&doi=10.1016%2fj.infsof.2016.11.009&partnerID=40&md5=cccc8fb68cfa817cf8e4f40d7ecefc9d,"Context: To find the best sequence of refactorings to be applied in a software artifact is an optimization problem that can be solved using search techniques, in the field called Search-Based Refactoring (SBR). Over the last years, the field has gained importance, and many SBR approaches have appeared, arousing research interest. Objective: The objective of this paper is to provide an overview of existing SBR approaches, by presenting their common characteristics, and to identify trends and research opportunities. Method: A systematic review was conducted following a plan that includes the definition of research questions, selection criteria, a search string, and selection of search engines. 71 primary studies were selected, published in the last sixteen years. They were classified considering dimensions related to the main SBR elements, such as addressed artifacts, encoding, search technique, used metrics, available tools, and conducted evaluation. Results: Some results show that code is the most addressed artifact, and evolutionary algorithms are the most employed search technique. Furthermore, most times, the generated solution is a sequence of refactorings. In this respect, the refactorings considered are usually the ones of the Fowler's Catalog. Some trends and opportunities for future research include the use of models as artifacts, the use of many objectives, the study of the bad smells effect, and the use of hyper-heuristics. Conclusions: We have found many SBR approaches, most of them published recently. The approaches are presented, analyzed, and grouped following a classification scheme. The paper contributes to the SBR field as we identify a range of possibilities that serve as a basis to motivate future researches. © 2016",Review,Final,Scopus
Mourad B.; Badri L.; Hachemane O.; Ouellet A.,57203205678; 57204223568; 57202465120; 57198860179,Exploring the impact of clone refactoring on test code size in object-oriented software,2017,"Proceedings - 16th IEEE International Conference on Machine Learning and Applications, ICMLA 2017",2017-December,,,586,592,6,4,10.1109/ICMLA.2017.00098,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85048478759&doi=10.1109%2fICMLA.2017.00098&partnerID=40&md5=4f4888f5e45a8d68c2520a9d017785da,"This paper aims at exploring the impact of clone refactoring on the test code size, in terms of number of operations, in object-oriented software. We investigated three research questions: (1) the impact of clone refactoring on three important source code attributes (coupling, complexity and size) that are related to unit testability of classes, (2) the impact of clone refactoring on the test code size, and (3) the variations after clone refactoring in the source code attributes that have the most important impact on the test code size. We used linear regression and three popular machine learning techniques (i.e., k-Nearest Neighbors, Naïve Bayes and Random Forest) to develop predictive and explanatory models. We used data collected from an open source Java software system (ANT) that has been refactored using clone-refactoring techniques. The analyses indicate that there is a strong and positive relationship between clone refactoring and the reduction of the test code size. Results show that: (1) the source code attributes of refactored classes have been significantly improved, (2) the test code size of refactored classes has been significantly reduced, and (3) the variations of the test code size are more influenced by the variations of the complexity and size of refactored classes compared to coupling. © 2017 IEEE.",Conference paper,Final,Scopus
"Yoshida N.; Ishizu T.; Edwards B., III; Inoue K.",36176694200; 57203407990; 57203409346; 7601540520,How slim will my system be?: Estimating refactored code size by merging clones,2018,Proceedings - International Conference on Software Engineering,,,,352,360,8,3,10.1145/3196321.3196353,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051669359&doi=10.1145%2f3196321.3196353&partnerID=40&md5=cf4e9a50b68deb5b69521a0f6d28b319,"We have been doing code clone analysis with industry collaborators for a long time, and have been always asked a question, ""OK, I understand my system contains a lot of code clones, but how slim will it be after merging redundant code clones?"" As a software system evolves for long period, it would increasingly contain many code clones due to quick bug fix and new feature addition. Industry collaborators would recognize decay of initial design simplicity, and try to evaluate current system from the view point of maintenance effort and cost. As one of resources for the evaluation, the estimated code size by merging code clone is very important for them. In this paper, we formulate this issue as ""slimming"" problem, and present three different slimming methods, Basic, Complete, and Heuristic Methods, each of which gives a lower bound, upper bound, and modest reduction rates, respectively. Application of these methods to OSS systems written in C/C++ showed that the reduction rate is at most 5.7% of the total size, and to a commercial COBOL system, it is at most 15.4%. For this approach, we have gotten initial but very positive feedback from industry collaborators. © 2018 ACM.",Conference paper,Final,Scopus
Omori T.; Maruyama K.,35422698000; 7402479189,Comparative study between two approaches using edit operations and code differences to detect past refactorings,2018,IEICE Transactions on Information and Systems,E101D,3,,644,658,14,7,10.1587/transinf.2017EDP7160,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85042656892&doi=10.1587%2ftransinf.2017EDP7160&partnerID=40&md5=045c2ba1d0fdcdf64533a3a7e9cdea1a,"Understanding which refactoring transformations were performed is in demand in modern software constructions. Traditionally, many researchers have been tackling understanding code changes with history data derived from version control systems. In those studies, problems of the traditional approach are pointed out, such as entanglement of multiple changes. To alleviate the problems, operation histories on IDEs' code editors are available as a new source of software evolution data nowadays. By replaying such histories, we can investigate past code changes in a fine-grained level. However, the prior studies did not provide enough evidence of their effectiveness for detecting refactoring transformations. This paper describes an experiment in which participants detect refactoring transformations performed by other participants after investigating the code changes with an operation-replay tool and diff tools. The results show that both approaches have their respective factors that pose misunderstanding and overlooking of refactoring transformations. Two negative factors on divided operations and generated compound operations were observed in the operation-based approach, whereas all the negative factors resulted from three problems on tangling, shadowing, and out-of-order of code changes in the difference-based approach. This paper also shows seven concrete examples of participants' mistakes in both approaches. These findings give us hints for improving existing tools for understanding code changes and detecting refactoring transformations. © 2018 The Institute of Electronics, Information and Communication Engineers.",Article,Final,Scopus
Bassey I.; Dladlu N.; Ele B.,55252786400; 55372686000; 57194443390,Object-Oriented Code Metric-Based Refactoring Opportunities Identification Approaches: Analysis,2017,"Proceedings - 4th International Conference on Applied Computing and Information Technology, 3rd International Conference on Computational Science/Intelligence and Applied Informatics, 1st International Conference on Big Data, Cloud Computing, Data Science and Engineering, ACIT-CSII-BCD 2016",,,7916960,67,74,7,2,10.1109/ACIT-CSII-BCD.2016.025,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85020220406&doi=10.1109%2fACIT-CSII-BCD.2016.025&partnerID=40&md5=8fbac4e45c05f2c0ebc1e0c8d416945b,"This paper presents analysis of existing empirical studies of software metric-based refactorings opportunities identification (ROI) for object-oriented (OO) software systems. We carried out a comprehensive analysis on sixteen (16) primary studies to identify the state-of-the-practice in ROI, focusing on their operations, refactoring activities, programming languages and the impact on software quality. The analysis results show that ROI approaches were designed for either a single refactoring activity or couple of them. Additionally, move method and extract class refactoring were the most refactorings activities performed on OO software systems. Also, OO metrics played an indispensable role in both opportunity detection and refactoring decisions. With the obtained results, we recommend the development of a generic ROI approach that is capable of identifying opportunities for all refactoring activities as well as suggesting the appropriate refactoring operations to apply. © 2016 IEEE.",Conference paper,Final,Scopus
Zhao J.; Wang W.; Yang H.,55516416900; 57208135568; 35070638900,Code refactoring based on mapreduce in cloud migration,2018,"Proceedings - 16th IEEE International Symposium on Parallel and Distributed Processing with Applications, 17th IEEE International Conference on Ubiquitous Computing and Communications, 8th IEEE International Conference on Big Data and Cloud Computing, 11th IEEE International Conference on Social Computing and Networking and 8th IEEE International Conference on Sustainable Computing and Communications, ISPA/IUCC/BDCloud/SocialCom/SustainCom 2018",,,8672235,1042,1043,1,1,10.1109/BDCloud.2018.00154,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063918764&doi=10.1109%2fBDCloud.2018.00154&partnerID=40&md5=3139455939003ef9fd1b60cc5f0ad3b2,"With the advent of big data era, the response speed of traditional legacy systems can no longer meet the requirements of users. Many organizations are migrating their legacy systems from a local machine to the cloud so as to reuse the legacy systems as well as improve the performance of big data processing. The MapReduce model of cloud computing makes parallel and distributed programming over a cluster of machines more convenient. This paper presents an approach to refactor the specific sequential code into MapReduce model in cloud migration, and proposes a tool to support the process of code refactoring. © 2018 IEEE.",Conference paper,Final,Scopus
Vimaladevi M.; Zayaraz G.,56167677200; 15924298000,Stability aware software refactoring using hybrid search based techniques,2017,"Proceedings - 2017 International Conference on Technical Advancements in Computers and Communication, ICTACC 2017",2017-October,,,32,35,3,3,10.1109/ICTACC.2017.18,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049038303&doi=10.1109%2fICTACC.2017.18&partnerID=40&md5=6faae705397ef7b6166f0f129b5c30b3,"Software refactoring is a crucial and necessary activity for the quality enhancement during maintenance and evolution of a software system. Stability is a key quality aspect that needs to be monitored especially for the process of refactoring. Due to the nature of the larger possible options for refactoring, search based software engineering practices provide a best possible way in improving the code quality through refactoring. A combination of automated refactoring techniques and metaheuristic search methods, along with the aid of software metrics, can improve the structure of the code. In this work, four quality attributes, namely abstraction, coupling, inheritance, along with stability is taken as fitness functions that drive the search process. The calculation of the fitness function follows a weighted aggregate method of the software metrics. A hybrid Gravitational Search Algorithm and Artificial Bee Colony algorithm (GSA-ABC) is applied which provides improved results in the search process of refactoring options. The results show improvement in terms of average quality gain of the four measured quality factors for the refactored software. © 2017 IEEE.",Conference paper,Final,Scopus
Hsieh C.-Y.; My C.L.; Ho K.T.; Cheng Y.C.,35306777200; 57200037059; 57203853772; 55487650500,Identification and refactoring of exception handling code smells in javascript,2017,Journal of Internet Technology,18,6,,1461,1471,10,0,10.6138/JIT.2017.18.6.20160118,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038822233&doi=10.6138%2fJIT.2017.18.6.20160118&partnerID=40&md5=a7da2e6a3311863ecbdcd94d110ba40e,"Avoid making bad smells is very important in writing exception handling code for dealing with unexpected runtime errors. The task however is challenging and demands proficient programming skills and experience. This is particularly true in developing JavaScript applications because JavaScript is very rich in features as being dynamic, interpreted and object-oriented with firstclass functions. What further complicates the situation is the use of event-driven and non-blocking I/O model in Node.js, which is a runtime environment written in serverside JavaScript. Extended from our previous work on exception handling code smells in Java, this study aims at identifying exception handling code smells that can occur in a JavaScript application at either the client side or the server side. The impact to software quality that each smell has is demonstrated with examples. Refactorings corresponding to the identified smells are proposed; their effects to the application, including the robustness level achieved and other benefits gained, are illustrated. The work is intended to serve as a guide in helping JavaScript developers avoid or discover exception handling code smells.",Conference paper,Final,Scopus
Rumpe B.,55861872700,"Agile modeling with UML: Code generation, testing, refactoring",2017,"Agile Modeling with UML: Code Generation, Testing, Refactoring",,,,1,388,387,39,10.1007/978-3-319-58862-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85032933256&doi=10.1007%2f978-3-319-58862-9&partnerID=40&md5=e2d7cd25c7c70a6fffdaf3566a76bc2c,"This book focuses on the methodological treatment of UML/P and addresses three core topics of model-based software development: code generation, the systematic testing of programs using a model-based definition of test cases, and the evolutionary refactoring and transformation of models. For each of these topics, it first details the foundational concepts and techniques, and then presents their application with UML/P. This separation between basic principles and applications makes the content more accessible and allows the reader to transfer this knowledge directly to other model-based approaches and languages. After an introduction to the book and its primary goals in Chapter 1, Chapter 2 outlines an agile UML-based approach using UML/P as the primary development language for creating executable models, generating code from the models, designing test cases, and planning iterative evolution through refactoring. In the interest of completeness, Chapter 3 provides a brief summary of UML/P, which is used throughout the book. Next, Chapters 4 and 5 discuss core techniques for code generation, addressing the architecture of a code generator and methods for controlling it, as well as the suitability of UML/P notations for test or product code. Chapters 6 and 7 then discuss general concepts for testing software as well as the special features which arise due to the use of UML/P. Chapter 8 details test patterns to show how to use UML/P diagrams to define test cases and emphasizes in particular the use of functional tests for distributed and concurrent software systems. In closing, Chapters 9 and 10 examine techniques for transforming models and code and thus provide a solid foundation for refactoring as a type of transformation that preserves semantics. Overall, this book will be of great benefit for practical software development, for academic training in the field of Software Engineering, and for research in the area of model-based software development. Practitioners will learn how to use modern model-based techniques to improve the production of code and thus significantly increase quality. Students will find both important scientific basics as well as direct applications of the techniques presented. And last but not least, the book will offer scientists a comprehensive overview of the current state of development in the three core topics it covers. © Springer Verlag Berlin Heidelberg 2005, 2012. All Rights Reserved.",Book,Final,Scopus
"Magalhães N.M.; De Souza Campos H., Jr.; Araújo M.A.P.; De Oliveira Neves V.",57195951871; 57192689554; 35848063200; 56712958700,An automated refactoring approach to remove unnecessary complexity in source code,2017,ACM International Conference Proceeding Series,Part F130656,,3,,,,0,10.1145/3128473.3128476,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030472654&doi=10.1145%2f3128473.3128476&partnerID=40&md5=e10e5bea7d6a890b4a4776be512ef19b,"Programming apprentices may choose to prioritize the correct functioning of a source code without focusing on their quality, making them difficult to maintain and test. Based on that, a phenomenon called unnecessary structural complexity may occur, in which a program has a cyclomatic complexity value that can be reduced without affecting its external behavior. In a previous work, we developed an approach and tool to address this problem. The approach is able to identify the presence of unnecessary cyclomatic complexity and to show the developer a suggestion to restructure the source code, through a control flow graph. The goal of this paper is to automate the source code refactoring process to support the elimination of unnecessary cyclomatic complexity. We performed two experimental studies to evaluate the approach in the academic context. The evidences provided by these studies suggest that the approach is able to support unnecessary cyclomatic complexity removal. We could not find, however, evidences about the implications of such approach on unit tests development. © 2017 Association for Computing Machinery.",Conference paper,Final,Scopus
Dharmawan T.; Rochimah S.,57201504450; 24476646200,Systematic literature review: Model refactoring,2017,"Proceedings of the 2017 4th International Conference on Computer Applications and Information Processing Technology, CAIPT 2017",2018-January,,,1,5,4,2,10.1109/CAIPT.2017.8320730,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85048081626&doi=10.1109%2fCAIPT.2017.8320730&partnerID=40&md5=808eaab3653dca9c19edd4cec23bab6f,"Refactoring is the method to detecting and fixing bad smells in software. Refactoring techniques that have developed is a refactoring technique that is done on the source code. Along with the development of model driven software engineering (MDSE), it also developed the method of refactoring on the model. Refactoring method in the model is considered more effective and efficient because the detection and repair of bad smell is done at the design phase. The method of refactoring on the model evolves into a variety of techniques. Due to this, the systematic literature review is done to get the development of refactoring method on the developing model. © 2017 IEEE.",Conference paper,Final,Scopus
Zhang Y.,55816561700,Improving the learning of parallel programming using software refactoring,2017,Computer Applications in Engineering Education,25,1,,112,119,7,2,10.1002/cae.21784,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85010303965&doi=10.1002%2fcae.21784&partnerID=40&md5=4bba96efcac5515d518648a2e39fb5ba,"Parallel programming has become increasingly popular in the computer educational field over the past few years. Although parallel programs obtain the short execution time and the high throughput, learning how to write a well-structured and high-performance parallel program is still one of the challenges for most of students. How to let students learn parallel programming well is one of the important tasks that educators should resolve. This paper presents the learning of parallel programming using software refactoring methodologies and tools. Manual and automated refactoring are introduced to show how the learning is improved respectively. With manual refactoring, students learn how to perform the data or task decomposition and how to write a well-structured parallel software via customized programs and some benchmarks in JGF benchmark suite; with automated refactoring, students can transform the parallel parts quickly, and then evaluate the performance of a parallel software. Two automated refactoring tools are developed for educational purposes. Some of the experiences are also shared during conducting the course. © 2017 Wiley Periodicals, Inc. Comput Appl Eng Educ 25:112–119, 2017; View this article online at wileyonlinelibrary.com/journal/cae; DOI 10.1002/cae.21784. © 2017 Wiley Periodicals, Inc.",Article,Final,Scopus
Zhang D.; Li B.; Li Z.; Liang P.,57216798197; 55628528674; 46061313300; 24923262400,A preliminary investigation of self-Admitted refactorings in open source software,2018,"Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE",2018-July,,,165,168,3,10,10.18293/SEKE2018-081,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056883561&doi=10.18293%2fSEKE2018-081&partnerID=40&md5=58e6161dc9a55d903b889ce41da3d294,"In software development, developers commit code changes to the version control system. In a commit message, the committer may explicitly claim that the commit is a refactoring with the intention of code quality improvement. We defined such a commit as a self-Admitted refactoring (SAR). Currently, there is little knowledge about the SAR phenomenon, and the impact of SARs on software projects is not clear. In this work, we performed a preliminary investigation on SARs with an emphasis on their impact on code quality using the assessment of code smells. We used two non-Trivial open source software projects as cases and employed the PMD tool to detect code smells. The study results shows that: (1) SARs tend to improve code quality, though a small proportion of SARs introduced new code smells; and (2) projects that contain SARs have different results on frequently affected code smells. © 2018 Universitat zu Koln. All rights reserved.",Conference paper,Final,Scopus
Szoke G.,55803891600,Automating the refactoring process,2017,Acta Cybernetica,23,2,,715,735,20,0,10.14232/actacyb.23.2.2017.16,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034654107&doi=10.14232%2factacyb.23.2.2017.16&partnerID=40&md5=5b186780fed47b581715d59f52f74e0d,"To decrease software maintenance cost, software development companies use static source code analysis techniques. Static analysis tools are capable of finding potential bugs, anti-patterns, coding rule violations, and they can also enforce coding style standards. Although there are several available static analyzers to choose from, they only support issue detection. The elimination of the issues is still performed manually by developers. Here, we propose a process that supports the automatic elimination of coding issues in Java. We introduce a tool that uses a third-party static analyzer as input and enables developers to automatically fix the detected issues for them. Our tool uses a special technique, called reverse AST-search, to locate source code elements in a syntax tree, just based on location information. Our tool was evaluated and tested in a two-year project with six software development companies where thousands of code smells were identified and fixed in five systems that have altogether over five million lines of code.",Conference paper,Final,Scopus
Vedurada J.; Nandivada V.K.,57195278189; 8940304200,Refactoring opportunities for replacing type code with state and subclass,2017,"Proceedings - 2017 IEEE/ACM 39th International Conference on Software Engineering Companion, ICSE-C 2017",,,7965339,305,307,2,4,10.1109/ICSE-C.2017.97,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85026750870&doi=10.1109%2fICSE-C.2017.97&partnerID=40&md5=6c50921e76d85fd36cfbf762dc25bea8,"Refactoring restructures a program to improve itsreadability and maintainability, without changing its originalbehavior. One of the key steps in refactoring is the identification ofpotential refactoring opportunities. In this paper, we discuss therelevance of two popular refactorings 'Replace Type Code withSubclass' and 'Replace Type Code with State' in real world Javaapplications and describe some of the challenges in automaticallyidentifying these refactoring opportunities. © 2017 IEEE.",Conference paper,Final,Scopus
Medeleanu ?.; Mihancea P.F.,57193336792; 8876469700,NullTerminator: Pseudo-automatic refactoring to null object design pattern,2017,"Proceedings - 2016 IEEE International Conference on Software Maintenance and Evolution, ICSME 2016",,,7816516,601,603,2,1,10.1109/ICSME.2016.23,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013127871&doi=10.1109%2fICSME.2016.23&partnerID=40&md5=00655f3fc4520b68356bea869c525704,"Restructuring legacy code to improve its structure and understandability is difficult and adequate tool support is required. While the advantages of the Null Object pattern are widely recognized, the first tool support has only recently emerged. We complement it with NULLTERMINATOR, a prototype tool to assist developers in the instantiation of the Null Object design pattern in Java programs. We describe the main functionalities of the tool and some important internal details on an accompanying example. The demo concludes presenting some initial results. © 2016 IEEE.",Conference paper,Final,Scopus
Winters T.,57203484156,Non-Atomic Refactoring and Software Sustainability,2018,Proceedings - International Conference on Software Engineering,,,,2,5,3,8,10.1145/3194793.3194794,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051840039&doi=10.1145%2f3194793.3194794&partnerID=40&md5=ddbe883a831de612e68f892b0b71ae9d,"Sustainability is the ability of a project / codebase / organization to react to necessary changes over its expected lifespan. At a large enough scale, or with enough disconnect between dependencies, sustainability comes from application of both technical and non-Technical approaches. On the technical side, I advocate for restraint among API providers on making arbitrary changes, and use of non-Atomic refactoring techniques when more invasive changes are required; such techniques are employed in many Google projects, and in programming languages like Go and C++, to allow more flexible changes to language standards over time. On the non-Technical side, I argue for a clear separation of responsibilities (providers need to do the bulk of the work for the update), as well as a growing need to document acceptable usage of an API, be it a library or programming language. In many languages, there are very few changes to an API that are provably safe without this idea: just because a user's code currently works does not mean that it is supported and can be expected to continue to work indefinitely under maintenance. Taken together, these two approaches form what I believe to be a minimum set of requirements when approaching software sustainability. © 2018 Copyright held by the owner/author(s).",Conference paper,Final,Scopus
Khatchadourian R.; Masuhara H.,24469948000; 7103057135,Automated Refactoring of Legacy Java Software to Default Methods,2017,"Proceedings - 2017 IEEE/ACM 39th International Conference on Software Engineering, ICSE 2017",,,7985652,82,93,11,14,10.1109/ICSE.2017.16,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027716666&doi=10.1109%2fICSE.2017.16&partnerID=40&md5=1e70ebaaf5b72fe1b6621011225a9fcb,"Java 8 default methods, which allow interfaces to contain (instance) method implementations, are useful for the skeletal implementation software design pattern. However, it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods to preserve type-correctness and confirm semantics preservation. In this paper, we present an efficient, fully-Automated, type constraint-based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy Java software. The approach features an extensive rule set that covers various corner-cases where default methods cannot be used. To demonstrate applicability, we implemented our approach as an Eclipse plug-in and applied it to 19 real-world Java projects, as well as submitted pull requests to popular GitHub repositories. The indication is that it is useful in migrating skeletal implementation methods to interfaces as default methods, sheds light onto the pattern's usage, and provides insight to language designers on how this new construct applies to existing software. © 2017 IEEE.",Conference paper,Final,Scopus
Cruz L.; Abreu R.; Rouvignac J.-N.,57143791700; 16479696600; 57195311970,Leafactor: Improving Energy Efficiency of Android Apps via Automatic Refactoring,2017,"Proceedings - 2017 IEEE/ACM 4th International Conference on Mobile Software Engineering and Systems, MOBILESoft 2017",,,7972807,205,206,1,29,10.1109/MOBILESoft.2017.21,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027046510&doi=10.1109%2fMOBILESoft.2017.21&partnerID=40&md5=177fbb10849252b06d621b5061cdb452,Leafactor is a tool to automatically improve the energy consumption of Android apps. It does so by refactoring the source code to follow a set of patterns known to be energy efficient. The toolset was validated using 222 refactorings in 140 open-source apps. Changes were submitted to the original apps by creating pull requests to the official projects. © 2017 IEEE.,Conference paper,Final,Scopus
Kaur G.; Singh B.,58754759400; 57209538273,Improving the quality of software by refactoring,2017,"Proceedings of the 2017 International Conference on Intelligent Computing and Control Systems, ICICCS 2017",2018-January,,,185,191,6,13,10.1109/ICCONS.2017.8250707,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047473327&doi=10.1109%2fICCONS.2017.8250707&partnerID=40&md5=ed9c0c0d09c009d0f8e4c4e58f935c13,"Software code management has become another key skill required by software architects and software developers. Size of software increases with increase in count of features in software. Code refactoring is process of reducing code maintenance cost. It is achieved by many different techniques like extract, move methods, fields or classes in code. In this research we focused on improving the maintainability of the code by looking into the different refactoring techniques and improving upon them. We proposed an algorithm to improve the refactoring process which results in higher maintainability. To look into the validity of our proposed algorithm, we have used Junit and reffinder to analyse the code and generate the result metrics. We have observed the effectiveness of our work by comparing the different code maintainability indexes generated by the tool. In our research we have examined four releases of the software project for code refactoring and maintainability. Adding some extra features and using enhanced refactoring techniques measuring the code metrics and comparing the results of current releases with the previous releases. © 2017 IEEE.",Conference paper,Final,Scopus
Gil Y.; Orru M.,7004618171; 55982780800,The Spartanizer: Massive automatic refactoring,2017,"SANER 2017 - 24th IEEE International Conference on Software Analysis, Evolution, and Reengineering",,,7884657,477,481,4,9,10.1109/SANER.2017.7884657,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85018385623&doi=10.1109%2fSANER.2017.7884657&partnerID=40&md5=ac76cad5a34acce9195cfd0d6a23588b,"The Spartanizer is an eclipse plugin featuring over one hundred and fifty refactoring techniques, all aimed at reducing various size complexity of the code, without changing its design, i.e., inheritance relations, modular structure, etc. Typical use case of the Spartanizer is in an automatic mode: refactoring operations are successively selected and applied by the tool, until the code is reshaped in spartan style (a frugal coding style minimizing the use of characters, variables, tokens, etc.). The Spartanizer demonstrates the potential of automatic refactoring: tens of thousands of transformations are applied in matter of seconds, chains of dependent applications of transformations with tens of operations in them, significant impact on code size, and extent reaching almost every line of code, even of professional libraries. © 2017 IEEE.",Conference paper,Final,Scopus
Bashir R.S.; Lee S.P.; Yung C.C.; Alam K.A.; Ahmad R.W.,57189758390; 7601407331; 57215289534; 56504833200; 56486885900,A Methodology for Impact Evaluation of Refactoring on External Quality Attributes of a Software Design,2017,"Proceedings - 2017 International Conference on Frontiers of Information Technology, FIT 2017",2017-January,,,183,188,5,9,10.1109/FIT.2017.00040,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049253365&doi=10.1109%2fFIT.2017.00040&partnerID=40&md5=f5c41c647f4f482f8ad54ab3648e6051,"Refactoring aims at improving software design quality without affecting external behavior. It is commonly believed that refactoring operations always enhance the software quality. However, some recent empirical studies have reported negative or negligible effects of refactoring on certain quality attributes. The actual impact of each refactroing on certain quality attributes may help developers in selecting the most suitable refactoring alternatives. Various work have been proposed in this regard at source code-level. However, fewer studies have assessed the refactoring impact at design-level. In this study, We propose a refactoring impact evaluation method enabling developers to select the suitable refactoring operations based on their impact. Nine small scale case studies have been used to validate the consistency of propose method. The results reveal that move method, extract method, extract class rafactoring operations have improved maintainability, understandability, modifiability, and analyzability in nine case studies. These obeservations are consistent accross multiple case studies, implying that the proposed approach is highly consistent. © 2017 IEEE.",Conference paper,Final,Scopus
Al Dallal J.; Abdin A.,6508260263; 57200308490,Empirical Evaluation of the Impact of Object-Oriented Code Refactoring on Quality Attributes: A Systematic Literature Review,2018,IEEE Transactions on Software Engineering,44,1,7833023,44,69,25,50,10.1109/TSE.2017.2658573,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040724898&doi=10.1109%2fTSE.2017.2658573&partnerID=40&md5=79192b030d0b740162fcec9f58ad4098,"Software refactoring is a maintenance task that addresses code restructuring to improve its quality. Many studies have addressed the impact of different refactoring scenarios on software quality. This study presents a systematic literature review that aggregates, summarizes, and discusses the results of 76 relevant primary studies (PSs) concerning the impact of refactoring on several internal and external quality attributes. The included PSs were selected using inclusion and exclusion criteria applied to relevant articles published before the end of 2015. We analyzed the PSs based on a set of classification criteria, including software quality attributes and measures, refactoring scenarios, evaluation approaches, datasets, and impact results. We followed the vote-counting approach to determine the level of consistency among the PS reported results concerning the relationship between refactoring and software quality. The results indicated that different refactoring scenarios sometimes have opposite impacts on different quality attributes. Therefore, it is false that refactoring always improves all software quality aspects. The vote-counting study provided a clear view of the impacts of some individual refactoring scenarios on some internal quality attributes such as cohesion, coupling, complexity, inheritance, and size, but failed to identify their impacts on external and other internal quality attributes due to insufficient findings. © 1976-2012 IEEE.",Review,Final,Scopus
Khelladi D.E.; Hebig R.; Bendraou R.; Robin J.; Gervais M.-P.,56728591300; 35147919400; 6507188884; 7102560751; 56216389000,Detecting complex changes and refactorings during (Meta)model evolution,2016,Information Systems,62,,,220,241,21,25,10.1016/j.is.2016.05.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84977498602&doi=10.1016%2fj.is.2016.05.002&partnerID=40&md5=0bf6008403cc90472c88d2875b37fcfa,"Evolution of metamodels can be represented at the finest grain by the trace of atomic changes such as add, delete, and update of elements. For many applications, like automatic correction of models when the metamodel evolves, a higher grained trace must be inferred, composed of complex changes, each one aggregating several atomic changes. Complex change detection is a challenging task since multiple sequences of atomic changes may define a single user intention and complex changes may overlap over the atomic change trace. In this paper, we propose a detection engine of complex changes that simultaneously addresses these two challenges of variability and overlap. We introduce three ranking heuristics to help users to decide which overlapping complex changes are likely to be correct. In our approach, we record the trace of atomic changes rather than computing them with the difference between the original and evolved metamodel. Thus, we have a complete and an ordered sequence of atomic changes without hidden changes. Furthermore, we consider the issue of undo operations (i.e. change canceling actions) while recording the sequence of atomic changes, and we illustrate how we cope with it. We validate our approach on 8 real case studies demonstrating its feasibility and its applicability. We observe that a full recall is always reached in all case studies and an average precision of 70.75%. The precision is improved by the heuristics up to 91% and 100% in some cases. © 2016 Elsevier Ltd",Article,Final,Scopus
Antal G.; Szarka A.; Heged?s P.,6701427737; 57202961526; 25926433300,A hands-on openstack code refactoring experience report,2018,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),10964 LNCS,,,464,480,16,0,10.1007/978-3-319-95174-4_37,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049932789&doi=10.1007%2f978-3-319-95174-4_37&partnerID=40&md5=df7229c43586ee4be9ebc1b819b5ea23,"Nowadays, almost everyone uses some kind of cloud infrastructure. As clouds gaining more and more attention, it is now even more important to have stable and reliable cloud systems. Along with stability and reliability comes source code maintainability. Unfortunately, maintainability has no exact definition, there are several definitions both from users’ and developers’ perspective. In this paper, we analyzed two projects of OpenStack, the world’s leading open-source cloud system, using QualityGate, a static software analyzer which can help to determine the maintainability of software. During the analysis we found quality issues that could be fixed by refactoring the code. We have created 47 patches in this two OpenStack projects. We have also analyzed our patches with QualityGate to see whether they increase the maintainability of the system. We found that a single refactoring has a barely noticeable effect on the maintainability of the software, what is more, it can even decrease maintainability. But if we do refactorings regularly, their cumulative effect will probably increase the quality in the mid and long-term. We also experienced that our refactoring commits were very appreciated by the open-source community. © Springer International Publishing AG, part of Springer Nature 2018.",Conference paper,Final,Scopus
Cedrim D.; Garcia A.; Mongiovi M.; Gheyi R.; Sousa L.; De Mello R.; Fonseca B.; Ribeiro M.; Chávez A.,57194528845; 7404608626; 54395969100; 8365747700; 57194212913; 37025865700; 36175426900; 57199329234; 57195995000,Understanding the impact of refactoring on smells: A longitudinal study of 23 software projects,2017,Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering,Part F130154,,,465,475,10,62,10.1145/3106237.3106259,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030761002&doi=10.1145%2f3106237.3106259&partnerID=40&md5=3d27d644fa9af398b34ff1186d9d1e56,"Code smells in a program represent indications of structural quality problems, which can be addressed by software refactoring. However, refactoring intends to achieve different goals in practice, and its application may not reduce smelly structures. Developers may neglect or end up creating new code smells through refactoring. Unfortunately, little has been reported about the beneficial and harmful effects of refactoring on code smells. This paper reports a longitudinal study intended to address this gap. We analyze how often commonly-used refactoring types affect the density of 13 types of code smells along the version histories of 23 projects. Our findings are based on the analysis of 16, 566 refactorings distributed in 10 different types. Even though 79.4% of the refactorings touched smelly elements, 57% did not reduce their occurrences. Surprisingly, only 9.7% of refactorings removed smells, while 33.3% induced the introduction of new ones. More than 95% of such refactoringinduced smells were not removed in successive commits, which suggest refactorings tend to more frequently introduce long-living smells instead of eliminating existing ones. We also characterized and quantified typical refactoring-smell patterns, and observed that harmful patterns are frequent, including: (i) approximately 30% of the Move Method and Pull Up Method refactorings induced the emergence of God Class, and (ii) the Extract Superclass refactoring creates the smell Speculative Generality in 68% of the cases. © 2017 Association for Computing Machinery.",Conference paper,Final,Scopus
Viggiano J.A.S.,6701629323,Calculation of scalars in Neugebauer-like models. I: Refactoring the calculations,2017,Final Program and Proceedings - IS and T/SID Color Imaging Conference,2017,25-Sep,,123,129,6,2,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85042381991&partnerID=40&md5=63dbb8e1d51190fda40f925091f22b41,"This paper discusses a new way to compute weights (scalars) for Neugebauer-like models that is more flexible than existing methods, simplifying the insertion of a new model for scalar calculation. Specifically, the scalar computing task is refactored into two independent components. In one, the specific dot overlap behavior is specified in a single, often simple, expression. This expression may be implemented for each the three main overlap modalities in a function with a singlestatement body. The other component actually computes the scalars, calling the other component as necessary. This second component has been described algorithmically, and open-source software to demonstrate it has been made available.",Conference paper,Final,Scopus
Burek P.; Loebe F.; Herre H.,8886021700; 36887467300; 7004478721,Towards refactoring the Molecular Function Ontology with a UML profile for function modeling,2017,Journal of Biomedical Semantics,8,1,48,,,,7,10.1186/s13326-017-0152-y,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030325881&doi=10.1186%2fs13326-017-0152-y&partnerID=40&md5=7e3ec02ac3ddd81dcd5215e9ac0034db,"Background: Gene Ontology (GO) is the largest resource for cataloging gene products. This resource grows steadily and, naturally, this growth raises issues regarding the structure of the ontology. Moreover, modeling and refactoring large ontologies such as GO is generally far from being simple, as a whole as well as when focusing on certain aspects or fragments. It seems that human-friendly graphical modeling languages such as the Unified Modeling Language (UML) could be helpful in connection with these tasks. Results: We investigate the use of UML for making the structural organization of the Molecular Function Ontology (MFO), a sub-ontology of GO, more explicit. More precisely, we present a UML dialect, called the Function Modeling Language (FueL), which is suited for capturing functions in an ontologically founded way. FueL is equipped, among other features, with language elements that arise from studying patterns of subsumption between functions. We show how to use this UML dialect for capturing the structure of molecular functions. Furthermore, we propose and discuss some refactoring options concerning fragments of MFO. Conclusions: FueL enables the systematic, graphical representation of functions and their interrelations, including making information explicit that is currently either implicit in MFO or is mainly captured in textual descriptions. Moreover, the considered subsumption patterns lend themselves to the methodical analysis of refactoring options with respect to MFO. On this basis we argue that the approach can increase the comprehensibility of the structure of MFO for humans and can support communication, for example, during revision and further development. © 2017 The Author(s).",Article,Final,Scopus
Honsel D.; Fiekas N.; Herbold V.; Welter M.; Ahlbrecht T.; Waack S.; Dix J.; Grabowski J.,55596825200; 57194782876; 57194789309; 56345737000; 56017250900; 55976438900; 7005667469; 22334240800,Simulating software refactorings based on graph transformations,2018,Communications in Computer and Information Science,889,,,161,175,14,0,10.1007/978-3-319-96271-9_10,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052070893&doi=10.1007%2f978-3-319-96271-9_10&partnerID=40&md5=a7c2e2098b93048b455a2aaf8c0bf1e9,"We aim to simulate software processes in order to predict the structural evolution of software graphs and assure higher software quality. To make our simulation and therefore the results more accurate, we need to model real world practices. In this paper, we consider the specific problem of including software refactorings in our simulation. We describe these refactorings as graph transformations and apply parameters we collected from open source projects. © Springer Nature Switzerland AG 2018.",Conference paper,Final,Scopus
Silva L.H.; Valente M.T.; Bergel A.,57220764382; 55437198000; 23093070700,"Refactoring legacy javascript code to use classes: The good, the bad and the ugly",2017,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),10221 LNCS,,,155,171,16,3,10.1007/978-3-319-56856-0_11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85019238616&doi=10.1007%2f978-3-319-56856-0_11&partnerID=40&md5=0b66e5ee28de1c5bb32f72d59b19bc8a,"JavaScript systems are becoming increasingly complex and large. To tackle the challenges involved in implementing these systems, the language is evolving to include several constructions for programming-in-the-large. For example, although the language is prototype-based, the latest JavaScript standard, named ECMAScript 6 (ES6), provides native support for implementing classes. Even though most modern web browsers support ES6, only a very few applications use the class syntax. In this paper, we analyze the process of migrating structures that emulate classes in legacy JavaScript code to adopt the new syntax for classes introduced by ES6. We apply a set of migration rules on eight legacy JavaScript systems. In our study, we document: (a) cases that are straightforward to migrate (the good parts); (b) cases that require manual and ad-hoc migration (the bad parts); and (c) cases that cannot be migrated due to limitations and restrictions of ES6 (the ugly parts). Six out of eight systems (75%) contain instances of bad and/or ugly cases.We also collect the perceptions of JavaScript developers about migrating their code to use the new syntax for classes. © Springer International Publishing AG 2017.",Conference paper,Final,Scopus
Rama G.M.; Komondoor R.,35614628200; 8728279600,Detecting Full Initialization Points of Objects to Support Code Refactorings,2018,"Proceedings - Asia-Pacific Software Engineering Conference, APSEC",2017-December,,,110,119,9,0,10.1109/APSEC.2017.17,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045907110&doi=10.1109%2fAPSEC.2017.17&partnerID=40&md5=a92e5d97469993f38f570ff37ead5595,"A common need of refactorings that involve object allocations is to determine precisely the program points at which objects allocated at a given allocation site become fully initialized. In this paper we formalize the notion of full initialization points (FIPs) of allocation sites, and present a static analysis to determine precisely these program points. While this analysis can benefit several allocation-site refactorings, to demonstrate its usefulness we select two specific refactorings in this paper - object sharing refactoring and immutability refactoring. By introducing code to cache and share objects at the FIPs suggested by our analysis, object-sharing refactoring was able to obtain a mean memory savings of 11.4% on a set of real Java benchmarks. Immutability refactoring guided by our analysis achieved a mean runtime speedup of 1.6X compared to performing the same refactoring using a baseline approach. © 2017 IEEE.",Conference paper,Final,Scopus
Ghannem A.; Kessentini M.; Hamdi M.S.; El Boussaidi G.,55871956200; 25653537200; 57200926729; 13104902500,Model refactoring by example: A multi-objective search based software engineering approach,2018,Journal of Software: Evolution and Process,30,4,e1916,,,,15,10.1002/smr.1916,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045620151&doi=10.1002%2fsmr.1916&partnerID=40&md5=f20cac5d1d2576a2fd90cafbc855b3ee,"Declarative rules are frequently used in model refactoring in order to detect refactoring opportunities and to apply the appropriate ones. However, a large number of rules is required to obtain a complete specification of refactoring opportunities. Companies usually have accumulated examples of refactorings from past maintenance experiences. Based on these observations, we consider the model refactoring problem as a multi objective problem by suggesting refactoring sequences that aim to maximize both structural and textual similarity between a given model (the model to be refactored) and a set of poorly designed models in the base of examples (models that have undergone some refactorings) and minimize the structural similarity between a given model and a set of well-designed models in the base of examples (models that do not need any refactoring). To this end, we use the Non-dominated Sorting Genetic Algorithm (NSGA-II) to find a set of representative Pareto optimal solutions that present the best trade-off between structural and textual similarities of models. The validation results, based on 8 real world models taken from open-source projects, confirm the effectiveness of our approach, yielding refactoring recommendations with an average correctness of over 80%. In addition, our approach outperforms 5 of the state-of-the-art refactoring approaches. Copyright © 2017 John Wiley & Sons, Ltd.",Article,Final,Scopus
Ma W.; Chen L.; Zhou Y.; Xu B.,56949541600; 57189042207; 57022538800; 7404589262,Do we have a chance to fix bugs when refactoring code smells?,2016,"Proceedings - 2016 International Conference on Software Analysis, Testing and Evolution, SATE 2016",,,7780189,24,29,5,14,10.1109/SATE.2016.11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85010628555&doi=10.1109%2fSATE.2016.11&partnerID=40&md5=beb48d5c4fe316b9b083326b56b2af71,"Code smells are used to describe code structures that may cause detrimental effects on software and should be refactored. Previous studies show that some code smells have significant effect on faults. However, how to refactor code smells to reduce bugs still needs more concern. We investigate the possibility of prioritizing code smell refactoring with the help of fault prediction results. We also investigate the possibility of improving the performance of fault prediction by using code smell detection results. We use Cohen's Kappa statistic to report agreements between results of code smell detections and fault predictions. We use fault prediction result as an indicator to guide code smell refactoring. Our results show that refactoring Blob, Long Parameter List, and Refused Parent Be Request may have a good chance to detect and fix bugs, and some code smells are particularly useful for improving the recall of fault prediction. © 2016 IEEE.",Conference paper,Final,Scopus
Dao T.-H.; Trinh T.-B.; Truong N.-T.,58334381300; 25929658500; 12753859100,A tool support for checking consistency in model refactoring,2017,"Proceedings - 2017 9th International Conference on Knowledge and Systems Engineering, KSE 2017",2017-January,,,100,105,5,1,10.1109/KSE.2017.8119442,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85043713218&doi=10.1109%2fKSE.2017.8119442&partnerID=40&md5=f4a289f17d4a6a843dde7260ad20bcb5,"Refactoring is a technique that transforms a software structure to new one in order to improve the internal structure without affect its external behaviors. Although refactoring has shown a number of advantages, it has not been widely adopted in practice as expected. One of the big challenges to refactoring is the lack of tool support that may be raised some issues such as tedious, time-consuming and error-prone. We present in this paper a tool called CVT (Consistency Validator Tool) that used to assist to checking consistency in model refactoring. The CVT is composed of three essential modules which are well-formedness checking, translate OCL into FOL and behavioral consistency checking. We are most interested in OCL to FOL translation process that make use of Abstract Syntax Tree (AST) as an intermediate syntax. We have also carried out some experimental studies to evaluate the effectiveness of this tool. © 2017 IEEE.",Conference paper,Final,Scopus
Sagardui G.; Etxeberria L.; Agirre J.A.; Arrieta A.; Nicolás C.F.; Martín J.M.,13104721400; 13105885100; 55597868500; 56514865400; 7005466536; 57194763277,A configurable validation environment for refactored embedded software and its application in elevators; [Entorno de validación configurable para software embebido refactorizado y su aplicación en ascensores],2018,"Actas de las 23rd Jornadas de Ingenieria del Software y Bases de Datos, JISBD 2018",,,,,,,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85172593969&partnerID=40&md5=9f6962bc64d737560e1df1c3781babee,[No abstract available],Conference paper,Final,Scopus
Malhotra R.; Chug A.,15758058000; 56168650500,An empirical study to assess the effects of refactoring on software maintainability,2016,"2016 International Conference on Advances in Computing, Communications and Informatics, ICACCI 2016",,,7732033,110,117,7,21,10.1109/ICACCI.2016.7732033,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85007343986&doi=10.1109%2fICACCI.2016.7732033&partnerID=40&md5=ab5d3a10419d61501197df3045066a6b,"Maintenance is the most expensive phase of software and during this process refactoring is performed to improve the code without affecting its external behaviour. This study examines the effects of refactoring on maintainability using five proprietary software systems. Internal quality attributes were measured using design metrics suite whereas external quality attributes such as the level of abstraction, understandability, modifiability, extensibility and reusability were measured through expert opinion. The original versions of software are compared with refactored versions and the changes in quality attributes were mapped to maintainability. The results reveal that refactoring significantly improves the software quality and enhances software life. It was also found that even though refactoring is very tedious and might introduce errors if not implemented with utmost care, it is still advisable to frequently refactor the code to increase maintainability. Results of this study are useful to project managers in identifying the opportunities of refactoring while maintaining a perfect balance between reengineering and over-engineering. © 2016 IEEE.",Conference paper,Final,Scopus
Le H.A.; Dao T.-H.; Truong N.-T.,55613720900; 58334381300; 12753859100,A Formal Approach to Checking Consistency in Software Refactoring,2017,Mobile Networks and Applications,22,2,,356,366,10,4,10.1007/s11036-017-0807-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85010723111&doi=10.1007%2fs11036-017-0807-z&partnerID=40&md5=06151409d354fa192284b7b516fcfd2e,"In software development, refactoring is a process that improves the system internal structure without altering its external behavior. Applying design patterns, which are common reusable solutions of several kinds of problems is widely adopted. This technique, however, raises a challenging issue that after applying design patterns the software system may not preserve some certain behavioral properties. This paper proposes a new approach to checking consistency between original software system and its evolution at both design and implementation phases. First, we formalize elements of software designs and programs. Methods, based on these formalizations, are proposed for verifying the design and implementation of the system. Finally, the paper presents a case study of Adaptive Road Traffic Control system to illustrate the proposed approach in detail. © 2017, Springer Science+Business Media New York.",Article,Final,Scopus
Mohan M.; Greer D.,57189345360; 35228903500,MultiRefactor: Automated refactoring to improve software quality,2017,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),10611 LNCS,,,556,572,16,6,10.1007/978-3-319-69926-4_46,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034592235&doi=10.1007%2f978-3-319-69926-4_46&partnerID=40&md5=d8f962b06f33e6c95c91833052680e3d,"In this paper, a new approach is proposed for automated software maintenance. The tool is able to perform 26 different refactorings. It also contains a large selection of metrics to measure the impact of the refactorings on the software and six different search based optimization algorithms to improve the software. This tool contains both mono-objective and multi-objective search techniques for software improvement and is fully automated. The paper describes the various capabilities of the tool, the unique aspects of it, and also presents some research results from experimentation. The individual metrics are tested across five different codebases to deduce the most effective metrics for general quality improvement. It is found that the metrics that relate to more specific elements of the code are more useful for driving change in the search. The mono-objective genetic algorithm is also tested against the multi-objective algorithm to see how comparable the results gained are with three separate objectives. When comparing the best solutions of each individual objective the multi-objective approach generates suitable improvements in quality in less time, allowing for rapid maintenance cycles. © Springer International Publishing AG 2017.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Di Pompeo D.,55317293800; 6603764364; 57188727238,Performance-driven software model refactoring,2018,Information and Software Technology,95,,,366,397,31,27,10.1016/j.infsof.2017.09.006,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029760730&doi=10.1016%2fj.infsof.2017.09.006&partnerID=40&md5=f89a5b9d100bde4285eac2fa8b868e8c,"Context: Software refactoring is a common practice aimed at addressing requirements or fixing bugs during the software development. While refactoring related to functional requirements has been widely studied in the last few years, non-functional-driven refactoring is still critical, mostly because non-functional characteristics of software are hard to assess and appropriate refactoring actions can be difficult to identify. In the context of performance, which is the focus of this paper, antipatterns represent effective instruments to tackle this issue, because they document common mistakes leading to performance problems as well as their solutions. Objective: In order to effectively reuse the knowledge beyond performance antipatterns, automation is required to detect and remove them. In this paper we introduce a framework that enables, in an unique tool context, the refactoring of software models driven by performance antipattern detection and removal. Method: We have implemented, within the EPSILON platform, detection rules and refactoring actions on UML models for a set of well-known performance antipatterns. By exploiting the EPSILON languages to check properties and apply refactoring on models, we enable three types of refactoring sessions. Results: We experiment our framework on a Botanical Garden Management System to show, on one side, that antipatterns can effectively drive software refactoring towards models that satisfy performance requirements and, on the other side, that the automation introduced by EPSILON-based sessions enables to inspect multiple paths and to propose a variety of solutions. Conclusion: This work demonstrates that automation in performance-driven software model refactoring can be beneficial, and that performance antipatterns can be powerful instruments in the hands of software engineers for detecting (and solving) performance problems usually hidden to traditional bottleneck analysis. This work also opens the road to the integration of well-known techniques for software refactoring driven by functional requirements with novel techniques addressing non-functional requirements like performance. © 2017 Elsevier B.V.",Article,Final,Scopus
Pines G.; Winkler J.D.; Pines A.; Gill R.T.,22942241800; 57200901119; 56650637800; 57203084188,Refactoring the genetic code for increased evolvability,2017,mBio,8,6,e01654-17,,,,15,10.1128/mBio.01654-17,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85039911854&doi=10.1128%2fmBio.01654-17&partnerID=40&md5=bc4d5c00883c4f3f2e135cce63544947,"The standard genetic code is robust to mutations during transcription and translation. Point mutations are likely to be synonymous or to preserve the chemical properties of the original amino acid. Saturation mutagenesis experiments suggest that in some cases the best-performing mutant requires replacement of more than a single nucleotide within a codon. These replacements are essentially inaccessible to common error-based laboratory engineering techniques that alter a single nucleotide per mutation event, due to the extreme rarity of adjacent mutations. In this theoretical study, we suggest a radical reordering of the genetic code that maximizes the mutagenic potential of single nucleotide replacements. We explore several possible genetic codes that allow a greater degree of accessibility to the mutational landscape and may result in a hyperevolvable organism that could serve as an ideal platform for directed evolution experiments. We then conclude by evaluating the challenges of constructing such recoded organisms and their potential applications within the field of synthetic biology. IMPORTANCE The conservative nature of the genetic code prevents bioengineers from efficiently accessing the full mutational landscape of a gene via common errorprone methods. Here, we present two computational approaches to generate alternative genetic codes with increased accessibility. These new codes allow mutational transitions to a larger pool of amino acids and with a greater extent of chemical differences, based on a single nucleotide replacement within the codon, thus increasing evolvability both at the single-gene and at the genome levels. Given the widespread use of these techniques for strain and protein improvement, along with more fundamental evolutionary biology questions, the use of recoded organisms that maximize evolvability should significantly improve the efficiency of directed evolution, library generation, and fitness maximization. © 2017 Pines et al.",Article,Final,Scopus
Vasileva A.; Schmedding D.,57204609433; 23092137400,How to improve code quality by measurement and refactoring,2017,"Proceedings - 2016 10th International Conference on the Quality of Information and Communications Technology, QUATIC 2016",,,7814531,131,136,5,4,10.1109/QUATIC.2016.034,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013761756&doi=10.1109%2fQUATIC.2016.034&partnerID=40&md5=506a8d4149c96b30060c3ca6b84cc3c4,"In this paper, we show the successful integration of measurement of code quality into a software development process. Besides choosing a suitable tool for code analysis, metrics, and proper threshold values, concepts for removal of deficiencies are important requirements for code quality. Several cycles of a development process are necessary to achieve a long-term and effective integration of code quality into the development process. The integration of static analysis and refactoring of program code is achieved by Plan-Do-Check-Act cycle and didactic methods in a software development course at the university. © 2016 IEEE.",Conference paper,Final,Scopus
Cunha J.; Paulo Fernandes J.; Martins P.; Mendes J.; Pereira R.; Saraiva J.,23983985900; 7201540314; 57195251072; 7006448646; 35211356500; 57203315736,Evaluating refactorings for spreadsheet models,2016,Journal of Systems and Software,118,,,234,250,16,3,10.1016/j.jss.2016.04.043,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84971441815&doi=10.1016%2fj.jss.2016.04.043&partnerID=40&md5=3e3b59f67219342406adf481fe54f4d5,"Software refactoring is a well-known technique that provides transformations on software artifacts with the aim of improving their overall quality. We have previously proposed a catalog of refactorings for spreadsheet models expressed in the ClassSheets modeling language, which allows us to specify the business logic of a spreadsheet in an object-oriented fashion. Reasoning about spreadsheets at the model level enhances a model-driven spreadsheet environment where a ClassSheet model and its conforming instance (spreadsheet data) automatically co-evolves after applying a refactoring at the model level. Research motivation was to improve the model and its conforming instance: the spreadsheet data. In this paper we define such refactorings using previously proposed evolution steps for models and instances. We also present an empirical study we designed and conducted in order to confirm our original intuition that these refactorings have a positive impact on end-user productivity, both in terms of effectiveness and efficiency. The results are not only presented in terms of productivity changes between refactored and non-refactored scenarios, but also the overall user satisfaction, relevance, and experience. In almost all cases the refactorings improved end-users productivity. Moreover, in most cases users were more engaged with the refactored version of the spreadsheets they worked with. © 2016 Elsevier Inc. All rights reserved.",Article,Final,Scopus
Hauptmann B.; Eder S.; Junker M.; Juergens E.; Woinke V.,48861598700; 55319855300; 48861390600; 15020634100; 57188331400,Generating Refactoring Proposals to Remove Clones from Automated System Tests,2015,IEEE International Conference on Program Comprehension,2015-August,,7181438,115,124,9,6,10.1109/ICPC.2015.20,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961380979&doi=10.1109%2fICPC.2015.20&partnerID=40&md5=1a0f8deece875a8d4b816e24f3a30f23,"Automated system tests often have many clones, which make them complex to understand and costly to maintain. Unfortunately, removing clones is challenging as there are numerous possibilities of how to refactor them to reuse components such as subroutines. Additionally, clones often overlap partly which makes it particularly difficult to decide which parts to extract. If done wrongly, reuse potential is not leveraged optimally and structures between tests and reuse components will become unnecessarily complex. We present a method to support test engineers in extracting overlapping clones. Using grammar inference algorithms, we generate a refactoring proposal that demonstrates test engineers how overlapping clones can be extracted. Furthermore, we visualize the generated refactoring proposal to make it easily understandable for test engineers. An industrial case study demonstrates that our approach helps test engineers to gain information of the reuse potential of test suites and guides them to perform refactorings. © 2015 IEEE.",Conference paper,Final,Scopus
Srinivas M.; Krishna G.R.; Rao K.R.,7102823705; 56459678600; 57193164897,GA factor: A generic automated refactoring tool for the legacy software systems,2016,International Journal of Soft Computing,11,6,,391,396,5,0,10.3923/ijscomp.2016.391.396,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85011411821&doi=10.3923%2fijscomp.2016.391.396&partnerID=40&md5=ea5e44dde1fa5893b8810767140c973a,"Over the last two decades, many business organizations had noticed that a generous amount of nontrivial legacy software frame works fail due to unstructured architectural design. Moreover, refactoring is professional procedure for managing the software systems. Indeed, programmers practice regularly with refactoring tools in two different occasions-normal program development phase whenever and wherever design problems arise. Secondly these toolsare needed at the time of code duplication, specifically when adding a new feature, the programmer need to remove the duplication using the re-factor tool. Based on level of automation, refactoring can be classified into three categories-fully manual refactoring, semi-automatic refactoring and automatic refactoring. However, fully manual refactoring and semi-automatic refactoring tools are underused, because sometimes fails to recognize the legacy code and chasing the error messages that leads to more error-prone. This study proposed a novel refactoring tool called GA factor. The GA factor system detects a developer's legacy code, reminds to the programmer that the automatic refactoring is available and if the programmer accepts then GA factor complete the refactoring automatically. GA factor automatically performs static analysis for analyzing the flowof knowledgeof the code that saves the software engineer from doing erring. © Medwell Journals, 2016.",Article,Final,Scopus
Khan Y.A.; El-Attar M.,55314550400; 16030278200,Using model transformation to refactor use case models based on antipatterns,2016,Information Systems Frontiers,18,1,,171,204,33,15,10.1007/s10796-014-9528-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84959352795&doi=10.1007%2fs10796-014-9528-z&partnerID=40&md5=29562545ed19560b3f6226f646efaab4,"Use Case modeling is a popular technique for documenting functional requirements of software systems. Refactoring is the process of enhancing the structure of a software artifact without changing its intended behavior. Refactoring, which was first introduced for source code, has been extended for use case models. Antipatterns are low quality solutions to commonly occurring design problems. The presence of antipatterns in a use case model is likely to propagate defects to other software artifacts. Therefore, detection and refactoring of antipatterns in use case models is crucial for ensuring the overall quality of a software system. Model transformation can greatly ease several software development activities including model refactoring. In this paper, a model transformation approach is proposed for improving the quality of use case models. Model transformations which can detect antipattern instances in a given use case model, and refactor them appropriately are defined and implemented. The practicability of the approach is demonstrated by applying it on a case study that pertains to biodiversity database system. The results show that model transformations can efficiently improve quality of use case models by saving time and effort. © 2014, Springer Science+Business Media New York.",Article,Final,Scopus
Zhang Y.; Zhang D.; Wang H.,55816561700; 35303919200; 23390849100,Automated refactoring from synchronized locks to reentrant locks,2016,International Journal of Grid and Distributed Computing,9,6,,71,82,11,1,10.14257/ijgdc.2016.9.6.08,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027079530&doi=10.14257%2fijgdc.2016.9.6.08&partnerID=40&md5=464f585ab00519953eba2a44fb3c595e,"Multi-threaded Java applications using synchronized or reentrant locks respectively exist performance trade-off. Parallel programmers usually use manual refactoring to test the performance of locks in a particular environment. However, manual refactoring is labor-intensive and error-prone. There is a strong need for automated support to find which one is more suitable to exert the performance of applications. This paper presents a refactoring framework to enable the transformation from synchronized locks to reentrant locks automatically. The framework analyzes global monitors based on Quad intermediate representation and visitor pattern in the Joeq compiler, validates the consistency of analysis results, and performs the transformation. The framework is evaluated on three benchmarks including red-black tree, producer-consumer problem, and SPECjbb2005. The total time is less than 4s for all three benchmarks on common desktop computer, and the successful refactoring results are observed. © 2016 SERSC.",Article,Final,Scopus
Hermans F.; Pinzger M.; van Deursen A.,35573133300; 8244701600; 7003969355,Detecting and refactoring code smells in spreadsheet formulas,2015,Empirical Software Engineering,20,2,,549,575,26,47,10.1007/s10664-013-9296-2,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84928707326&doi=10.1007%2fs10664-013-9296-2&partnerID=40&md5=fbb265a2a8fe54731039a3bd6509019c,"Spreadsheets are used extensively in business processes around the world and just like software, spreadsheets are changed throughout their lifetime causing understandability and maintainability issues. This paper adapts known code smells to spreadsheet formulas. To that end we present a list of metrics by which we can detect smelly formulas; a visualization technique to highlight these formulas in spreadsheets and a method to automatically suggest refactorings to resolve smells. We implemented the metrics, visualization and refactoring suggestions techniques in a prototype tool and evaluated our approach in three studies. Firstly, we analyze the EUSES spreadsheet corpus, to study the occurrence of the formula smells. Secondly, we analyze ten real life spreadsheets, and interview the spreadsheet owners about the identified smells. Finally, we generate refactoring suggestions for those ten spreadsheets and study the implications. The results of these evaluations indicate that formula smells are common, that they can reveal real errors and weaknesses in spreadsheet formulas and that in simple cases they can be refactored. © 2014, Springer Science+Business Media New York.",Article,Final,Scopus
Manimekalai S.,57222335244,Component based software development using refactoring with form method,2016,International Journal of Control Theory and Applications,9,40,,7,17,10,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85010733386&partnerID=40&md5=7bd0b2cd83dd2a19db25a994ce030e74,"In industrial, for the enhancement and maintenance of software the Software Product Lines and Components Based Software Engineering (CBSE) is to increase the reuse level significantly. The Software Product Lines required to locate the problem of feature unpredictability that is a one feature may need different implementations for various customers. The refactoring method is used to reuse level of software in business components. During the planning stages, the domain analysis can be conducted by software product line engineering to manage the variability. However, high load planning processes are not well arranged with the minimal values of the practices. Refactoring techniques have been applied to develop the software quality attribute, but the refactoring effect on exacting quality attribute is still indefinite. Therefore, in this paper, the refactoring with Feature Oriented Reuse Method (FORM) is proposed to manage the variability of software development process. The CBSE is employed for the development of software that depends on reuse. CBSE is arising from the failure of object-oriented improvement to sustain reuse efficiently. Here the refactoring method is applied to improve the design of existing code for the Component Based Software Development. In FORM, for the development of reusable business components and architectures and the software applications are developed using the domain artifacts generated from the domain engineering. The feature model is an assessment space for software expansion and it is a high-quality starting point for discovering candidate reusable components. The refactoring is performed based on the software quality attributes. The software quality may be reusability, security, supportability, testability and maintainability. These methods can provide more efficient, reusable components for the software development in industries. © International Science Press.",Article,Final,Scopus
Clarke P.M.; Calafat A.L.M.; Ekert D.; Ekstrom J.J.; Gornostaja T.; Jovanovic M.; Johansen J.; Mas A.; Messnarz R.; Villar B.N.; O’Connor A.; O’Connor R.V.; Reiner M.; Sauberer G.; Schmitz K.-D.; Yilmaz M.,36536766400; 36537497300; 25633941500; 7005053176; 36602652700; 57210731385; 15831951900; 22635197600; 14034110200; 57191223747; 57190124009; 7202869241; 25634925900; 43461644500; 55927151800; 55738449500,Refactoring software development process terminology through the use of ontology,2016,Communications in Computer and Information Science,633,,,47,57,10,12,10.1007/978-3-319-44817-6_4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84987986864&doi=10.1007%2f978-3-319-44817-6_4&partnerID=40&md5=5b0b25abef0e17ee428b4dd2772fad9a,"In work that is ongoing, the authors are examining the extent of software development process terminology drift. Initial findings suggest there is a degree of term confusion, with the mapping of concepts to terms lacking precision in some instances. Ontologies are concerned with identifying the concepts of relevance to a field of endeavour and mapping those concepts to terms such that term confusion is reduced. In this paper, we discuss how ontologies are developed. We also identify various sources of software process terminology. Our work to date indicates that the systematic development of a software development process ontology would be of benefit to the entire software development community. The development of such an ontology would in effect represent a systematic refactoring of the terminology and concepts produced over four decades of software process innovation. © Springer International Publishing Switzerland 2016.",Conference paper,Final,Scopus
Orrú M.; Marchesi M.,55982780800; 7005947166,Assessment of approaches for the analysis of refactoring activity on software repositories an empirical study,2016,ACM International Conference Proceeding Series,24-May-16,,2962717,,,,1,10.1145/2962695.2962717,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84991448206&doi=10.1145%2f2962695.2962717&partnerID=40&md5=b45d9bbacd639d5a134a40e6c7b775e9,"Refactoring is the practice of changing source code without altering its external behavior. It is widely used since it is acknowledged to have a positive effect on software quality. However, different studies on the impact of Refactoring on software quality led to contrasting results. This might be due also to the fact that research works on Refactoring rely on different approaches to collect information about the refactoring activity on software repositories. Having a reliable approach is fundamental to draw solid conclusions. In this paper we empirically analyzed two of the most popular approaches to detect the refactoring activity on software repositories, finding that they return different outcomes. These results should be taken into account by researchers while designing the experimental settings of their studies. © 2016 ACM.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Di Pompeo D.,55317293800; 6603764364; 57188727238,Automated translation among EPSILON languages for performance-driven UML software model refactoring,2016,"IWoR 2016 - Proceedings of the 1st International Workshop on Software Refactoring, co-located with ASE 2016",,,,25,32,7,1,10.1145/2975945.2975951,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041550518&doi=10.1145%2f2975945.2975951&partnerID=40&md5=20913e22073ba6af8eb2e77e390d5196,"Although performance represents a crucial non-functional attribute of software, few model-based approaches have been introduced up today for reducing the gap between performance analysis results (e.g., mean response time) and the feedback expected by software engineers when performance problems are detected (i.e., refactoring actions). However, existing approaches aimed at performance-driven refactoring of software models suffer from fragmentation across different paradigms, languages, and meta-models. This paper aims at reducing such fragmentation by exploiting the EPSILON environment, which provides a suite of languages for checking properties and applying refactoring on models. In particular, we introduce automation aimed at translating performance antipattern detection rules and refactoring actions among three EPSILON languages. Such automation helps to reduce code writing effort, in the context of performance-driven refactoring of UML models, while exploiting the specific support provided by the different execution semantics of considered languages. © 2016 ACM.",Conference paper,Final,Scopus
,,"IWoR 2016 - Proceedings of the 1st International Workshop on Software Refactoring, co-located with ASE 2016",2016,"IWoR 2016 - Proceedings of the 1st International Workshop on Software Refactoring, co-located with ASE 2016",,,,,,42,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85055197104&partnerID=40&md5=c856df207098b9184dd0ff8a0cb9416d,The proceedings contain 7 papers. The topics discussed include: refactoring for software architecture smells; empirical evaluation of code smells in open source projects: preliminary results; measuring refactoring benefits: a survey of the evidence; graph-based approach for detecting impure refactoring from version commits; refactoring verification using model transformation; automated translation among EPSILON languages for performance-driven UML Software model refactoring; and full application of the extract interface refactoring: conceptual structures in the hands of master students.,Conference review,Final,Scopus
Wang H.; Kessentini M.; Grosky W.; Meddeb H.,57188742982; 25653537200; 7004119740; 57188742927,On the use of time series and search based software engineering for refactoring recommendation,2015,"7th International ACM Conference on Management of Computational and CollEctive Intelligence in Digital EcoSystems, MEDES 2015",,,,35,42,7,12,10.1145/2857218.2857224,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962708036&doi=10.1145%2f2857218.2857224&partnerID=40&md5=156cfd7aad3578e5f910772fe85ddd91,"To improve the quality of software systems, one of the widely used techniques is refactoring, defined as the process of improving the design of an existing system by changing its internal structure without altering the external behavior. The majority of existing refactoring works do not consider the impact of recommended refactorings on the quality of future releases of a system. In this paper, we propose to combine the use of search-based software engineering with time series to recommend good refactoring strategies in order to manage technical debt. We used a multi-objective algorithm to generate refactoring solutions that maximize the correction of important quality issues and minimize the effort. For these two fitness functions, we adapted time series forecasting to estimate the impact of the generated refactorings solution on future next releases of the system by predicting the evolution of the remaining code smells in the system, after refactoring, using different quality metrics. We evaluated our approach on one industrial project and a benchmark of 4 open source systems. The results confirm the efficiency of our technique to provide better refactoring management comparing to several existing refactoring techniques. © 2015 ACM.",Conference paper,Final,Scopus
Sreeji K.S.; Lakshmi C.,56910262300; 56433809200,A systematic literature review: Recent trends and open issues in software refactoring,2015,International Journal of Applied Engineering Research,10,18,,39696,39707,11,2,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84944564016&partnerID=40&md5=082ba197f7144b951eeeacbcdee14ad5,"Software refactoring is a process of improving the internal structure of software artifacts through various steps of transformations without affecting the externally observed behavior. Refactoring aims to improve the quality of the software in several aspects like code understandability, maintainability and modularity. Extensive researches are taking place in this area for the last decade and several papers are available for review in various angles of software like code smell detection, refactoring algorithms, patterns and refactoring, program evolution and refactoring and code clone detection. The aim of this review paper is to structure and organize the major findings published since 2004 with more emphasis given to papers published for the last five years to understand the current trends in refactoring and also to formulate better research problems for further research. © Research India Publications.",Article,Final,Scopus
Muqtadiroh F.A.; Astuti H.M.; Pradan A.P.,56543803200; 55821977600; 56543790100,Software quality measurement and improvement using refactoring and square metric methods,2015,Journal of Theoretical and Applied Information Technology,73,1,,80,90,10,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924385906&partnerID=40&md5=2f987fa9bd829b1f6881802f19a45b10,"Software requirement is one of critical factors in a successful software development. Based on some existing researches, a good or poor design of software relies heavily on the quality of software requirements as a definition of software requirements is certainly an early stage in software development. In an IT project, such as a development of School of Social Network (SSN), some problems concerning software quality requirements may occur any time. The changes occurring in the software requirements and the mismatch among the needs, designs, and final result of the project, can lead to poor quality of the software produced. To minimize the problems, it is necessary to measure the quality of software requirements based on SQuaRE Metrics using Refactoring. First, it is to determine the characteristics of software quality requirements. The determination of quality characteristics of SSN is based on an expert experience and eventually sets 4 attributes of software quality requirements that are considered very important, namely: Correctness, Completeness, Consistency and Non-Ambiguity. Second, it is to give a weight on each quality characteristic to obtain the IRQ value. Third, the process of refactoring is conducted to improve the usecase scenarios. And the last step is to re-measure the quality of re-factored software requirement. The early measurements showed that the quality requirements of the SSN reached 39%. Through refactoring process, the improvement of software requirements caused an increase of 6 use cases. And after repair by using refactoring, it increased the quality of the requirements of SSN by 62%. Refactoring is definitely helpful for enhancing the understanding on software requirements without changing the software business process. © 2005 - 2015 JATIT & LLS. All rights reserved.",Article,Final,Scopus
Arbiza L.M.R.; Bertholdo L.M.; Dos Santos C.R.P.; Granville L.Z.; Tarouco L.M.R.,55546004900; 22033285400; 25654751400; 6701779039; 9846634800,Refactoring internet of things middleware through software-defined network,2015,Proceedings of the ACM Symposium on Applied Computing,13-17-April-2015,,,640,645,5,6,10.1145/2695664.2695861,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84955459540&doi=10.1145%2f2695664.2695861&partnerID=40&md5=ca9375d89ef40cf367828c0672a0dbe6,"Refactoring means to rewrite pieces of code aiming to improve it internally but keeping the expected software behavior. In this paper we present the refactoring of an Internet of Things middleware based on Software-Defined Network. In a previous work we proposed a middleware to address issues we found in healthcare devices used to monitor patients with chronic illnesses in their homes. Software-Defined Network allowed the redesign of the middleware architecture to improve things management, its interconnection with services, and the deployment process of new monitoring scenarios. Refactoring process also extended the middleware to support multiple services in a single home network sharing the same network infrastructure. This work details an Open-Flow controller and an application developed to achieve our goals; we also present sample scenarios where our approach can be applied showing different services delivered in the same home network environment, and using data from all connected devices to build a digital representation of the physical realm. Copyright 2015 ACM.",Conference paper,Final,Scopus
Khlif W.; Ben-Abdallah H.,35766583000; 57192050350,Integrating semantics and structural information for BPMN model refactoring,2015,"2015 IEEE/ACIS 14th International Conference on Computer and Information Science, ICIS 2015 - Proceedings",,,7166674,656,660,4,10,10.1109/ICIS.2015.7166674,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84945253561&doi=10.1109%2fICIS.2015.7166674&partnerID=40&md5=27b0cae489ed446ba83269606a386e29,"Refactoring a business process model may enhance the understandability and/or ease the maintainability of the process. So far proposed refactoring approaches tackled only the structural aspect of a model. As we illustrate in this paper, combining the semantic aspect with the structural aspect further reduces the control flow complexity of a business process modeled in the Business Process Modelling Notation. Our refactoring method adapts a set of rules from the graph optimization domain. We illustrate the efficiency of a subset of the proposed rules through well-established complexity metrics. © 2015 IEEE.",Conference paper,Final,Scopus
Sz?ke G.; Nagy C.; Ferenc R.; Gyimóthy T.,55803891600; 26667913000; 6603559878; 6603266536,Designing and developing automated refactoring transformations: An experience report,2016,"2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2016",1,,7476700,693,697,4,11,10.1109/SANER.2016.17,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050995870&doi=10.1109%2fSANER.2016.17&partnerID=40&md5=2e37af091a1422ca2211f59fabf5d8ee,"There are several challenges which should be kept in mind during the design and development phases of a refactoring tool, and one is that developers have several expectations that are quite hard to satisfy. In this report, we present our experiences of a two-year project where we attempted to create an automatic refactoring tool. In this project, we worked with five software development companies that wanted to improve the maintainability of their products. The project was designed to take into account the expectations of the developers of these companies and consisted of three main stages: a manual refactoring phase, a tool building phase, and an automatic refactoring phase. Throughout these stages we collected the opinions of the developers and faced several challenges on how to automate refactoring transformations, which we present and summarize. © 2016 IEEE",Conference paper,Final,Scopus
Dubois D.J.; Trubiani C.; Casale G.,7202196910; 24781277400; 21742204200,Model-driven application refactoring to minimize deployment costs in preemptible cloud resources,2016,"IEEE International Conference on Cloud Computing, CLOUD",0,,7820289,335,342,7,6,10.1109/CLOUD.2016.50,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85014202261&doi=10.1109%2fCLOUD.2016.50&partnerID=40&md5=0f24a4bd9025b66bde9e04c52d1a9e17,"Performance assessment of cloud-based applications requires new methodologies to deal with the complexity of software systems and the variability of cloud resources. In this paper, we address the problem of reducing the total costs for running cloud-based applications while fulfilling servicelevel objectives (SLOs). To this end, we define an approach to refactor a cloud application in such a way that, when it is deployed, it requires less computational capacity and therefore less resources. We experimented our approach on top of a modified optimal provisioning heuristic designed for preemptible cloud resources and the results show that it reduces deployment costs, up to 60% when compared to the same approach, but without model-driven application refactoring. © 2016 IEEE.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Di Pompeo D.,55317293800; 6603764364; 57188727238,Towards a unifying approach for performance-driven software model refactoring,2015,CEUR Workshop Proceedings,1511,,,42,51,9,2,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962583142&partnerID=40&md5=57277e5a5f66d18161001bb25488e4b1,"Performance is a pervasive quality attribute of software systems. Since it plays a key role in the success of many projects, it is important to introduce approaches aimed at satisfying performance requirements from the early phases of software life-cycle. However, this is a complex problem, because a large gap exists between performance analysis results and the feedback expected by software designers. Some approaches proposed in the last few years aim at reducing such gap, based on automated Model-Driven Engineering techniques, but they are fragmented across different paradigms, languages and metamodels. The goal of this paper is to work towards an approach that enables performance problems detection and solution within an unique supporting environment. We rely on the Epsilon platform, which provides an ecosystem of task-specific languages, interpreters, and tools for MDE. We describe the approach that we are implementing, and we show how some of these languages nicely fit the needs of a unifying paradigm for performance-driven software model refactoring.",Conference paper,Final,Scopus
Kebir S.; Borne I.; Meslati D.,57190378426; 23392088100; 6507707445,A genetic algorithm for automated refactoring of component-based software,2015,EAI International Conference on Bio-inspired Information and Communications Technologies (BICT),,,,,,,1,10.4108/eai.3-12-2015.2262353,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052177873&doi=10.4108%2feai.3-12-2015.2262353&partnerID=40&md5=89963a615f74a8fa1a203494b162ec2d,"Nowadays a software undergoes modifications done by dif- ferent people to quickly fulfill new requirements, but its underlying design is not adjusted properly after each up- date. This leads to the emergence of bad smells. Refactoring provides a de facto behavior-preserving means to elim- inate these anomalies. However, manually determining and performing useful refactorings is known as an NP-Complete problem as stated by Harman et al. [9] because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search based technique. However the review of the litterature shows that automated refactoring of component- based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been pro- posed in the literature but there is a lack of component- relevant refactorings. In this paper we propose a catalogue of component-relevant refactoring as well as detections rules for component-relevant bad smells. Then we rely on these two ingredients to propose a genetic algorithm for automated refactoring of component-based software systems. © 2016 ICST.",Conference paper,Final,Scopus
Srinivas M.; Rama Krishna G.; Rajasekhara Rao K.,7102823705; 55613254000; 55786238400,Generating automatic certifying refactored engine for software legacy system,2016,ARPN Journal of Engineering and Applied Sciences,11,23,,13996,14003,7,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013096192&partnerID=40&md5=8d73084c3235a563ffb23b0de0ecefd9,"Refactoring or Platform migration is a process of improving the underlying design and architecture of legacy systems that subsequently can improve their performance and maintainability. Many of the legacy technologies are no longer supported, hence the need for migration. However, the refactoring tools are not correct in every possible cases and programmers cannot trust them. One has to make sure that the functionality of the legacy system remains intact after going through the process of migration. Hence there is a need to build certified refactoring tools which were useful for industrial developments. In this paper, we will address the complete automated certification mechanism which certifies all the functional components of a service or application and various process involved during the certification phase. We are particularly interested in complex program transformation based on a sequence of refactoring operations provided by eclipse tools. © 2006-2016 Asian Research Publishing Network (ARPN).",Article,Final,Scopus
Gerlitz T.; Schake S.; Kowalewski S.,50861005000; 57217827028; 7006648507,Duplicate detection and refactoring of Matlab/Simulink models; [Duplikatserkennung und Refactoring in Matlab/Simulink-Modellen],2015,Tagungsband - Dagstuhl-Workshop MBEES 2015: Modellbasierte Entwicklung Eingebetteter Systeme XI,,,,17,26,9,4,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84983369336&partnerID=40&md5=44b2925d5797046b6e87ab7c4b353afb,[No abstract available],Conference paper,Final,Scopus
Mohan M.; Greer D.; McMullan P.,57189345360; 35228903500; 7003939217,Technical debt reduction using search based automated refactoring,2016,Journal of Systems and Software,120,,,183,194,11,21,10.1016/j.jss.2016.05.019,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969523698&doi=10.1016%2fj.jss.2016.05.019&partnerID=40&md5=07eba65643d86978f95d37848a0257a0,"Software refactoring has been recognized as a valuable process during software development and is often aimed at repaying technical debt. Technical debt arises when a software product has been built or amended without full care for structure and extensibility. Refactoring is useful to keep technical debt low and if it can be automated there are obvious efficiency benefits. Using a combination of automated refactoring techniques, software metrics and metaheuristic searches, an automated refactoring tool can improve the structure of a software system without affecting its functionality. In this paper, four different refactoring approaches are compared using an automated software refactoring tool. Weighted sums of metrics are used to form different fitness functions that drive the search process towards certain aspects of software quality. Metrics are combined to measure coupling, abstraction and inheritance and a fourth fitness function is proposed to measure reduction in technical debt. The 4 functions are compared against each other using 3 different searches on 6 different open source programs. Four out of the 6 programs show a larger improvement in the technical debt function after the search based refactoring process. The results show that the technical debt function is useful for assessing improvement in quality. © 2016 Elsevier Inc.",Article,Final,Scopus
Wang M.; Pan W.; Jiang B.; Yuan C.,53986917700; 35230163600; 57193331129; 58594774000,CLEAR: Class level software refactoring using evolutionary algorithms,2015,Journal of Intelligent Systems,24,1,,85,97,12,2,10.1515/jisys-2013-0058,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84919650838&doi=10.1515%2fjisys-2013-0058&partnerID=40&md5=48e0975d52cecc34db4a6e4d1a0e402b,"The original design of a software system is rarely prepared for every new requirement. Software systems should be updated frequently, which is usually accompanied by the decline in software modularity and quality. Although many approaches have been proposed to improve the quality of software, a majority of them are guided by metrics defined on the local properties of software. In this article, we propose to use a global metric borrowed from the network science to detect the moving method refactoring. First, our approach uses a bipartite network to represent classes, features (i.e., methods and fields), and their dependencies. Second, a new metric is introduced to quantify the modularity of a software system as a whole. Finally, a crossover-only evolutionary algorithm that uses the metric as its fitness function is introduced to optimize the class structure of a software system and detect the methods that should be moved. Empirical results on the benchmark Java projects show that our approach can find meaningful methods that should be moved with a high stability. The advantages of our approach are illustrated in comparison with some other approaches, specifically one refactoring approach, namely search-based refactoring approach (SBRA), and two community detection algorithms, namely a graph theoretic clustering algorithm (MCODE) and a fast algorithm for community detection (FG). Our approach provides a new way to do refactoring from the perspective of software structure.",Article,Final,Scopus
Al Dallal J.,6508260263,Identifying refactoring opportunities in object-oriented code: A systematic literature review,2015,Information and Software Technology,58,,,231,249,18,78,10.1016/j.infsof.2014.08.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85027935153&doi=10.1016%2fj.infsof.2014.08.002&partnerID=40&md5=90b7e295c6674858bfb5c0fefee0fc4c,"Context: Identifying refactoring opportunities in object-oriented code is an important stage that precedes the actual refactoring process. Several techniques have been proposed in the literature to identify opportunities for various refactoring activities. Objective: This paper provides a systematic literature review of existing studies identifying opportunities for code refactoring activities. Method: We performed an automatic search of the relevant digital libraries for potentially relevant studies published through the end of 2013, performed pilot and author-based searches, and selected 47 primary studies (PSs) based on inclusion and exclusion criteria. The PSs were analyzed based on a number of criteria, including the refactoring activities, the approaches to refactoring opportunity identification, the empirical evaluation approaches, and the data sets used. Results: The results indicate that research in the area of identifying refactoring opportunities is highly active. Most of the studies have been performed by academic researchers using nonindustrial data sets. Extract Class and Move Method were found to be the most frequently considered refactoring activities. The results show that researchers use six primary existing approaches to identify refactoring opportunities and six approaches to empirically evaluate the identification techniques. Most of the systems used in the evaluation process were open-source, which helps to make the studies repeatable. However, a relatively high percentage of the data sets used in the empirical evaluations were small, which limits the generality of the results. Conclusions: It would be beneficial to perform further studies that consider more refactoring activities, involve researchers from industry, and use large-scale and industrial-based systems. © 2014 Elsevier B.V. All rights reserved.",Review,Final,Scopus
Misbhauddin M.; Alshayeb M.,36662537800; 6506030177,UML model refactoring: a systematic literature review,2015,Empirical Software Engineering,20,1,,206,251,45,74,10.1007/s10664-013-9283-7,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921700552&doi=10.1007%2fs10664-013-9283-7&partnerID=40&md5=9bd4c5338bcc803ea441c69992f12c8f,"Model-driven engineering, an emerging trend in software engineering, has enabled the use of refactoring to UML models. Numerous approaches to model refactoring, problem detection, consistency management, and tool support to automate and verify refactoring are discussed and distributed across numerous research literatures. This paper provides a systematic overview of existing research in the field of model refactoring. A total of 3,295 articles, related to the field of UML model refactoring, were extracted from well-known electronic databases. A multi-stage selection process was used to ensure proper inclusion of relevant studies for review and analysis. Ninety-four primary studies were eventually selected and analyzed based on a number of different criteria: UML models considered for refactoring, formalisms used to support refactoring at the model level, important to consider when building refactoring tool support, and the effect of refactoring on model quality. The results of this review indicate that UML model refactoring is a highly active area of research. Quite a few quality techniques and approaches have been proposed in this area, but it still has some important open issues and limitations to be addressed in future work. © 2013, Springer Science+Business Media New York.",Article,Final,Scopus
Steimann F.,55910765900,From well-formedness to meaning preservation: model refactoring for almost free,2015,Software and Systems Modeling,14,1,,307,320,13,10,10.1007/s10270-013-0314-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84922337862&doi=10.1007%2fs10270-013-0314-z&partnerID=40&md5=ad8f87125d26d001a1087d220dc4953f,"Modelling languages such as the UML specify well-formedness as constraints on models. For the refactoring of a model to be correct, it must take these constraints into account and check that they are still satisfied after the refactoring has been performed—if not, execution of the refactoring must be refused. By replacing constraint checking with constraint solving, we show how the role of constraints can be lifted from permitting or denying a tentative refactoring to computing additional model changes required for the refactoring to be executable. Thus, to the degree that the semantics of a modelling language is specified using constraints, refactorings based on these constraints are guaranteed to be meaning preserving. To be able to exploit constraints available in the form of a language’s well-formedness rules for refactoring, we present a mapping from these rules to the constraint rules required by constraint-based refactoring. Where there are no gaps between well-formedness and (static) semantics of a modelling language, these mappings enable structural refactorings of models at no extra cost; where there are, we identify ways of detecting and filling the gaps. © 2013, Springer-Verlag Berlin Heidelberg.",Article,Final,Scopus
Schuts M.; Hooman J.; Vaandrager F.,55337033000; 6701349187; 6701396047,Refactoring of legacy software using model learning and equivalence checking: An industrial experience report,2016,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),9681,,,311,325,14,30,10.1007/978-3-319-33693-0_20,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84977599369&doi=10.1007%2f978-3-319-33693-0_20&partnerID=40&md5=9f5102ba951c030f99390faa87d2a4bd,"Many companies struggle with large amounts of legacy software that is difficult to maintain and to extend. Refactoring legacy code typically requires large efforts and introduces serious risks because often crucial business assets are hidden in legacy components. We investigate the support of formal techniques for the rejuvenation of legacy embedded software, concentrating on control components. Model learning and equivalence checking are used to improve a new implementation of a legacy control component. Model learning is applied to both the old and the new implementation. The resulting models are compared using an equivalence check of a model checker. We report about our experiences with this approach at Philips. By gradually increasing the set of input stimuli, we obtained implementations of a power control service for which the learned behaviour is equivalent. © Springer International Publishing Switzerland 2016.",Conference paper,Final,Scopus
Tran Q.M.; Winkler J.; Dziobek C.,57197686333; 57193332700; 37041184800,SLRefactor: A refactoring approach for Simulink models; [SLRefactor: Ein Refactoring-Ansatz für Simulink-Modelle],2015,"Lecture Notes in Informatics (LNI), Proceedings - Series of the Gesellschaft fur Informatik (GI)",246,,,1661,1672,11,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85018243189&partnerID=40&md5=69d6d554ac1c0e4f9eb2e67ec4e370a0,[No abstract available],Conference paper,Final,Scopus
Ben Ammar B.; Bhiri M.T.,24503992500; 6504776054,Pattern-based model refactoring for the introduction association relationship,2015,Journal of King Saud University - Computer and Information Sciences,27,2,,170,180,10,5,10.1016/j.jksuci.2014.06.012,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84959935917&doi=10.1016%2fj.jksuci.2014.06.012&partnerID=40&md5=0a6a04270bfa56f67eba0810efd0071e,"Refactoring is an important software development process involving the restructuring of a model to improve its internal qualities without changing its external behavior. In this paper, we propose a new approach of model refactoring based on the combined use of UML, B and CSP. UML models are described by class diagrams, OCL constraints, and state machine diagrams. We detail a refactoring pattern that allows for the introduction of an association relationship between two existing classes. We illustrate our proposal by giving a case study involving the SAAT (Software Architecture Analysis Tool) system. © 2015 The Authors.",Article,Final,Scopus
Kádár I.; Hegedüs P.; Ferenc R.; Gyimóthy T.,56529171400; 25926433300; 6603559878; 6603266536,Assessment of the code refactoring dataset regarding the maintainability of methods,2016,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),9789,,,610,624,14,7,10.1007/978-3-319-42089-9_43,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84978196613&doi=10.1007%2f978-3-319-42089-9_43&partnerID=40&md5=4239246d21ba3b1699a61fd76f5ff645,"Code refactoring has a solid theoretical background while being used in development practice at the same time. However, previous works found controversial results on the nature of code refactoring activities in practice. Both their application context and impact on code quality needs further examination. Our paper encourages the investigation of code refactorings in practice by providing an excessive open dataset of source code metrics and applied refactorings through several releases of 7 open-source systems. We already demonstrated the practical value of the dataset by analyzing the quality attributes of the refactored source code classes and the values of source code metrics improved by those refactorings. In this paper, we have gone one step deeper and explored the effect of code refactorings at the level of methods. We found that similarly to class level, lower maintainability indeed triggers more code refactorings in practice at the level of methods and these refactorings significantly decrease size, coupling and clone metrics. © Springer International Publishing Switzerland 2016.",Conference paper,Final,Scopus
Szoke G.; Nagy C.; Fulop L.J.; Ferenc R.; Gyimothy T.,55803891600; 26667913000; 24576278500; 6603559878; 6603266536,FaultBuster: An automatic code smell refactoring toolset,2015,"2015 IEEE 15th International Working Conference on Source Code Analysis and Manipulation, SCAM 2015 - Proceedings",,,7335422,253,258,5,29,10.1109/SCAM.2015.7335422,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963532716&doi=10.1109%2fSCAM.2015.7335422&partnerID=40&md5=346d245cccaba9d6ce751e9775303d94,"One solution to prevent the quality erosion of a software product is to maintain its quality by continuous refac-toring. However, refactoring is not always easy. Developers need to identify the piece of code that should be improved and decide how to rewrite it. Furthermore, refactoring can also be risky; that is, the modified code needs to be re-tested, so developers can see if they broke something. Many IDEs offer a range of refactorings to support so-called automatic refactoring, but tools which are really able to automatically refactor code smells are still under research. In this paper we introduce FaultBuster, a refactoring toolset which is able to support automatic refactoring: identifying the problematic code parts via static code analysis, running automatic algorithms to fix selected code smells, and executing integrated testing tools. In the heart of the toolset lies a refactoring framework to control the analysis and the execution of automatic algorithms. FaultBuster provides IDE plugins to interact with developers via popular IDEs (Eclipse, Netbeans and IntelliJ IDEA). All the tools were developed and tested in a 2-year project with 6 software development companies where thousands of code smells were identified and fixed in 5 systems having altogether over 5 million lines of code. © 2015 IEEE.",Conference paper,Final,Scopus
Ahmed M.; Ibrahim R.; Ibrahim N.,56438492900; 23388898900; 56036883900,An adaptation model for android application testing with refactoring,2015,International Journal of Software Engineering and its Applications,9,10,,65,74,9,6,10.14257/ijseia.2015.9.10.07,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84946729588&doi=10.14257%2fijseia.2015.9.10.07&partnerID=40&md5=8357da81b296272afa89fddfd32ddf35,"Software testing is a set of activities that typically consumes roughly 50% of the total time and cost of testers during the software development process. Developing an enhanced technique to test mobile application becomes a necessity considering the high demand of mobile applications, android specifically, hence the need for software quality assurance. Adapting software testing model would not only lessen the cost incurred in the process of mobile application development but also increase the reliability of the software under test. In this paper, we discuss mobile application testing and its challenges. The Reweb and Testweb frameworks are also discussed followed by an adaptation model from both frameworks to improve testing of android applications. Asides from adapting these web application testing frameworks, another major contribution of our approach is the refactoring the source code before generating test cases to reduce redundancy in the test case library thereby improving the generated test case. © 2015 SERSC.",Article,Final,Scopus
Siebra C.; Gouveia T.; Sodre L.; Silva F.Q.B.; Santos A.L.M.,36979783900; 54420073600; 57190178272; 57219695226; 8832605700,The anticipated test design and its use in legacy code refactoring: Lessons learned from a real experiment,2016,"2016 International Conference on Information Technology for Organizations Development, IT4OD 2016",,,7479256,,,,1,10.1109/IT4OD.2016.7479256,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84978052582&doi=10.1109%2fIT4OD.2016.7479256&partnerID=40&md5=f310e0988d0bac7e8236eee54597abb5,"The maintenance of legacy code is a hard task since developers do not have access to details of its implementation. Thus, the refactoring of code units usually generates problems in other parts of the code that already had been validated. A solution to this problem is to use an anticipated test design methodology, where unit tests are first created to each module/class/methods before their modification. Thus, developers are able to ensure the correct performance of functions after their refactoring. This work discusses our experience in applying this methodology to the Data Access Object (DAO) layer refactoring of a real legacy application of a mobile multinational. Our results show that this strategy assists developers in better understanding the code and improves the performance of unit tests since they are produced by the own development team. Furthermore, we show the importance of the miniworld definition, which tries to represent a set of data that increases the coverage of the test process. © 2016 IEEE.",Conference paper,Final,Scopus
Fontana F.A.; Roveda R.; Vittori S.; Metelli A.; Saldarini S.; Mazzei F.,6601971118; 56411879800; 57191545006; 57190376005; 57191537444; 57191537491,On evaluating the impact of the refactoring of architectural problems on software quality,2016,ACM International Conference Proceeding Series,24-May-16,,2962716,,,,7,10.1145/2962695.2962716,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84991503926&doi=10.1145%2f2962695.2962716&partnerID=40&md5=a5293ee39b17f53a8650505d5db25bb9,"We can improve software quality in different ways and by removing different kinds of problems. In this paper, we focus our attention on architectural problems, as architectural smells or antipatterns represent, we remove some of these problems through refactoring steps and we check the impact that the refactoring has on different quality metrics. In particular, we focus our attention on some Quality Indexes computed by four tools. These tools are used also for the detection of the architectural problems. We present the results and outline different issues related to the impact of the refactoring of these architectural problems on the Quality Indexes and the difficulties in the choice of the problems to be refactored. © 2016 ACM.",Conference paper,Final,Scopus
Shinkarev A.,57194213616,Refactoring as complexity decreasing instrument of representation of traffic flow models based on cellular automata,2016,"2016 2nd International Conference on Industrial Engineering, Applications and Manufacturing, ICIEAM 2016 - Proceedings",,,7910924,,,,0,10.1109/ICIEAM.2016.7910924,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85019211802&doi=10.1109%2fICIEAM.2016.7910924&partnerID=40&md5=4b31c984871c6f5fc4413e3bfd376e39,"This paper combines results of several papers published by the author. In particular, results of analysis and creation of a new common representation of the traffic flow models based on the cellular automata theory are used. The necessity of transition to the four-stepped unified representation of the considered models group is justified. The refactoring approach that is applicable for the most models of the considered group is formulated based on the revised representation of the next models: Rule 184, Nagel-Schreckenberg model, Slow-to-Start Rule model, Multifactorial model and Adaptive Deceleration model. As the result of the described refactoring approach application, we have got a quite similar representation of the different models of the considered group; without a doubt, it makes it easier to sense these models group key concepts and decrease the barrier to entry for novices in this transportation modeling realm. © 2016 IEEE.",Conference paper,Final,Scopus
Fontana F.A.; Zanoni M.; Zanoni F.,6601971118; 56599129300; 56880162000,A duplicated code refactoring advisor,2015,Lecture Notes in Business Information Processing,212,,,3,14,11,13,10.1007/978-3-319-18612-2_1,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942780436&doi=10.1007%2f978-3-319-18612-2_1&partnerID=40&md5=dd3c485d0a5fdac99381f8d74b21cb40,"Refactoring is one of the key practices in Extreme Programming and other agile methods. Duplicated code is one of the most pervasive and pungent smells to remove from source code through refactoring. Duplicated code has been largely studied in the literature, and different types of duplications, or “clones”, have been identified. Some studies analyzed in details the problems caused by clones in the code, others outlined also the difficulties in removing clones, and the cases in which it could be better not removing them. The refactoring cost for removing clones can be very high, also due to the different choices on the possible refactoring steps. In this paper, we describe our approach and tool developed with the aim to suggest the best refactorings to remove clones in Java code. Our approach is based on the classification of the clones in terms of their location in a class hierarchy, and allows to choose among a restricted set of refactorings, which are then evaluated using multiple criteria. We provide a validation of the effectiveness of the approach. © Springer International Publishing Switzerland 2015.",Conference paper,Final,Scopus
Mondal M.; Roy C.K.; Schneider K.A.,7005459894; 36176304400; 7402470734,SPCP-Miner: A tool for mining code clones that are important for refactoring or tracking,2015,"2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2015 - Proceedings",,,7081861,484,488,4,33,10.1109/SANER.2015.7081861,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84928676238&doi=10.1109%2fSANER.2015.7081861&partnerID=40&md5=2cf69af86605077a056f7e60bcc0be54,"Code cloning has both positive and negative impacts on software maintenance and evolution. Focusing on the issues related to code cloning, researchers suggest to manage code clones through refactoring and tracking. However, it is impractical to refactor or track all clones in a software system. Thus, it is essential to identify which clones are important for refactoring and also, which clones are important for tracking. In this paper, we present a tool called SPCP-Miner which is the pioneer one to automatically identify and rank the important refactoring as well as important tracking candidates from the whole set of clones in a software system. SPCP-Miner implements the existing techniques that we used to conduct a large scale empirical study on SPCP clones (i.e., the clones that evolved following a Similarity Preserving Change Pattern called SPCP). We believe that SPCP-Miner can help us in better management of code clones by suggesting important clones for refactoring or tracking. © 2015 IEEE.",Conference paper,Final,Scopus
Shahjahan A.; Haider Butt W.; Ahmad A.Z.,57188747621; 26665905200; 57188748866,Impact of refactoring on code quality by using graph theory: An empirical evaluation,2015,IntelliSys 2015 - Proceedings of 2015 SAI Intelligent Systems Conference,,,7361201,595,600,5,7,10.1109/IntelliSys.2015.7361201,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962702574&doi=10.1109%2fIntelliSys.2015.7361201&partnerID=40&md5=88d444d04a86dc3ee053b96bdcf07ca2,"Refactoring is the process of improving code quality without affecting its external behaviour and by changing its internal structure. Refactoring is done to improve code quality and structure. In this research, we have proposed a new method of code refactoring by using graph theory techniques. Previously manual methods were used to identify the classes with high impact in refactoring. the proposed method has been implemented and applied on software projects developed in Java. Validation has been done by surveying software professionals to measure improve in code quality. © 2015 IEEE.",Conference paper,Final,Scopus
Cedrim D.; Sousa L.; Gheyi R.; Garcia A.,57194528845; 57194212913; 8365747700; 7404608626,Does refactoring improve software structural quality? A longitudinal study of 25 projects,2016,ACM International Conference Proceeding Series,,,,73,82,9,29,10.1145/2973839.2973848,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030768354&doi=10.1145%2f2973839.2973848&partnerID=40&md5=e40047b429754b6a6e90ecb407a1194a,"Code smells in a program represent indications of structural quality problems, which can be addressed by software refactoring. Refactoring is widely practiced by developers, and considerable development effort has been invested in refactoring tooling support. There is an explicit assumption that software refactoring improves the structural quality of a program by reducing its density of code smells. However, little has been reported about whether and to what extent developers successfully remove code smells through refactoring. This paper reports a first longitudinal study intended to address this gap. We analyze how often the commonly-used refactoring types affect the density of 5 types of code smells along the version histories of 25 projects. Our findings are based on the analysis of 2,635 refactorings distributed in 11 different types. Surprisingly, 2,506 refactorings (95.1%) did not reduce or introduce code smells. Thus, these findings suggest that refactorings lead to smell reduction less often than what has been reported. According to our data, only 2.24% of refactoring changes removed code smells and 2.66% introduced new ones. Moreover, several smells induced by refactoring tended to live long, i.e., 146 days on average. These smells were only eventually removed when smelly elements started to exhibit poor structural quality and, as a consequence, started to be more costly to get rid of. © 2016 ACM.",Conference paper,Final,Scopus
Fontana F.A.; Mangiacavalli M.; Pochiero D.; Zanoni M.,6601971118; 57186684300; 57186712500; 56599129300,On experimenting refactoring tools to remove code smells,2015,ACM International Conference Proceeding Series,25-29-May-2015,,a7,,,,17,10.1145/2764979.2764986,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961255102&doi=10.1145%2f2764979.2764986&partnerID=40&md5=45721977807ab086e96e39679bde12e7,"When we develop a software project of a certain complexity, source code maintainability could become a problem, in particular if developers do not use a consolidate development process that simplifies the management of the entire project. When source code becomes very complex, it is difficult for developers to share and modify it. We can improve internal software qualities such as reusability, maintainability and readability through refactoring. Refactoring can be applied to remove possible problems in the code, as code smells. Identifying code smells and removing them through refactoring results in better code maintainability, but it can be an overwhelming task. In this paper, we describe our experimentation on using four refactoring tools to remove code smells in four systems, with the aim to outline advantages and disadvantages of the tools with respect to the accomplishment of this task, and to identify the smells easier to be removed among the ones we considered in this paper. © 2015 ACM.",Conference paper,Final,Scopus
Simons C.; Singer J.; White D.R.,8147837800; 14827373300; 55538156100,Search-based refactoring: Metrics are not enough,2015,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),9275,,,47,61,14,42,10.1007/978-3-319-22183-0_4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84951271742&doi=10.1007%2f978-3-319-22183-0_4&partnerID=40&md5=5c4fa4a98e910b9309d5aafba6a4edbb,"Search-based Software Engineering (SBSE) techniques have been applied extensively to refactor software, often based on metrics that describe the object-oriented structure of an application. Recent work shows that in some cases applying popular SBSE tools to open-source software does not necessarily lead to an improved version of the software as assessed by some subjective criteria. Through a survey of professionals, we investigate the relationship between popular SBSE refactoring metrics and the subjective opinions of software engineers. We find little or no correlation between the two. Through qualitative analysis, we find that a simple static view of software is insufficient to assess software quality, and that software quality is dependent on factors that are not amenable to measurement via metrics. We recommend that future SBSE refactoring research should incorporate information about the dynamic behaviour of software, and conclude that a human-in-the-loop approach may be the only way to refactor software in a manner helpful to an engineer. © Springer International Publishing Switzerland 2015.",Conference paper,Final,Scopus
Durak U.,24334630800,Pragmatic model transformations for refactoring in Scilab/Xcos,2016,"International Journal of Modeling, Simulation, and Scientific Computing",7,1,1541004,,,,4,10.1142/S1793962315410044,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84947717804&doi=10.1142%2fS1793962315410044&partnerID=40&md5=90e346abd4134b1751f6f93c6ec2dbbf,"Model-Based Development has become an industry wide standard paradigm. As an open source alternative, Scilab/Xcos is being widely employed as a hybrid dynamic systems modeling tool. With the increasing efficiency in implementation using graphical model development and code generation, the modeling and simulation community is struggling with assuring quality as well as maintainability and extendibility. Refactoring is defined as an evolutionary modernization activity where, most of the time, the structure of the artifact is changed to alter its quality characteristics, while keeping its behavior unchanged. It has been widely established as a technique for textual programming languages to improve the code structure and quality. While refactoring is also regarded as one of the key practices of model engineering, the methodologies and approaches for model refactoring are still under development. Architecture-Driven Modernization (ADM) has been introduced by the software engineering community as a model-based approach to software modernization, in which the implicit information that lies in software artifacts is extracted to models and model transformations are applied for modernization tasks. Regarding refactoring as a low level modernization task, the practices from ADM are adaptable. Accordingly, this paper proposes a model-based approach for model refactoring in order to come up with more efficient and effective model refactoring methodology that is accessible and extendable by modelers. Like other graphical modeling tools, Scilab/Xcos also possesses a formalized model specification conforming to its implicit metamodel. Rather than proposing another metamodel for knowledge extraction, this pragmatic approach proposes to conduct in place model-to-model transformations for refactoring employing the Scilab/Xcos model specification. To construct a structured model-based approach, the implicit Scilab/Xcos metamodel is explicitly presented utilizing ECORE as a meta-metamodel. Then a practical model transformation approach is established based on Scilab scripting. A Scilab toolset is provided to the modeler for in-place model-to-model transformations. Using a sample case study, it is demonstrated that proposed model transformation functions in Scilab provide a valuable refactoring tool. © 2016 World Scientific Publishing Company.",Article,Final,Scopus
Costa R.S.; Costa H.; Parreira P.A.,57193153459; 26031311400; 35273395300,AOLink-Automatic gerenation of refactoring suggestions for aspect-oriented anomalies,2016,"Proceedings - International Conference of the Chilean Computer Science Society, SCCC",,,7836059,,,,0,10.1109/SCCC.2016.7836059,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85017586793&doi=10.1109%2fSCCC.2016.7836059&partnerID=40&md5=1688b8f6850dcadf71424f22f690a3ea,"Aspect-Orientation (AO) is a strategy to improve the internal structure of the software. However, using AO abstractions in an inappropriate way may also introduce bad smells in the software. To handle it, the developer needs to read catalogs of bad smells and refactorings. The problem is these catalogs are written in a non-standardized way, what make hard the understanding on them. Furthermore, the existing tools for AO bad smells detection do not present to the user the necessary refactoring to deal with them. This paper aims to present: (i) a standardized catalog of AO bad smells; and (ii) an extension, called AOLink, for a tool that detect AO bad smells. It is able to suggest the refactorings to deal with AO bad smells. The preliminary assessment performed on the proposed catalog showed that the recall and precision with respect to the bad smells detection may be improved. © 2016 IEEE.",Conference paper,Final,Scopus
Najafi M.; Haghighi H.; Nasab T.Z.,48662617300; 57189446914; 57190570228,A set of refactoring rules for UML-B specifications,2016,Computing and Informatics,35,2,,411,440,29,3,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84981288427&partnerID=40&md5=08dcaa6ee554f9262bf6d6b5203f7ad8,"UML-B is a graphical formal modelling notation which is based on UML and relics oil Event-B and its verification tools. In this paper, we propose annealing and introduce subtyping rules as well-known refactoring rules which can improve and assist the derivation of object-oriented design from an abstract specification written in UML-B. We prove that the proposed annealing rules are behavior preserving. We also demonstrate the applicability and effectiveness of our refactoring rules by applying them on two UML-B specifications.",Article,Final,Scopus
Khelladi D.E.; Bendraou R.; Gervais M.-P.,56728591300; 6507188884; 56216389000,AD-ROOM: A tool for automatic detection of refactorings in object-oriented models,2016,Proceedings - International Conference on Software Engineering,,,,617,620,3,13,10.1145/2889160.2889169,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85012095733&doi=10.1145%2f2889160.2889169&partnerID=40&md5=39a76adcf2d41da1267a37b9994ccc08,"Detecting refactorings in Object-Oriented Models (OOM) is essential to automate the repair, maintenance, and migration of OOM-related products. However, detecting refactorings is challenging since multiple sequences of atomic changes may define a single user intention and refactorings may overlap over the atomic change trace. In this paper, we present AD-ROOM, an Eclipse-based tool to automatically detect refactorings during evolution of OOM. In contrast to existing tools, AD-ROOM is designed to reach 100% recall that is confirmed in our eight case studies. We allow user confirmation and we support the user with three heuristics that help to improve the precision of AD-ROOM. See the demonstration video: https://youtu.be/4OJ8zHtfnq8 © 2016 ACM.",Conference paper,Final,Scopus
Kádár I.; Hegedüs P.; Ferenc R.; Gyimóthy T.,56529171400; 25926433300; 6603559878; 6603266536,A code refactoring dataset and its assessment regarding software maintainability,2016,"2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2016",2016-January,,,599,603,4,31,10.1109/SANER.2016.42,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85015318688&doi=10.1109%2fSANER.2016.42&partnerID=40&md5=0baa5f4a03fc366d2ec6af1531c960d5,"It is very common in various fields that there is a gap between theoretical results and their practical applications. This is true for code refactoring as well, which has a solid theoretical background while being used in development practice at the same time. However, more and more studies suggest that developers perform code refactoring entirely differently than the theory would suggest. Our paper encourages the further investigation of code refactorings in practice by providing an excessive open dataset of source code metrics and applied refactorings through several releases of 7 open-source systems. As a first step of processing this dataset, we examined the quality attributes of the refactored source code classes and the values of source code metrics improved by those refactorings. Our early results show that lower maintainability indeed triggers more code refactorings in practice and these refactorings significantly decrease complexity, code lines, coupling and clone metrics. However, we observed a decrease in comment related metrics in the refactored code. © 2016 IEEE.",Conference paper,Final,Scopus
Ouni A.; Kessentini M.; Sahraoui H.; Inoue K.; Deb K.,50761492200; 25653537200; 57196894039; 7601540520; 7006019904,Multi-criteria code refactoring using search-based software engineering: An industrial case study,2016,ACM Transactions on Software Engineering and Methodology,25,3,23,,,,111,10.1145/2932631,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84978052454&doi=10.1145%2f2932631&partnerID=40&md5=2d9a6e26e31902da8615a06995af7e2d,"One of the most widely used techniques to improve the quality of existing software systems is refactoring-the process of improving the design of existing code by changing its internal structure without altering its external behavior. While it is important to suggest refactorings that improve the quality and structure of the system, many other criteria are also important to consider, such as reducing the number of code changes, preserving the semantics of the software design and not only its behavior, and maintaining consistency with the previously applied refactorings. In this article, we propose a multi-objective search-based approach for automating the recommendation of refactorings. The process aims at finding the optimal sequence of refactorings that (i) improves the quality by minimizing the number of design defects, (ii) minimizes code changes required to fix those defects, (iii) preserves design semantics, and (iv) maximizes the consistency with the previously code changes. We evaluated the efficiency of our approach using a benchmark of six opensource systems, 11 different types of refactorings (move method, move field, pull up method, pull up field, push down method, push down field, inline class, move class, extract class, extract method, and extract interface) and six commonly occurring design defect types (blob, spaghetti code, functional decomposition, data class, shotgun surgery, and feature envy) through an empirical study conducted with experts. In addition, we performed an industrial validation of our technique, with 10 software engineers, on a large project provided by our industrial partner. We found that the proposed refactorings succeed in preserving the design coherence of the code, with an acceptable level of code change score while reusing knowledge from recorded refactorings applied in the past to similar contexts. © 2016 ACM.",Article,Final,Scopus
Alkhazi B.; Ruas T.; Kessentini M.; Wimmer M.; Grosky W.I.,57192870706; 35204056800; 25653537200; 14030698000; 7004119740,Automated refactoring of ATL model transformations: A search-based approach,2016,"Proceedings - 19th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems, MODELS 2016",,,,295,304,9,15,10.1145/2976767.2976782,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85008511987&doi=10.1145%2f2976767.2976782&partnerID=40&md5=1cf680042332a112246817fe0e7baa8b,"Model transformation programs evolve through a process of continuous change. However, this process may weaken the design of the transformation programs and make it unnecessarily complex, leading to increased fault-proneness. Refactoring improves the software design while preserving overall functionality and behavior. However, very few studies addressed the problem of refactoring model transformation programs. These existing studies provided an entirely manual or semi-automated refactoring support to transformation languages such as ATL. In this paper, we propose a fully-automated search-based approach to refactor model transformations based on a multi-objective algorithm that recommends the best refactoring sequence (e.g. extract rule, merge rules, etc.) optimizing a set of ATL-based quality metrics (e.g. number of rules, coupling, etc.). To validate our approach, we apply it to a comprehensive dataset of model transformations. The statistical analysis of our experiments over 30 runs shows that our automated approach recommended useful refactorings based on benchmark of ATL programs and compared to random search, mono-objective search formulation and a semi-automated refactoring approach not based heuristic search. © 2016 ACM.",Conference paper,Final,Scopus
Santos Neto B.F.D.; Ribeiro M.; Da Silva V.T.; Braga C.; De Lucena C.J.P.; De Barros Costa E.,36175426900; 57199329234; 7102297160; 8670867000; 54898975000; 23033597200,AutoRefactoring: A platform to build refactoring agents,2015,Expert Systems with Applications,42,3,,1652,1664,12,13,10.1016/j.eswa.2014.09.022,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908541659&doi=10.1016%2fj.eswa.2014.09.022&partnerID=40&md5=0e2349e9133138073a9f742716f69c98,"Software maintenance may degrade the software quality. One of the primary ways to reduce undesired effects of maintenance is refactoring, which is a technique to improve software code quality without changing its observable behavior. To safely apply a refactoring, several issues must be considered: (i) identify the code parts that should be improved; (ii) determine the changes that must be applied to the code in order to improve its; (iii) evaluate the corrections impacts on code quality; and (iv) check that the observable behavior of the software will be preserved after applying the corrections. Given the amount of issues to consider, refactoring by hand has been assumed to be an expensive and error-prone task. Therefore, in this paper, we propose an agent-based platform that enables to implement an agent able to autonomously deal with the above mentioned refactoring issues. To evaluate our approach, we performed an empirical study on code smells detection and correction, code quality improvement and preservation of the software observable behavior. To answer our research questions, we analyze 5 releases of Java open source projects, ranging from 166 to 711 classes. © 2014 Elsevier Ltd. All rights reserved.",Article,Final,Scopus
Zimmermann O.,23468051100,Architectural refactoring: A task-centric view on software evolution,2015,IEEE Software,32,2,7057560,26,29,3,27,10.1109/MS.2015.37,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84925036831&doi=10.1109%2fMS.2015.37&partnerID=40&md5=c62d6f85857b5d750438264fa918a54e,"A refactoring aims to improve a certain quality while preserving others. For example, code refactoring restructures code to make it more maintainable without changing its observable behavior. Given the success of code refactoring, it's surprising that architectural refactoring (AR) hasn't taken off yet. This article examines AR from a new angle: as an evolution technique that revisits architectural decisions and identifies related design, implementation, and documentation tasks. © 2015 IEEE.",Article,Final,Scopus
Samarthyam G.; Suryanarayana G.; Sharma T.,55320970300; 57190844683; 25224153100,Refactoring for software architecture smells,2016,"IWoR 2016 - Proceedings of the 1st International Workshop on Software Refactoring, co-located with ASE 2016",,,,1,4,3,20,10.1145/2975945.2975946,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050616894&doi=10.1145%2f2975945.2975946&partnerID=40&md5=559cc094ad5c19965986793ef3957b7b,"Code smells and refactoring have received considerable interest from the academia as well as from the industry in the past two decades. The interest has given birth to various tools, processes, techniques, and practices to identify smells and refactor them. Despite the high interest, architecture smells and corresponding refactorings haven’t received as much focus and adoption from the software engineering community. In this paper, we motivate the need of architecture refactoring, discuss the current related research, and present a few potential research directions for architecture refactoring. © 2016 ACM.",Conference paper,Final,Scopus
Devi U.; Sharma A.; Kesswani N.,57214544909; 57214355695; 56464247200,A review on quality models to analyse the impact of refactored code on maintainability with reference to software product line,2016,"Proceedings of the 10th INDIACom; 2016 3rd International Conference on Computing for Sustainable Global Development, INDIACom 2016",,,7724954,3705,3708,3,3,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84997503403&partnerID=40&md5=c1cc2086115f825aa0f6e2a0cf776b4e,"Code cloning is a major problem in object oriented methodology and advanced software methodologies like Software Product Line methodology (SPL). SPL Maintainability is a critical quality factor which is influenced by code cloning detection and correction. There are quality models to study and analyze such impacts. But existing quality models fall short in assessing the impact of code clones on them. Since SPL maintainability is one of the key factors when considering software quality, our study revolves around it. Also, the fact that not much experiments have been performed to assess and measure the impact of refactored code on SPL maintainability, we wish to divulge in that particular area. A review has been done which validates the need to quantify SPL maintainability before and after it has been refactored. © 2016 IEEE.",Conference paper,Final,Scopus
Fördos V.; Tóth M.,56369038600; 26422511300,Identifying code clones with refactorerl,2016,Acta Cybernetica,22,3,,553,571,18,1,10.14232/actacyb.22.3.2016.1,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84983339559&doi=10.14232%2factacyb.22.3.2016.1&partnerID=40&md5=d123d9a4a8477fa81b83d593af15e177,"Code clones, the results of ""copy&paste programming"", have a negative impact on software maintenance. Therefore several tools and techniques have been developed to identify them in the source code. Most of them concentrate on imperative, well known languages, while in this paper, we give an AST/metric based clone detection algorithm for the functional programming language Erlang. We propose a standalone solution that does not overload users with results that are insignificant from the point of view of the user. We emphasise that the maintenance costs can be decreased by using our solution, because the programmers need to deal only with important issues.",Article,Final,Scopus
Miralles A.; Huchard M.; Dolques X.; Le Ber F.; Libourel T.; Nebut C.; Osman-Guédi A.,7006811060; 6602390606; 36991851000; 57202981280; 15136092800; 15045364000; 55351480900,Increasing the abstraction level of a class model through a gradual refactoring; [Méthode de factorisation progressive pour accroître l’abstraction d’un modèle de classes],2015,Ingenierie des Systemes d'Information,20,2,,9,40,31,2,10.3166/ISI.20.2.9-39,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84965096345&doi=10.3166%2fISI.20.2.9-39&partnerID=40&md5=0b0b610fd01f1b7429c52545f42fdb77,"We are involved in the building by several actors of the class model of an information system in the environment domain. Actor concerns are various and sometimes conflicting, and progressively designing the model during working group sessions is required. This progressive improvement relies on the emergence of more abstract classes and associations. We use an optimization technique based on formal concept analysis. Nevertheless, building all abstractions in a single step produces too much concepts to be analyzed by the domain experts. In this paper, we propose a step-by-step approach, under the actor control, to extract these new abstractions. This solution is experimented on an environmental information system. © 2015 Lavoisier.",Article,Final,Scopus
Yoshida N.; Saika T.; Choi E.; Ouni A.; Inoue K.,36176694200; 56470444400; 41561025900; 50761492200; 7601540520,Revisiting the relationship between code smells and refactoring,2016,IEEE International Conference on Program Comprehension,2016-July,,7503738,,,,19,10.1109/ICPC.2016.7503738,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84979729400&doi=10.1109%2fICPC.2016.7503738&partnerID=40&md5=2ca56d0294d613a61553f016aa855ca9,"Refactoring is a critical technique in evolving software systems. Martin Fowler presented a catalogue of refactoring patterns that defines a list of code smells and their corresponding refactoring patterns. This list aimed at supporting programmers in finding suitable refactoring patterns that remove code smells from their systems. However, a recent empirical study by Bavota et al. shows that refactoring rarely removes code smells which do not align with Fowler's catalog. To bridge the gap between them, we revisit the relationship between code smells and refactorings. In this study, we investigate whether developers apply appropriate refactoring patterns to fix code smells in three open source software systems. © 2016 IEEE.",Conference paper,Final,Scopus
Griswold W.G.; Opdyke W.F.,7006192093; 6603499634,The Birth of Refactoring: A Retrospective on the Nature of High-Impact Software Engineering Research,2015,IEEE Software,32,6,7274256,30,38,8,16,10.1109/MS.2015.107,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84946563422&doi=10.1109%2fMS.2015.107&partnerID=40&md5=1d81abaeae8270f7b7e6400eb5c0e106,"Software refactoring was independently invented in the late '80s by two students in two research groups: Ralph Johnson's group at the University of Illinois and David Notkin's group at the University of Washington. This article provides a retrospective of the birth of refactoring, reflecting on how the ideas came about and were developed in those two students' doctoral dissertations. The analysis provides useful insights for both researchers and practitioners seeking high impact in their work. This article is part of a special issue on Refactoring. © 2015 IEEE.",Article,Final,Scopus
Szoke G.; Nagy C.; Hegedus P.; Ferenc R.; Gyimothy T.,55803891600; 26667913000; 25926433300; 6603559878; 6603266536,Do automatic refactorings improve maintainability? An industrial case study,2015,"2015 IEEE 31st International Conference on Software Maintenance and Evolution, ICSME 2015 - Proceedings",,,7332494,429,438,9,13,10.1109/ICSM.2015.7332494,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961637893&doi=10.1109%2fICSM.2015.7332494&partnerID=40&md5=1bc053308bb62c20339bc810e3e3fa1b,"Refactoring is often treated as the main remedy against the unavoidable code erosion happening during software evolution. Studies show that refactoring is indeed an elemental part of the developers' arsenal. However, empirical studies about the impact of refactorings on software maintainability still did not reach a consensus. Moreover, most of these empirical investigations are carried out on open-source projects where distinguishing refactoring operations from other development activities is a challenge in itself. We had a chance to work together with several software development companies in a project where they got extra budget to improve their source code by performing refactoring operations. Taking advantage of this controlled environment, we collected a large amount of data during a refactoring phase where the developers used a (semi)automatic refactoring tool. By measuring the maintainability of the involved subject systems before and after the refactorings, we got valuable insights into the effect of these refactorings on large-scale industrial projects. All but one company, who applied a special refactoring strategy, achieved a maintainability improvement at the end of the refactoring phase, but even that one company suffered from the negative impact of only one type of refactoring. © 2015 IEEE.",Conference paper,Final,Scopus
Xuan J.; Cornu B.; Martinez M.; Baudry B.; Seinturier L.; Monperrus M.,25640418400; 56511995300; 55938368500; 57203847520; 6603303741; 6506353145,B-Refactoring: Automatic test code refactoring to improve dynamic analysis,2016,Information and Software Technology,76,,,65,80,15,25,10.1016/j.infsof.2016.04.016,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84965136564&doi=10.1016%2fj.infsof.2016.04.016&partnerID=40&md5=7f80f2bb795e4b7ba2c1f6d6e0978c89,"Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks. © 2016 Elsevier B.V. All rights reserved.",Article,Final,Scopus
Jin T.; Wang J.; Yang Y.; Wen L.; Li K.,57192435256; 16306106100; 10042024700; 14030649200; 7404989623,Refactor Business Process Models with Maximized Parallelism,2016,IEEE Transactions on Services Computing,9,3,6991557,456,468,12,12,10.1109/TSC.2014.2383391,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84976562506&doi=10.1109%2fTSC.2014.2383391&partnerID=40&md5=34eb40616c84c5ba9fcbd4106796d721,"With the broad use of business process management technology, there are more and more business process models. Since the ability of different modelers is different, the quality of these models varies. A question arises here is that, can we refactor these models to improve the quality as practised in software engineering? Business process modeling can be regarded as declarative programming, and business process models can be used to drive the process aware information systems, which are generally developed with model driven architecture, so business process models are crucial for the efficiency of process aware information systems. In this paper, we propose a novel approach on how to systematically refactor business process models with parallel structures for sequence structures for the first time. More specifically, we analyze the real causal relations between business tasks based on data operation dependency analysis, and refactor business process models with process mining technology. After comprehensive model refactoring, parallel execution of business tasks can be maximized, so the efficiency of business processing can be improved, that is, the quality of business process models can be improved. Analysis and experiments show that our approach is effective and efficient. © 2008-2012 IEEE.",Article,Final,Scopus
Ichii M.; Shimbara D.; Suzuki Y.; Ogawa H.,24724571000; 55326011500; 57204104558; 26032684700,Refactoring verification using model transformation,2016,"IWoR 2016 - Proceedings of the 1st International Workshop on Software Refactoring, co-located with ASE 2016",,,,17,24,7,0,10.1145/2975945.2975950,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85055207280&doi=10.1145%2f2975945.2975950&partnerID=40&md5=6fe686ee1a96917436fbe05331ad6567,"Software refactoring is an effective way for dealing with technical debt accumulated in a software system; however, regression risk prevents developers from refactoring their code. Herein, we propose an approach to check the equivalence of source code before and after refactoring using the AST-based model extracted from source code. In order to detect unintended changes to the program structure, our approach first transforms the model from the refactored code in accordance with the refactoring pattern so that the refactoring is cancelled, and then compares it with the model from the code before refactoring. We also built a tool named POM/EQ based on the Eclipse Modeling Framework for checking C/C++ source code. As a result of the case study using the tool, we successfully checked 56 % of the refactoring changes that are performed on an industrial product. © 2016 ACM.",Conference paper,Final,Scopus
Orrú M.; Marchesi M.,55982780800; 7005947166,A case study on the relationship between code ownership and refactoring activities in a Java software system,2016,"Proceedings - 7th International Workshop on Emerging Trends in Software Metrics, WETSoM 2016",,,,43,49,6,4,10.1145/2897695.2897702,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84974623996&doi=10.1145%2f2897695.2897702&partnerID=40&md5=7d06be1008b09f33c86c76ff0ff87cf9,"Refactoring, the activity of changing source code design with- out affecting its external behavior, is a widely used practice among developers, since it is considered to positively affect the quality of software systems. However, there are some ""human factors"" to be considered while performing refactor-ing, including developers knowledge of systems architecture. Recent studies showed how much ""people"" metrics, such as code ownership, might affect software quality as well. In this preliminary study we investigated the relationship between code ownership and refactoring activity performed by developers. This study can provide useful insights on who performs refactoring and help team leaders to properly man- age human resources during software development. © 2016 ACM.",Conference paper,Final,Scopus
Kaur A.; Kaur M.,57222024069; 57146467600,Analysis of Code Refactoring Impact on Software Quality,2016,MATEC Web of Conferences,57,,2012,,,,17,10.1051/matecconf/20165702012,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84973299040&doi=10.1051%2fmatecconf%2f20165702012&partnerID=40&md5=cf4645db361fc7004d438a13428f732b,"Code refactoring is a ""Technique used for restructuring an existing source code, improving its internal structure without changing its external behaviour"". It is the process of changing a source code in such a way that it does not alter the external behaviour of the code yet improves its internal structure. It is a way to clean up code that minimizes the chances of introducing bugs. Refactoring is a change made to the internal structure of a software component to make it easier to understand and cheaper to modify, without changing the observable behaviour of that software component. Bad smells indicate that there is something wrong in the code that have to refactor. There are different tools that are available to identify and remove these bad smells. It is a technique that change our source code in a more readable and maintainable form by removing the bad smells from the code. Refactoring is used to improve the quality of software by reducing the complexity. In this paper bad smells are found and perform the refactoring based on these bad smell and then find the complexity of program and compare with initial complexity. This paper shows that when refactoring is performed the complexity of software decrease and easily understandable. © Owned by the authors, published by EDP Sciences, 2016.",Conference paper,Final,Scopus
Tsantalis N.; Mazinanian D.; Krishnan G.P.,8839792600; 55308236700; 55907104300,Assessing the Refactorability of Software Clones,2015,IEEE Transactions on Software Engineering,41,11,7130676,1055,1090,35,61,10.1109/TSE.2015.2448531,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961859281&doi=10.1109%2fTSE.2015.2448531&partnerID=40&md5=cdb051704cb736baa857bdf25119c199,"The presence of duplicated code in software systems is significant and several studies have shown that clones can be potentially harmful with respect to the maintainability and evolution of the source code. Despite the significance of the problem, there is still limited support for eliminating software clones through refactoring, because the unification and merging of duplicated code is a very challenging problem, especially when software clones have gone through several modifications after their initial introduction. In this work, we propose an approach for automatically assessing whether a pair of clones can be safely refactored without changing the behavior of the program. In particular, our approach examines if the differences present between the clones can be safely parameterized without causing any side-effects. The evaluation results have shown that the clones assessed as refactorable by our approach can be indeed refactored without causing any compile errors or test failures. Additionally, the computational cost of the proposed approach is negligible (less than a second) in the vast majority of the examined cases. Finally, we perform a large-scale empirical study on over a million clone pairs detected by four different clone detection tools in nine open-source projects to investigate how refactorability is affected by different clone properties and tool configuration options. Among the highlights of our conclusions, we found that a) clones in production code tend to be more refactorable than clones in test code, b) clones with a close relative location (i.e., same method, type, or file) tend to be more refactorable than clones in distant locations (i.e., same hierarchy, or unrelated types), c) Type-1 clones tend to be more refactorable than the other clone types, and d) clones with a small size tend to be more refactorable than clones with a larger size. © 2015 IEEE.",Article,Final,Scopus
Verebi I.,24479044300,A model-based approach to software refactoring,2015,"2015 IEEE 31st International Conference on Software Maintenance and Evolution, ICSME 2015 - Proceedings",,,7332524,606,609,3,6,10.1109/ICSM.2015.7332524,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961642270&doi=10.1109%2fICSM.2015.7332524&partnerID=40&md5=3ba506c38d06275d2d2fbdefba0a9a19,"Refactoring is a key activity for any software system, as it ensures that the system is easily maintainable and extensible. However, complex refactorings (restructurings) are largely performed by hand, as there are no automated means of chaining existent basic refactorings. In addition, developers cannot quickly and safely evaluate the effects of a restructuring solution over another. In this context, we introduce a model-based approach to software refactoring, which provides an easy and safe way to explore restructuring alternatives. Restructurings are written as a composition of low-level model transformations, making them reusable in different complex refactorings. In order to support our approach, we implemented a tool named reFactor, which aims to bridge the gap between design flaw detection and correction. It detects design problems and offers a platform to compose model transformations into composite restructurings, while permanently monitoring the overall quality of the code. © 2015 IEEE.",Conference paper,Final,Scopus
Dea T.J.,57191404749,Improving the performance of many-objective software refactoring technique using dimensionality reduction,2016,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),9962 LNCS,,,298,303,5,4,10.1007/978-3-319-47106-8_26,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84989849031&doi=10.1007%2f978-3-319-47106-8_26&partnerID=40&md5=1e0949e680194d7f83c4c120e2be008f,"Software quality Assessment involves the measurement of a large number of software attributes referred to as quality metrics. In most searchedbased software engineering processes, an optimization algorithm is used to evaluate a certain number of maintenance operations by minimizing or maximizing these quality metrics. One such process is software refactoring. When the solution to the problem includes a large number of objectives, various difficulties arise, including the determination of the Pareto-optimal front, and the visualization of the solutions. However, in some refactoring problem, there may be redundancies among any two or more objectives. In this paper, we propose a new software refactoring approach named PCA-NSGA-II many-objective refactoring. This approach is based on the PCA-NSGA-II evolutionary multi-objective algorithm, and can overcome the curse of dimensionality by removing redundancies to retain conflicting objectives for further analysis. © Springer International Publishing AG 2016.",Conference paper,Final,Scopus
Lin Y.; Peng X.; Cai Y.; Dig D.; Zheng D.; Zhao W.,56683209800; 53865467700; 23003221700; 13404654100; 57161975500; 8320355200,Interactive and guided architectural refactoring with search-based recommendation,2016,Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering,13-18-November-2016,,,535,546,11,58,10.1145/2950290.2950317,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84997124483&doi=10.1145%2f2950290.2950317&partnerID=40&md5=a398b600201d12b8e78ac14606f33ccb,"Architectural refactorings can contain hundreds of steps and experienced developers could carry them out over several weeks. Moreover, developers need to explore a correct sequence of refactorings steps among many more incorrect alternatives. Thus, carrying out architectural refactorings is costly, risky, and challenging. In this paper, we present Refactoring Navigator: A tool-supported and interactive recommendation approach for aiding architectural refactoring. Our approach takes a given implementation as the starting point, a desired high-level design as the target, and iteratively recommends a series of refactoring steps. Moreover, our approach allows the user to accept, reject, or ignore a recommended refactoring step, and uses the user's feedback in further refactoring recommendations. We evaluated the effectiveness of our approach and tool using a controlled experiment and an industrial case study. The controlled experiment shows that the participants who used Refactoring Navigator accomplished their tasks in 77.4% less time and manually edited 98.3% fewer lines than the control group. The industrial case study suggests that Refactoring Navigator has the potential to help with architectural refactorings in practice. © 2016 ACM.",Conference paper,Final,Scopus
Tanhaei M.; Habibi J.; Mirian-Hosseinabadi S.-H.,36239539500; 56219524600; 24344603600,A Feature Model Based Framework for Refactoring Software Product Line Architecture,2016,Journal of Computer Science and Technology,31,5,,951,986,35,9,10.1007/s11390-016-1674-y,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84984908557&doi=10.1007%2fs11390-016-1674-y&partnerID=40&md5=bb87ce0a2218e447cdac76a5b15fa444,"Software product line (SPL) is an approach used to develop a range of software products with a high degree of similarity. In this approach, a feature model is usually used to keep track of similarities and differences. Over time, as modifications are made to the SPL, inconsistencies with the feature model could arise. The first approach to dealing with these inconsistencies is refactoring. Refactoring consists of small steps which, when accumulated, may lead to large-scale changes in the SPL, resulting in features being added to or eliminated from the SPL. In this paper, we propose a framework for refactoring SPLs, which helps keep SPLs consistent with the feature model. After some introductory remarks, we describe a formal model for representing the feature model. We express various refactoring patterns applicable to the feature model and the SPL formally, and then introduce an algorithm for finding them in the SPL. In the end, we use a real-world case study of an SPL to illustrate the applicability of the framework introduced in the paper. © 2016, Springer Science+Business Media New York.",Article,Final,Scopus
Baqais A.; Alshayeb M.,54921732100; 6506030177,Automatic refactoring of single and multiple-view uml models using artificial intelligence algorithms,2016,"MODELSWARD 2016 - 4th International Conference on Model-Driven Engineering and Software Development, Doctoral Consortium",,,,3,8,5,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969916696&partnerID=40&md5=38a0161b3118fe2c9925c02eaf241f96,[No abstract available],Conference paper,Final,Scopus
Khatchadourian R.; Moore O.; Masuhara H.,24469948000; 57189074787; 7103057135,Towards improving interface modularity in legacy Java software through automated refactoring,2016,MODULARITY Companion 2016 - Companion Proceedings of the 15th International Conference on Modularity,,,,104,106,2,3,10.1145/2892664.2892681,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84965022940&doi=10.1145%2f2892664.2892681&partnerID=40&md5=0453e1752b0de893b6aabbb746a6c6d0,"The skeletal implementation pattern is a software design pattern consisting of defining an abstract class that provides a partial interface implementation. However, since Java allows only single class inheritance, if implementers decide to extend a skeletal implementation, they will not be allowed to extend any other class. Also, discovering the skeletal implementation may require a global analysis. Java 8 enhanced interfaces alleviate these problems by allowing interfaces to contain (default) method implementations, which implementers inherit. Java classes are then free to extend a different class, and a separate abstract class is no longer needed; developers considering implementing an interface need only examine the interface itself.We argue that both these benefits improve software modularity, and discuss our ongoing work in developing an automated refactoring tool that would assist developers in taking advantage of the enhanced interface feature for their legacy Java software. © 2016 ACM.",Conference paper,Final,Scopus
Srinivas M.; Rama Krishna G.,7102823705; 55613254000,Design and analysis of automatic verification of refactored legacy code in software systems,2016,Ponte,72,12,,366,379,13,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85016133811&partnerID=40&md5=e8be8be1a1e24db6c7ca36458873637c,"The software development is primarily more important for the business organisation due to its dynamic changes that has to be carried out in a less span of time. Over the last two decades, many business organizations had noticed that a generous amount of non-trivial legacy software frameworks fail due to unstructured architectural design. Consequently, software reuse will improves the quality of the product, increases the productivity and reduces the costs in an organization.Refactoring is professional procedure for managing the software systems. Indeed, programmers practice regularly with refactoring tools in two different occasions-normal program development phase whenever and wherever design problems arise. Secondly these tools are needed at the time of code duplication, specifically when adding a new feature, the programmer need to remove the duplication using the re-factor tool. Based on level of automation, refactoring can be classified into three categories-Fully manual refactoring, Semiautomatic refactoring and automatic refactoring. However, fully manual refactoring and semiautomatic refactoring tools are underused, because sometimes fails to recognize the legacy code and chasing the error messages that leads to more error-proneHowever, the refactoring tools are not correct in every possible cases, and programmers cannot trust them. One has to make sure that the functionality of the legacy system remains intact after going through the process of migration. Hence there is a need to build certified refactoring tools which were useful for industrial developments.This paper presents generic automated tools for analyzing the legacy software systems, a novel refactoring tool called GAFactor which detects a developer's legacy code, complete the refactoring automatically and finally we propose the complete automated certification mechanism which certifies all the functional components of a service or application and various processes involved during the certification phase.",Article,Final,Scopus
Ambrus T.; Tóth M.; Asztalos D.; Borbély Z.,57191345042; 26422511300; 6507641627; 57191347500,Tool to measure and refactor complex UML models,2016,CEUR Workshop Proceedings,1677,,,1,8,7,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84988981993&partnerID=40&md5=37b5f580b94de0bd76c68aa4f023cc0b,"Modifying and maintaining the source code of existing software products take the majority of time in the software development lifecycle. The same problem appears when the software is designed in a modeling environment with UML. Therefore, providing the same toolchain that already exists in the area of source code based development is required for UML modeling as well. This toolchain includes not just editors, but debugging tools, version controlling systems, static analysers and refactoring tools as well. In this paper we introduce a refactoring tool for UML models built within the Papyrus framework. Beside the transformations, the tool is able to measure the complexity of UML models and propose transformations to reduce the complexity.",Conference paper,Final,Scopus
Scholtes I.; Zanetti M.S.; Tessone C.J.; Schweitzer F.,19639626000; 55319930500; 6602779977; 7005771861,Automated Software Remodularization Based on Move Refactoring - A Complex Systems Approach,2015,"Lecture Notes in Informatics (LNI), Proceedings - Series of the Gesellschaft fur Informatik (GI)",P-239,,,85,86,1,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85134725168&partnerID=40&md5=42ed379f95e06fd233f001aab7138b5a,"Modular design is a desirable characteristic that fosters the comprehensibility and thus maintainability of software systems. While many software systems are initially created in a modular way, over time modularity typically degrades. In our work, we propose an automated strategy to remodularize software based on move refactorings, i.e. moving classes between packages without changing other aspects of the source code. Taking a complex systems perspective, our approach applies network theory to the dynamics of software dependency structures. Drawing inspiration from statistical physics, we use the Potts Spin Model and turn it into a stochastic remodularization algorithm which is based on probabilistically moving classes between modules. We test our method on 39 open source JAVA software projects. Comparing the modular structure produced by developers with that optimized by our algorithm, we find that our method is able to improve modularity by an average of 166 ± 77 percent. Our work highlights the potential of interdisciplinary applications of methods from the statistical physics perspective on complex systems to software engineering. © 2015 Gesellschaft fur Informatik (GI). All rights reserved.",Conference paper,Final,Scopus
Simons C.; Smith J.,8147837800; 7410180217,Exploiting antipheromone in ant colony optimisation for interactive search-based software design and refactoring,2016,GECCO 2016 Companion - Proceedings of the 2016 Genetic and Evolutionary Computation Conference,,,,143,144,1,5,10.1145/2908961.2909018,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84986255579&doi=10.1145%2f2908961.2909018&partnerID=40&md5=7429111e7b0155061b2761a7a881c18e,"Preventing user-fatigue in interactive meta-heuristic search places as great an emphasis on efficiency as it does on effectiveness. Engagement may also be boosted if the system provides a sense of ""responsiveness"" - for example, avoiding unpopular solutions as well as exploiting preferred ones. In this paper we explore one possible way of achieving these goals using the concept of ""anti-pheromones"" in different forms of Ant Colony Optimisation. Taking search-based software design and refactoring as a case study, we use extensive offline experiments to investigate differences of timescale and method for applying anti-pheromones. Results confirm our predictions that most combinations are in fact counter-productive. However, applying high levels of anti-pheromone, only in the initial stages of a run, can rapidly steer the search away from unproductive regions, reducing the number of evaluations required by up to 20% without compromising solution fitness. © 2016 Copyright held by the owner/author(s).",Conference paper,Final,Scopus
Malhotra R.; Chug A.; Khosla P.,15758058000; 56168650500; 57171824600,Prioritization of classes for refactoring: A step towards improvement in software quality,2015,ACM International Conference Proceeding Series,10-13-August-2015,,,228,234,6,19,10.1145/2791405.2791463,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84960946558&doi=10.1145%2f2791405.2791463&partnerID=40&md5=66afe12f62bd9aeb0134cdec917b2ac7,"Bad Smells are certain structures in the software which violates the design principles and ruin the software quality. In order to deals with the bad smells, often refactoring treatment is provided in the code which further improves the software quality. However, it's not possible to refactor each and every class of the software in maintenance phase due to certain deadlines. Prioritization of classes helps the developer to identify the software portions requiring urgent refactoring. In the current study, we propose a framework to identify the potential classes which immediately require refactoring based on the bad smells as well as design characteristics. We evaluate our approach on medium sized open- source systems ORDrumbox. Four types of code-smells Feature Envy, Long Method, God Class and Type Checking were identified and well known Chidamber and Kemerer metric suite is used to evaluate the object oriented characteristics. Both are combined in certain ratio to calculate new proposed metric Quality Depreciation Index Rule (QDIR) for each class. Classes are further arranged as per their QDIR values to identify the severely affected classes requiring immediate refactoring treatment. This study works on 80:20 principles conveying 80% of the code quality can be improved by just providing refactoring treatment to 20% of the severely affected classes. Results reflects that the bad smells and design metrics can be used as an important source of information to quantify the flaws in the classes, thus helpful to maintainers in performing their task under strict time constraints while maintaining the overall software quality. © 2015 ACM.",Conference paper,Final,Scopus
Techapalokul P.; Tilevich E.,57189044783; 6507251807,Programming environments for blocks need first-class software refactoring support: A position paper,2015,"Proceedings - 2015 IEEE Blocks and Beyond Workshop, Blocks and Beyond 2015",,,7369015,109,111,2,3,10.1109/BLOCKS.2015.7369015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964828802&doi=10.1109%2fBLOCKS.2015.7369015&partnerID=40&md5=22868f06f4f0cc7fea3d5e2245684191,"Block-based programming languages and their development environments have become a widely used educational platform for novices to learn how to program. In addition, these languages and environments have been increasingly embraced by domain experts to develop end-user software. Though popular for having a «low floor» (easy to get started), programs written in block-based languages often become unwieldy as projects grow progressively more complex. Software refactoring -improving the design quality of a codebase while preserving its external functionality -has been shown highly effective as a means of improving the quality of software written in text-based languages. Unfortunately, programming environments for blocks lack systematic software refactoring support. In this position paper, we argue that first-class software refactoring support must become an essential feature in programming environments for blocks; we present our research vision and concrete research directions, including program analysis to detect «code smells,» automated transformations for block-based programs to support common refactoring techniques, and integration of refactoring into introductory computing curricula. © 2015 IEEE.",Conference paper,Final,Scopus
Sirqueira T.F.M.; Brandl A.H.M.; Pedro E.J.P.; Silva R.D.S.; Araújo M.A.P.,56904287500; 57188865132; 57188862691; 57188866776; 35848063200,Code Smell Analyzer: A Tool To Teaching Support Of Refactoring Techniques Source Code,2016,IEEE Latin America Transactions,14,2,7437235,877,884,7,4,10.1109/TLA.2016.7437235,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963951626&doi=10.1109%2fTLA.2016.7437235&partnerID=40&md5=3b5d5dd0034527b083a59d126afb23af,"The present paper addresses the refactoring techniques defended by Martin Fowler (2002), and bad smells present in your work. A tool was developed to support teaching and assessing academic works called Code Smell Analyzer, which aims to identify bad smells codes, presenting how they can be corrected and avoided using refactoring techniques. The tool works integrated into the Eclipse IDE (Integrated Development Environment) and aims to assist in the teaching and assessment of academic works about bad smells and refactoring of source code. © 2016 IEEE.",Article,Final,Scopus
Meng N.; Hua L.; Kim M.; McKinley K.S.,42161811400; 57020866900; 57203466476; 35583751400,Does automated refactoring obviate systematic editing?,2015,Proceedings - International Conference on Software Engineering,1,,7194591,392,402,10,41,10.1109/ICSE.2015.58,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84951791981&doi=10.1109%2fICSE.2015.58&partnerID=40&md5=2a7744f666b008b5072dd107a87255c1,"When developers add features and fix bugs, they often make systematic edits-similar edits to multiple locations. Systematic edits may indicate that developers should instead refactor to eliminate redundancy. This paper explores this question by designing and implementing a fully automated refactoring tool called RASE, which performs clone removal. RASE (1) extracts common code guided by a systematic edit; (2) creates new types and methods as needed; (3) parameterizes differences in types, methods, variables, and expressions; and (4) inserts return objects and exit labels based on control and data flow. To our knowledge, this functionality makes RASE the most advanced refactoring tool for automated clone removal. We evaluate RASE with real-world systematic edits and compare to method based clone removal. RASE successfully performs clone removal in 30 of 56 method pairs (n=2) and 20 of 30 method groups (n=3) with systematic edits. We find that scoping refactoring based on systematic edits (58%), rather than the entire method (33%), increases the applicability of automated clone removal. Automated refactoring is not feasible in the other 42% cases, which indicates that automated refactoring does not obviate the need for systematic editing. © 2015 IEEE.",Conference paper,Final,Scopus
Cheng Y.C.; Jwo J.-S.; Tsai C.-T.,55487650500; 7003386599; 7404968387,A leading indicator of post-release defect density in refactoring-based software maintenance: A case study,2016,Journal of Internet Technology,17,3,,589,597,8,0,10.6138/JIT.2016.17.3.20151110d,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84973533363&doi=10.6138%2fJIT.2016.17.3.20151110d&partnerID=40&md5=443ff2b68efabf587f8512ac4ec59093,"We look to create a leading indicator to relate the trend-of-change of the post-release defect density for two consecutive releases of a software product. We propose a rational form in which the ratio of changes of each identified internal quality factor appears as a multiplicative term either at the numerator or at the de-nominator. For a collection of factors identified as interrelated to refactoring, the best formulation is found experimentally by exhaustive enumeration. In the case study that involves a maintenance phase to bring the post-release defect densities of two suites of tools down to within the organization's upper limit, the proposed leading indicator correctly generated the desired negative correlation with the trend of changes in postrelease defect density.",Conference paper,Final,Scopus
Gatrell M.; Counsell S.,35271862700; 7005059140,The effect of refactoring on change and fault-proneness in commercial C# software,2015,Science of Computer Programming,102,,,44,56,12,29,10.1016/j.scico.2014.12.002,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84923301872&doi=10.1016%2fj.scico.2014.12.002&partnerID=40&md5=da52ef6043d024443458cff5142dac66,"Refactoring is a process for improving the internal characteristics and design of software while preserving its external behaviour. Refactoring has been suggested as a positive influence on the long-term quality and maintainability of software and, as a result, we might expect benefits of a lower future change or fault propensity by refactoring software. Conversely, many studies show a correlation between change and future faults; so application of a refactoring may in itself increase future fault propensity, negating any benefit of the refactoring. In this paper, we determine whether the refactoring process reaps future maintenance benefits and, as a consequence, results in software with a lower propensity for both faults and change. We studied a large, commercial software system over a twelve-month period and identified a set of refactored classes during the middle four months of the study; a bespoke tool was used to detect occurrences of fifteen types of refactoring. We then examined the fault- and change-proneness of the same set of refactored classes in the four months prior to, during, and after the period of refactoring to determine if change or fault activity was reduced either during or after the period of refactoring studied. We also compared these trends with remaining classes in the system that had not been refactored over the same periods. Results revealed that refactored classes experienced a lower change-proneness in the period after refactoring and were significantly less fault-prone during and after the period of refactoring, even when accounting for the effects of change. The study therefore presents concrete evidence of the benefits of refactoring in these two senses. © 2015 Elsevier B.V. All rights reserved.",Article,Final,Scopus
Gaitani M.A.G.; Zafeiris V.E.; Diamantidis N.A.; Giakoumakis E.A.,56483251100; 15752340900; 6506193987; 6601998278,Automated refactoring to the Null Object design pattern,2015,Information and Software Technology,59,,,33,52,19,19,10.1016/j.infsof.2014.10.010,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921033188&doi=10.1016%2fj.infsof.2014.10.010&partnerID=40&md5=23f43c7b7890d36767c4e5d812a99ea6,"Context Null-checking conditionals are a straightforward solution against null dereferences. However, their frequent repetition is considered a sign of poor program design, since they introduce source code duplication and complexity that impacts code comprehension and maintenance. The Null Object design pattern enables the replacement of null-checking conditionals with polymorphic method invocations that are bound, at runtime, to either a real object or a Null Object. Objective This work proposes a novel method for automated refactoring to Null Object that eliminates null-checking conditionals associated with optional class fields, i.e., fields that are not initialized in all class instantiations and, thus, their usage needs to be guarded in order to avoid null dereferences. Method We introduce an algorithm for automated discovery of refactoring opportunities to Null Object. Moreover, we specify the source code transformation procedure and an extensive set of refactoring preconditions for safely refactoring an optional field and its associated null-checking conditionals to the Null Object design pattern. The method is implemented as an Eclipse plug-in and is evaluated on a set of open source Java projects. Results Several refactoring candidates are discovered in the projects used in the evaluation and their refactoring lead to improvement of the cyclomatic complexity of the affected classes. The successful execution of the projects' test suites, on their refactored versions, provides empirical evidence on the soundness of the proposed source code transformation. Runtime performance results highlight the potential for applying our method to a wide range of project sizes. Conclusion Our method automates the elimination of null-checking conditionals through refactoring to the Null Object design pattern. It contributes to improvement of the cyclomatic complexity of classes with optional fields. The runtime processing overhead of applying our method is limited and allows its integration to the programmer's routine code analysis activities. © 2014 Elsevier B.V. All rights reserved.",Article,Final,Scopus
Ichii M.; Ogawa H.,24724571000; 26032684700,Checking refactoring using model transformation,2015,Computer Software,32,3,,70,76,6,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942437021&partnerID=40&md5=752a4d10f06ab06453a73fdf311ce5e3,"We propose a method for checking the behavior preservation property of refactoring based on static analysis of source code. Our method detects difference of program structure using AST-based models that are extracted from the source code and transformed according to the refactoring patterns. We also built a tool named POM/EQ that checks C/C++ source code. As a result of the case study using the tool, we successfully judged the validity of 56% of the refactoring changes that are performed to an industrial product.",Article,Final,Scopus
Makka S.; Sagar B.B.,57189322821; 55811522300,Simulation of a model for refactoring approach for parallelism using parallel computing tool box,2016,"Smart Innovation, Systems and Technologies",51,,,77,84,7,0,10.1007/978-3-319-30927-9_8,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969244102&doi=10.1007%2f978-3-319-30927-9_8&partnerID=40&md5=b1c5cc080675dfd03fe39e11da4ed617,"Refactoring is the process of retaining the behavior of a program by making changes to the structure of a program. Initially refactoring is used only for sequential programs, but due to highly configurated architectural availability, it also aids parallel programmers in implementing their parallel applications. Refactoring provides many advantages to parallel programmers, in identifying independent modules, in refining process of programs, it also helps in separating concerns between application and system programmers, and it reduces the time for deployment. All mentioned advantages benefit the programmer in writing parallel programs. The approach for refactoring using multi core system is already developed. Hence all these advantages made us to thought of a system to develop refactoring approach for parallelism which uses heterogeneous parallel architectures which uses combination of both Graphic Processing Unit (GPU) and Central Processing Unit (CPU). A Tool in MATLAB, Parallel Computing Toolbox can be used to execute programs on multiple processing elements simultaneously with local workers available in the toolbox, which takes benefit of GPUs. This tool box uses complete processing speed of multi core system to execute applications on local workers without changing the code. Our suggested model can be simulated by using Parallel Computing Toolbox. © Springer International Publishing Switzerland 2016.",Conference paper,Final,Scopus
Choudhary A.; Singh P.,57192957857; 57202959177,"Minimizing refactoring effort through prioritization of classes based on historical, architectural and code smell information",2016,CEUR Workshop Proceedings,1771,,,76,79,3,8,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85009466009&partnerID=40&md5=696c7c304db407e66bf56b8784f350e8,"Improving a software system's internal structure through regular refactoring is considered vital for its long and healthy life. However, despite its amenities, refactoring is not readily adopted by software development teams in industry mainly due to strict project deadlines and limited resources. Hence, they look for optimal refactoring recommendations that would incur minimal effort overhead while outputting decent benefits in terms of enhanced software quality. To this end, we propose an approach for identifying and prioritizing object-oriented software classes in need of refactoring. Our approach first identifies the most refactoring-prone as well as architecturally relevant classes, and then generates class ranks based on the code smell information. In addition to locating classes with the most significant incremental refactoring opportunities, this work contributes through suggesting developers on estimating maximum code smell correction (paying off maximum technical debt) with minimum refactoring effort. We evaluated the proposed approach on a sample of 1621 classes and 2358 code smell instances, distributed over 28 versions of four open source java systems. © 2016, CEUR-WS. All rights reserved.",Conference paper,Final,Scopus
Rajdev U.; Kaur A.,57215271861; 57215275293,Automatic detection of bad smells from excel sheets and refactor for performance improvement,2016,"Proceedings of the International Conference on Inventive Computation Technologies, ICICT 2016",2,,7824903,,,,1,10.1109/INVENTIVE.2016.7824903,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85011035343&doi=10.1109%2fINVENTIVE.2016.7824903&partnerID=40&md5=8476bcdac07955980fc7f0a32211316d,"This paper presents the prevailing analysis, as well as some of experimental findings analogous to the factual study of so called Bad smells. An anatomy is presented which categorize bad smells given by Fowler in context of object-oriented programming. Many research papers have been published quantifying the effect of code smells on maintenance efforts. Notion of bad smells can be applied to multiple areas other than Software. This paper intends to give a review to look for bad smells in the context of spreadsheets. Many authors in past years have worked on spreadsheet bad smells. Here in this paper, a systematic review is proposed demonstrating list of bad smells for spreadsheets and related work issued in past in field of spreadsheet bad smells. © 2016 IEEE.",Conference paper,Final,Scopus
Desai A.B.; Parmar J.K.,57150023300; 56905290100,Refactoring Cost Estimation (RCE) Model for Object Oriented System,2016,"Proceedings - 6th International Advanced Computing Conference, IACC 2016",,,7544837,214,218,4,3,10.1109/IACC.2016.48,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84987725518&doi=10.1109%2fIACC.2016.48&partnerID=40&md5=0b4503da086827f56eab3ecbf7343492,"Successful software systems must be developedto evolve or die. Although object-oriented softwaresystems are to be built to last over the time but they willdegrade as much as any legacy software system. As aconsequence, one may identify various reengineeringpatterns which capture best practice in reverse and re-engineering object-oriented legacy systems. Software reengineeringbasically focuses on re-implementing oldersystems to improve or make it more maintainable. Refactoring is on kind of re-engineering with-in an Object-Oriented context. In this paper, with the given object-oriented refactoring opportunities, the cost ofrefactoring is resembled using RCE. The opportunities areclass misuse, violation of the principle of encapsulation, lack of use of inheritance concept, misuse of inheritance, misplaced polymorphism. © 2016 IEEE.",Conference paper,Final,Scopus
Elezi L.; Sali S.; Demeyer S.; Murgia A.; Pèrez J.,57191542767; 57191535981; 6602168026; 36237030700; 56910411600,A game of refactoring. Studying the impact of gamification in software refactoring,2016,ACM International Conference Proceeding Series,24-May-16,,2962718,,,,2,10.1145/2962695.2962718,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84991445513&doi=10.1145%2f2962695.2962718&partnerID=40&md5=e027fb3be07fa9e0326087e420aa8dd9,"Software refactoring is an essential skill for developers. It improves the quality of the software and reduces maintenance costs in the long run. In this paper, we investigate the impact that gamification can have on the refactoring process and on the usability of the existing refactoring tools. For this reason we created CodeArena, a gamifocation system that tracks and rewards refactorings during development. We used CodeArena in an exploratory study which involved 12 students of computer science. Then, we collected the feedback provided by these students via a survey. Although the gamification had less effect than expected, our findings can be useful to practitioners interested in promoting refactoring tools via gamification. © 2016 ACM.",Conference paper,Final,Scopus
Parsai A.; Murgia A.; Soetens Q.D.; Demeyer S.,56446920400; 36237030700; 36810722200; 6602168026,Mutation testing as a safety net for test code refactoring,2015,ACM International Conference Proceeding Series,25-29-May-2015,,a8,,,,4,10.1145/2764979.2764987,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961252273&doi=10.1145%2f2764979.2764987&partnerID=40&md5=8f5fe86a9a02fee36582f073d3722c7e,"Refactoring is an activity that improves the internal structure of the code without altering its external behavior. When performed on the production code, the tests can be used to verify that the external behavior of the production code is preserved. However, when the refactoring is performed on test code, there is no safety net that assures that the external behavior of the test code is preserved. In this paper, we propose to adopt mutation testing as a means to verify if the behavior of the test code is preserved after refactoring. Moreover, we also show how this approach can be used to identify the part of the test code which is improperly refactored. © 2015 ACM.",Conference paper,Final,Scopus
Kadar I.; Hegedus P.; Ferenc R.; Gyimothy T.,56529171400; 25926433300; 6603559878; 6603266536,A manually validated code refactoring dataset and its assessment regarding software maintainability,2016,ACM International Conference Proceeding Series,,,2972962,,,,17,10.1145/2972958.2972962,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047085071&doi=10.1145%2f2972958.2972962&partnerID=40&md5=71bd468a3c7aca0de500ec210bffab80,"Refactoring is a popular technique for improving the internal structure of software systems. It has a solid theoretical background while being used in development practice at the same time. However, we lack empirical research results on the real effect of code refactoring and its ways of application. This paper presents a manually validated dataset of applied refactorings and source code metrics and maintainability of 7 open-source systems. It is a subset of our previously published dataset containing the refactoring instances automatically extracted by the RefFinder tool. We found that RefFinder had around 27% overall average precision on the subject systems, thus our new – manually validated – subset has substantial added value allowing researchers to perform more accurate empirical investigations. Using this data, we were able to study whether refactorings were really triggered by poor maintainability of the code, or by other aspects. The results show that source code elements subject to refactorings had significantly lower maintainability values (approximated by source code metric aggregation) than elements not affected by refactorings between two releases. © 2016 ACM.",Conference paper,Final,Scopus
Kebir S.; Borne I.; Meslati D.,57190378426; 23392088100; 6507707445,Automatic Refactoring of component-based software by detecting and eliminating bad smells a search-based approach,2016,ENASE 2016 - Proceedings of the 11th International Conference on Evaluation of Novel Software Approaches to Software Engineering,,,,210,215,5,2,10.5220/0005891602100215,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84979642838&doi=10.5220%2f0005891602100215&partnerID=40&md5=73f6e8668c75c4c7b546589304ada34e,"Refactoring has been proposed as a de facto behavior-preserving mean to eliminate bad smells. However manually determining and performing useful refactorings is a though challenge because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search-based technique. Nevertheless the review of the literature shows that automated refactoring of component-based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been proposed in the literature but there is a lack of component-relevant refactorings. In this paper we propose detection rules for component-relevant bad smells as well as a catalogue of component-relevant refactorings. Then we rely on these two elements to propose a search-based approach for automated refactoring of component-based software systems by detecting and eliminating bad smells. Finally, we experiment our approach on a medium-sized component-based software and we assess the efficieny and accuracy of our approach. Copyright © 2016 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.",Conference paper,Final,Scopus
Chen Z.,57190860338,Helping mobile software code reviewers: A study of bug repair and refactoring patterns,2016,"Proceedings - International Conference on Mobile Software Engineering and Systems, MOBILESoft 2016",,,,34,35,1,0,10.1145/2897073.2897130,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84983474478&doi=10.1145%2f2897073.2897130&partnerID=40&md5=ebe86d226608d07d26dfe3ad2910a1d1,"Mobile Developers commonly spend a significant amount of time and effort on conducting code reviews on newly introduced and domain-specific practices, such as platform-specific feature addition, quality of service anti-pattern refactorings, and battery-related bug fixes. To address these problems, we conducted a large empirical study over the software change history of 318 open source projects and investigated platform-dependent code changes from open source projects. Our analysis focuses on what types of changes mobile application developers typically make and how they perceive, recall, and communicate changed and affected code. Our study required the development of an automated strategy to examine open source repositories and categorize platform-related refactoring edits, bug repairs, and API updates, mining 1,961,990 commit changes. Our findings call for the need to develop a new recommendation system aimed at efficiently identifying required changes such as bug fixes and refactorings during mobile application code reviews. © 2016 Copyright held by the owner/author(s).",Conference paper,Final,Scopus
Khrishe Y.; Alshayeb M.,57191163828; 6506030177,An empirical study on the effect of the order of applying software refactoring,2016,Proceedings - CSIT 2016: 2016 7th International Conference on Computer Science and Information Technology,,,7549471,,,,10,10.1109/CSIT.2016.7549471,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84987596934&doi=10.1109%2fCSIT.2016.7549471&partnerID=40&md5=e18181a1f31cc7b23f5cf0e3d8e782f1,"Refactoring has been widely used to improve software design. Refactoring is applied when a bad smell is detected. Several bad smells might be present in the code. In this paper, we conduct an empirical study to find if the order of applying refactoring has any impact on the quality of the final code. We run six experiments by applying three refactoring methods in different orders and evaluate the quality of the code using software metrics at the end of each refactoring sequence. Our experiments results show that that applying refactoring in different order provides different impact on the final code. © 2016 IEEE.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Trubiani C.,55317293800; 6603764364; 24781277400,Performance-based software model refactoring in fuzzy contexts,2015,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),9033,,,149,164,15,12,10.1007/978-3-662-46675-9_10,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84944250248&doi=10.1007%2f978-3-662-46675-9_10&partnerID=40&md5=cf9d84b3b46a125503e976e0bb5e4937,"The detection of causes of performance problems in software systems and the identification of refactoring actions that can remove the problems are complex activities (even in small/medium scale systems). It has been demonstrated that software models can nicely support these activities, especially because they enable the introduction of automation in the detection and refactoring steps. In our recent work we have focused on performance antipattern-based detection and refactoring of software models. However performance antipatterns suffer from the numerous thresholds that occur in their representations and whose binding has to be performed before the detection starts (as for many pattern/antipattern categories). In this paper we introduce an approach that aims at overcoming this limitation. We work in a fuzzy context where threshold values cannot be determined, but only their lower and upper bounds do. On this basis, the detection task produces a list of performance antipatterns along with their probabilities to occur in the model. Several refactoring alternatives can be available to remove each performance antipattern. Our approach associates an estimate of how effective each alternative can be in terms of performance benefits. We demonstrate that the joint analysis of antipattern probability and refactoring benefits drives the designers to identify the alternatives that heavily improve the software performance. © Springer-Verlag Berlin Heidelberg 2015.",Conference paper,Final,Scopus
Vidal S.A.; Marcos C.; Díaz-Pace J.A.,36142371300; 15124839500; 14017872900,An approach to prioritize code smells for refactoring,2016,Automated Software Engineering,23,3,,501,532,31,106,10.1007/s10515-014-0175-x,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84917706742&doi=10.1007%2fs10515-014-0175-x&partnerID=40&md5=f0488395c29723c78a0fd6d47681d473,"Code smells are a popular mechanism to find structural design problems in software systems. Consequently, several tools have emerged to support the detection of code smells. However, the number of smells returned by current tools usually exceeds the amount of problems that the developer can deal with, particularly when the effort available for performing refactorings is limited. Moreover, not all the code smells are equally relevant to the goals of the system or its health. This article presents a semi-automated approach that helps developers focus on the most critical problems of the system. We have developed a tool that suggests a ranking of code smells, based on a combination of three criteria, namely: past component modifications, important modifiability scenarios for the system, and relevance of the kind of smell. These criteria are complementary and enable our approach to assess the smells from different perspectives. Our approach has been evaluated in two case-studies, and the results show that the suggested code smells are useful to developers. © 2014, Springer Science+Business Media New York.",Article,Final,Scopus
Fu H.; Liao J.; Xue W.; Wang L.; Chen D.; Gu L.; Xu J.; Ding N.; Wang X.; He C.; Xu S.; Liang Y.; Fang J.; Xu Y.; Zheng W.; Xu J.; Zheng Z.; Wei W.; Ji X.; Zhang H.; Chen B.; Li K.; Huang X.; Chen W.; Yang G.,8713118400; 57677232500; 57226077905; 35222779200; 57157623300; 57215331696; 57215336619; 57225416682; 56341608700; 57191203308; 55839534200; 57190573387; 56670316100; 54394647300; 57188811455; 57190225828; 57190091739; 57192199364; 57201534601; 57211165737; 57190848579; 55487992600; 8905764300; 37004257700; 8684892000,Refactoring and Optimizing the Community Atmosphere Model (CAM) on the Sunway TaihuLight Supercomputer,2016,"International Conference for High Performance Computing, Networking, Storage and Analysis, SC",0,,7877161,969,980,11,33,10.1109/SC.2016.82,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85017257820&doi=10.1109%2fSC.2016.82&partnerID=40&md5=65b42d5d2e3cc21733c20f0ef6f8ba8b,"This paper reports our efforts on refactoring and optimizing the Community Atmosphere Model (CAM) on the Sunway TaihuLight supercomputer, which uses a many-core processor that consists of management processing elements (MPEs) and clusters of computing processing elements (CPEs). To map the large code base of CAM to the millions of cores on the Sunway system, we take OpenACC-based refactoring as the major approach, and apply source-to-source translator tools to exploit the most suitable parallelism for the CPE cluster, and to fit the intermediate variable into the limited on-chip fast buffer. For individual kernels, when comparing the original ported version using only MPEs and the refactored version using both the MPE and CPE clusters, we achieve up to 22× speedup for the compute-intensive kernels. For the 25km resolution CAM global model, we manage to scale to 24,000 MPEs, and 1,536,000 CPEs, and achieve a simulation speed of 2.81 model years per day. © 2016 IEEE.",Conference paper,Final,Scopus
Kaur J.; Singh S.,58330402600; 7407874009,Neural network based refactoring area identification in Software System with object oriented metrics,2016,Indian Journal of Science and Technology,9,10,85110,,,,6,10.17485/ijst/2016/v9i10/85110,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962788202&doi=10.17485%2fijst%2f2016%2fv9i10%2f85110&partnerID=40&md5=00d51c67827dfc36b3273ff8b1aca0f6,"Objectives of the Study (a) To study previously designed models for identification of refactoring area in Object Oriented Software Systems. (b) To design a general framework or model that helps to easily identify the software code smells for a good quality of coding. (c) To identify the bad smells in the code with a design of neural network based model with the help of object-oriented metrics and further to predict the performance of the proposed model using various evaluation parameters of confusion matrix. Analysis/Methods: In this study, two different versions of Rhino (1.7r1 and 1.7r2) were taken as dataset. Object-Oriented metrics were taken as input data and the probability factor (occurrence or non-occurrence of a bad smell as output. Presence of a bad smell was considered as 1 and 0 means absence of bad smell. If there was at least one bad smell present in the code in a class, it was marked as smelly class. The tool used to extract the databases for collected object-oriented metrics and bad smells of these Rhino versions is PTIDEJ. Further, the data was tested on neural networks for different epochs to predict their performance. Findings: a) Bad Smell Analysis: Twelve design smells were considered to detect the presence of bad smell in code. If there was at least one bad smell present in the code in a class, it was marked as smelly class. b) Neural Network Model Table: Weight and bias factor for various predictors were calculated for different epochs (500, 1000, and 2000). It shows the weights assigned from input layer to hidden layer and from hidden layer to output neurons layer. After the training, the weights were tested on various datasets. C) Performance Tables and Graphs: In this, the Neural network proposed model was trained using different number of epochs to examine if the number of epochs used in training has any impact on the results or not. Further, the results for the accuracy of these models were shown. Novelty/Improvement: When the data was highly trained then the results were better. When the data was trained with 500 epochs, it was suitable for only with-in company projects but when the data was more trained than the model was also appropriate for cross projects. It was seen that when the data was trained with 1000 and 2000 epochs, the results of the proposed model were improved.",Article,Final,Scopus
Hamioud S.; Atil F.,56731108700; 14824607700,Model-driven java code refactoring,2015,Computer Science and Information Systems,12,2,,375,403,28,1,10.2298/CSIS141025015H,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84937557103&doi=10.2298%2fCSIS141025015H&partnerID=40&md5=8b7c02a0cbc690c0682d88302ff33627,"Refactoring is an important technique for restructuring code to improve its design and increase programmer productivity and code reuse. Performing refactorings manually, however, is tedious, time consuming and error-prone. Thus, providing an automated support for them is necessary. Unfortunately even in our days, such automation is still not easily achieved and requires formal specifications of the refactoring process. Moreover, extensibility and tool develo-pment automation are factors that should be taken into consideration when design-ing and implementing automated refactorings. In this paper, we introduce a model-driven approach where refactoring features, such as code representation, analysis and transformation adopt models as first-class artifacts. We aim at exploring the value of model transformation and code generation when formaliz-ing refactorings and developing tool support. The presented approach is applied to the refactoring of Java code using a prototypical implementation based on the Eclipse Modeling Framework, a language workbench, a Java metamodel and a set of OMG standards. © 2015 ComSIS Consortium. All rights reserved.",Article,Final,Scopus
Zhao S.; Bian Y.; Zhang S.,56739571100; 33467456300; 56739494500,A review on refactoring sequential program to parallel code in multicore era,2015,"Proceedings of 2015 International Conference on Intelligent Computing and Internet of Things, ICIT 2015",,,7111558,151,154,3,2,10.1109/ICAIOT.2015.7111558,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84938071157&doi=10.1109%2fICAIOT.2015.7111558&partnerID=40&md5=d0ad4d9c691b96b59e9dd37f0f1a831a,"Nowdays it is inevitable to face the emergence of multicore processors and parallel platforms. In the multicore time, sequential programs need to be refactored for parallelism. Refactoring is a process of adjusting the code structure of a program keeping its internal function. However, refactoring sequential code to concurrent program is not trivial. In this paper, a survey of the current literature that frequently reported parallel refactoring are carried out. It is important for programmers or computer researchers to exploit multicore platform in order to get better understand and perform refactoring in parallel. This review can help the research community to know the different directions about development of parallel refactoring in order to improve the quality of software. © 2015 IEEE.",Conference paper,Final,Scopus
Winetzhammer S.; Westfechtel B.,49965006900; 6603890434,Model refactorings for and with graph transformation rules,2015,Communications in Computer and Information Science,555,,,331,348,17,1,10.1007/978-3-319-25579-8_19,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84950974520&doi=10.1007%2f978-3-319-25579-8_19&partnerID=40&md5=fe1b62c907791f0e58fba3f28b172190,"Refactoring denotes the activity of improving the structure of software by applying a series of transformations without affecting its externally observable behavior. Refactoring has been applied extensively at the source code level. In the context of model-driven software engineering, refactoring has to be applied consistently to both structural and behavioral models. In this paper, we present tool support for model refactoring in ModGraph, a tool which employs Ecore class diagrams for structural modeling and graph transformation rules for declarative behavioral modeling. A refactoring transformation restructures the structural model - an Ecore class diagram - and propagates the changes consistently to the behavioral model - a set of graph transformation rules. Since the refactoring transformations are implemented with graph transformation rules, ModGraph supports model refactoring both for and with graph transformation rules. © Springer International Publishing Switzerland 2015.",Conference paper,Final,Scopus
Al Dallal J.,6508260263,Evaluating quality of primary studies on determining object-oriented code refactoring candidates,2015,ACM International Conference Proceeding Series,24-26-September-2015,,a25,,,,0,10.1145/2832987.2833026,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84988911087&doi=10.1145%2f2832987.2833026&partnerID=40&md5=a94ae9a7634330899d7125a79bde53ff,"Refactoring is a maintenance task that aims at improving the quality of a software source code by restructuring it without altering its external behavior. Identifying refactoring opportunities by manually inspecting and analyzing the source code of the system under consideration is a time consuming and costly process. Researchers, in this area, typically introduce fully or semi-automated techniques to determine or predict refactoring candidates and they report related evaluation studies. The quality of the performed studies has a great impact on the accuracy of the obtained results. In this paper, we demonstrate an application for a proposed framework that evaluates published primary studies (PSs) on refactoring prediction/identification techniques. The framework is applied on 47 selected PSs to evaluate the quality of the studies based on their design, conduct, analysis, and conclusion. We used the results to comment on the weaknesses of the existing PSs and the issues that have to be considered with more attention in future studies. Copyright 2015 ACM.",Conference paper,Final,Scopus
Park J.-J.; Hong J.-E.; Lee S.-H.,56413290200; 7404117852; 56152301200,Investigation for software power consumption of code refactoring techniques,2014,"Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE",2014-January,January,,717,722,5,27,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84938310823&partnerID=40&md5=feee1098c9ff6e8071e74300f0701a0d,"Code refactoring technique focuses on enhancing the maintainability of software to extend its lifetime. However, there are other efforts to improve software qualities like performance or reliability as well as maintainability by using code refactoring techniques. Recently, as low-power software has become one of the critical issues in mobile environments, developing energyefficient software through code refactoring becomes an important one. This paper aims to investigate whether the existing refactoring techniques can support energy-efficient software generation or not. The refactored codes generated by the existing techniques can consume more power than original codes because they did not consider the power consumption in their refactoring processes. This paper analyzes the power consumption to investigate the energy efficiency of M. Fowler's refactoring techniques. Our analysis result can provide useful information about energy-efficient refactoring techniques to software engineers, and support the development of software that has high maintainability and good energy efficiency. Copyright © 2014 by Knowledge Systems Institute Graduate School.",Conference paper,Final,Scopus
Fernández-Ropero M.; Pérez-Castillo R.; Piattini M.G.,54683892800; 34977424500; 7004203473,IBUPROFEN: Business process model refactoring,2013,Uncovering Essential Software Artifacts through Business Process Archeology,,,,64,87,23,0,10.4018/978-1-4666-4667-4.ch003,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84956844173&doi=10.4018%2f978-1-4666-4667-4.ch003&partnerID=40&md5=045858b61f005bdb04f714fa6287d78a,"Organizations are increasingly choosing process-oriented organizational designs as a source to achieve competitive advantages. Business process models represent the sequence of tasks that an organization carries out. However, organizations must cope with quality problems of business process models (e.g., lack of understandability, maintainability, reusability, etc.). These problems are compounded when business process models are mined by reverse engineering (e.g., from information systems that support them), owing to the semantics loss that it involves. Refactoring techniques are commonly used to reduce these problems through changing their internal structure without altering their external behavior. Although several refactoring operators exist in the literature, there are no refactoring techniques especially developed for models obtained by reverse engineering and their special features. For this reason, this chapter presents IBUPROFEN, a refactoring technique (and supporting tool) for business process models obtained by reverse engineering. Moreover, a case study is conducted to determine how the refactoring operator's order influences the understanding and modification of business process models. The case study reveals there is a clear influence in these quality features in terms of the size and separability of the models under study, and therefore, refactoring operators do not satisfy the commutative property among them. © 2014, IGI Global. All right reserved.",Book chapter,Final,Scopus
Mkaouer W.; Kessentini M.; Bechikh S.; Cinnéide M.Ó.; Deb K.,55904259300; 25653537200; 25924742700; 55890614500; 7006019904,Software Refactoring under uncertainty: A robust multi-objective approach,2014,GECCO 2014 - Companion Publication of the 2014 Genetic and Evolutionary Computation Conference,,,,187,188,1,10,10.1145/2598394.2598499,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84905668396&doi=10.1145%2f2598394.2598499&partnerID=40&md5=f36053a78f37aa0fec7ee04608a76df7,"Refactoring large systems involves several sources of uncertainty related to the severity levels of code smells to be corrected and the importance of the classes in which the smells are located. Due to the dynamic nature of software development, these values cannot be accurately determined in practice, leading to refactoring sequences that lack robustness. To address this problem, we introduced a multiobjective robust model, based on NSGA-II, for the software refactoring problem that tries to find the best trade-off between quality and robustness.",Conference paper,Final,Scopus
Ayshwaryalakshmi S.; Mary S.A.S.A.; Vadivu S.S.,56046211400; 56458090100; 56046708600,Agent based tool for topologically sorting badsmells and refactoring by analyzing complexities in source code,2013,"2013 4th International Conference on Computing, Communications and Networking Technologies, ICCCNT 2013",,,6726851,,,,1,10.1109/ICCCNT.2013.6726851,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84894444585&doi=10.1109%2fICCCNT.2013.6726851&partnerID=40&md5=606ee0079b928cde248476fe688ec458,"Code smells are smells found in source code. As the source code becomes larger and larger we find bad smells in the source code. These bad smells are removed using Refactoring. Hence experts say the method of removing bad smells without changing the quality of code is called as Refactoring[1]. But this Refactoring if not done properly is risky, and can take time (i.e.) might be days or weeks. Hence here we provide a technique to arrange these Bad smells analyze the complexities found in the source code and then Refactor them. These Bad smell detection and scheduling has been done manually or semi automatically. This paper provides a method of automatically detecting theses Bad smells. This Automatic detection of Bad smells are done with the help of Java Agent DEvelopment.(JADE) © 2013 IEEE.",Conference paper,Final,Scopus
Bosch M.; Genevès P.; Layaïda N.,56405171100; 8451752000; 6507942681,Automated refactoring for size reduction of CSS style sheets,2014,DocEng 2014 - Proceedings of the 2014 ACM Symposium on Document Engineering,,,,13,16,3,13,10.1145/2644866.2644885,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908636719&doi=10.1145%2f2644866.2644885&partnerID=40&md5=808d7f7549f15dc279c894de34072b12,"Cascading Style Sheets (CSS) is a standard language for stylizing and formatting web documents. Its role in web user experience becomes increasingly important. However, CSS files tend to be designed from a result-driven point of view, without much attention devoted to the CSS file structure as long as it produces the desired results. Furthermore, the rendering intended in the browser is often checked and debugged with a document instance. Style sheets normally apply to a set of documents, therefore modifications added while focusing on a particular instance might affect other documents of the set. We present a first prototype of static CSS semantical analyzer and optimizer that is capable of automatically detecting and removing redundant property declarations and rules. We build on earlier work on tree logics to locate redundancies due to the semantics of selectors and properties. Existing purely syntactic CSS optimizers might be used in conjunction with our tool, for performing complementary (and orthogonal) size reduction, toward the common goal of providing smaller and cleaner CSS files. © 2014 ACM.",Conference paper,Final,Scopus
Reimann J.; Seifert M.; Aßmann U.,57213087845; 35105937200; 6603009666,On the reuse and recommendation of model refactoring specifications,2013,Software and Systems Modeling,12,3,,579,596,17,16,10.1007/s10270-012-0243-2,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84879780913&doi=10.1007%2fs10270-012-0243-2&partnerID=40&md5=793557bbf4013fba584fed398bb820f8,"Refactorings can be used to improve the structure of software artefacts while preserving the semantics of the encapsulated information. Various types of refactorings have been proposed and implemented for programming languages (e.g., Java or C#). With the advent of (MDSD), a wealth of modelling languages rises and the need for restructuring models similar to programs has emerged. Since parts of these modelling languages are often very similar, we consider it beneficial to reuse the core transformation steps of refactorings across languages. In this sense, reusing the abstract transformation steps and the abstract participating elements suggests itself. Previous work in this field indicates that refactorings can be specified generically to foster their reuse. However, existing approaches can handle certain types of modelling languages only and solely reuse refactorings once per language. In this paper, a novel approach based on role models to specify generic refactorings is presented. Role models are suitable for this problem since they support declaration of roles which have to be played in a certain context. Assigned to generic refactoring, contexts are different refactorings and roles are the participating elements. We discuss how this resolves the limitations of previous works, as well as how specific refactorings can be defined as extensions to generic ones. The approach was implemented in our tool Refactory based on the (EMF) and evaluated using multiple modelling languages and refactorings. In addition, this paper investigates on the recommendation of refactoring specifications. This is motivated by the fact that language designers have many possibilities to enable refactorings in their modelling languages with regard to the language structures. To overcome this problem and to support language designers in deciding which refactorings to enable, we propose a solution and a prototypical implementation. © 2012 Springer-Verlag.",Article,Final,Scopus
Silva D.; Terra R.; Valente M.T.,56712316800; 36865399300; 55437198000,Recommending automated extract method refactorings,2014,"22nd International Conference on Program Comprehension, ICPC 2014 - Proceedings",,,,146,156,10,56,10.1145/2597008.2597141,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942510325&doi=10.1145%2f2597008.2597141&partnerID=40&md5=c867427cb0634c36940102b17c000499,"Extract Method is a key refactoring for improving program comprehension. However, recent empirical research shows that refactoring tools designed to automate Extract Methods are often underused. To tackle this issue, we propose a novel approach to identify and rank Extract Method refactoring opportunities that are directly automated by IDE-based refactoring tools. Our approach aims to recommend new methods that hide structural dependencies that are rarely used by the remaining statements in the original method. We conducted an exploratory study to experiment and define the best strategies to compute the dependencies and the similarity measures used by the proposed approach. We also evaluated our approach in a sample of 81 extract method opportunities generated for JUnit and JHotDraw, achieving a precision of 48% (JUnit) and 38% (JHotDraw). Copyright © 2014 ACM.",Conference paper,Final,Scopus
Bavota G.; De Lucia A.; Marcus A.; Oliveto R.,57220148228; 7003641564; 9239576200; 15136561900,Recommending refactoring operations in large software systems,2014,Recommendation Systems in Software Engineering,,,,387,419,32,45,10.1007/978-3-642-45135-5_15,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84937451212&doi=10.1007%2f978-3-642-45135-5_15&partnerID=40&md5=508f037bc7d53aa6393c39b91bf22cc7,"During its lifecycle, the internal structure of a software system undergoes continuous modifications. These changes push away the source code from its original design, often reducing its quality. In such cases, refactoring techniques can be applied to improve the readability and reducing the complexity of source code, to improve the architecture and provide for better software extensibility. Despite its advantages, performing refactoring in large and nontrivial software systems might be very challenging. Thus, a lot of effort has been devoted to the definition of automatic or semi-automatic approaches to support developer during software refactoring. Many of the proposed techniques are for recommending refactoring operations. In this chapter, we present guidelines on how to build such recommendation systems and how to evaluate them. We also highlight some of the challenges that exist in the field, pointing toward future research directions. © Springer-Verlag Berlin Heidelberg 2014.",Book chapter,Final,Scopus
Mkaouer W.; Kessentini M.; Bechikh S.; Deb K.; Cinnéide M.Ó.,55904259300; 25653537200; 25924742700; 7006019904; 55890614500,High dimensional search-based software engineering: Finding tradeoffs among 15 objectives for automating software refactoring using NSGA-III,2014,GECCO 2014 - Proceedings of the 2014 Genetic and Evolutionary Computation Conference,,,,1263,1270,7,81,10.1145/2576768.2598366,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84905675485&doi=10.1145%2f2576768.2598366&partnerID=40&md5=cb79d8f5f3ccd61a54f544bc6aad4495,"There is a growing need for scalable search-based software engineering approaches that address software engineering problems where a large number of objectives are to be optimized. Software refactoring is one of these problems where a refactoring sequence is sought that optimizes several software metrics. Most of the existing refactoring work uses a large set of quality metrics to evaluate the software design after applying refactoring operations, but current search-based software engineering approaches are limited to using a maximum of five metrics. We propose for the first time a scalable search-based software engineering approach based on a newly proposed evolutionary optimization method NSGA-III where there are 15 different objectives to be optimized. In our approach, automated refactoring solutions are evaluated using a set of 15 distinct quality metrics. We evaluated this approach on seven large open source systems and found that, on average, more than 92% of code smells were corrected. Statistical analysis of our experiments over 31 runs shows that NSGA-III performed significantly better than two other many-objective techniques (IBEA and MOEA/D), a multi-objective algorithm (NSGA-II) and two mono-objective approaches, hence demonstrating that our NSGA-III approach represents the new state of the art in fully-automated refactoring. © 2014 ACM.",Conference paper,Final,Scopus
Meng F.,55426663000,Identifying refactoring opportunities from code clones based on SOM clustering,2014,"ICIC Express Letters, Part B: Applications",5,4,,1087,1092,5,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84903466057&partnerID=40&md5=4ed44b73fe545fa46f49606dcc8fcf42,"Code clones are regarded as typical bad smell because they usually make software maintenance more difficult and may even propagate bugs. Code Clones almost exist in all kinds of source programs of any nontrivial software. In order to reduce the harmful impacts on software quality caused by code clones, some clones satisfying certain conditions should be removed by refactoring. However, for subsequent refactoring, those refactor-able code clones should be identified first. In this paper, a method based on SOM (Self Organizing Map) clustering is proposed to identify code clones which can satisfy certain conditions for refactoring. The method has 5 basic steps: code clone detection, refactoring sample selection, data preprocessing, SOM modeling and refactoring opportunity identification. The results of related experiments on 6 open source software show that the method has better precision than the method using single metric, and has better validity than the method using multiple metrics. © 2014 ICIC International.",Article,Final,Scopus
Ebanhesaten K.; Fussl F.-F.; Streitferdt D.,55884010700; 55885137700; 24470533800,Refactoring and automated testing of distributed ERP systems,2013,Proceedings - International Computer Software and Applications Conference,,,6605871,681,684,3,0,10.1109/COMPSACW.2013.105,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885651253&doi=10.1109%2fCOMPSACW.2013.105&partnerID=40&md5=b06793916917dae9b0af9d68530a01a0,"Software development offers various techniques to improve the quality of code. One possibility is Refactoring. It goals are restructuring software code without changing its behavior and improving systems design to make it more extensible and reusable. This can be achieved by very simple renaming of variables and classes up to complex restructuring activities, such as the replacement of inheritance by compositions. Especially large software systems e.g. ERP systems (particular SAP) are developing into heterogeneous application environment over time. For this reason they have to be able to respond to new challenges at the system operating departments continuously, which requires a high degree of extensibility and reusability. This paper summarizes a practical example to show the complexity of SAP FICO systems. It illustrates how the applications source code can be prepared to be more extensible by using specific Refactoring. Moreover, the relationship between Refactoring in ABAP and automated testing of changes in SAP are shown. © 2013 IEEE.",Conference paper,Final,Scopus
Wongpiang R.; Muenchaisri P.,56266623000; 6505797100,Comparing heuristic search methods for selecting sequence of refactoring techniques usage for code changing,2014,Lecture Notes in Engineering and Computer Science,2209,January,,590,595,5,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84938262783&partnerID=40&md5=1626ebffd5c2041fcaff52e9a76238c5,"Refactoring is the process of changing the internal structures, that preserves external behaviors of software. To improve software maintainability, we can apply several refactoring techniques to source code; applying different sequence of refactoring techniques to different parts of the source code results in different code changes and different level of software maintainability. This research uses Heuristic Search methods to find a sequence of refactoring techniques usage for code changing from a search space. Each Heuristic Search method has different characteristics and algorithm to reach an optimal result in solving the problem. Heuristic Search methods including Greedy Algorithm, Breadth First Search, Hill Climbing and A? (A Star) are used to search for sequence of refactoring techniques usage from search space and compare the effort and result of the search methods. The purpose of the research is to find the most appropriate Heuristic Search method for searching sequence of refactoring techniques usage with maximum software maintainability and least searching time. The researcher evaluates each Heuristic Search method with source code containing Long Method, Large Class and Feature Envy bad smell. The result shows that Greedy Algorithm shows the best results with maximum software maintainability and the least searching time.",Conference paper,Final,Scopus
Mondal M.; Roy C.K.; Schneider K.A.,7005459894; 36176304400; 7402470734,Automatic identification of important clones for refactoring and tracking,2014,"Proceedings - 2014 14th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2014",,,6975631,11,20,9,30,10.1109/SCAM.2014.11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924918497&doi=10.1109%2fSCAM.2014.11&partnerID=40&md5=13e0aef9cc91eef14595b2d03aca3a2e,"Code cloning is a controversial software engineering practice due to contradictory claims regarding its impacts on software evolution and maintenance. While a number of studies identify some positive aspects of code clones, there is strong empirical evidence of some negative impacts of clones too. Focusing on the issues related to clones researchers suggest to manage code clones through detection, refactoring, and tracking. However, all clones in a software system are not suitable for refactoring or tracking. Thus, it is important to identify which clones we should consider for refactoring and which clones should be considered for tracking. In this research work we apply the concept of evolutionary coupling to identify clones that are important for refactoring or tracking. By mining software evolution history, we determine and analyze constrained association rules of clone fragments that evolved following a particular change pattern called Similarity Preserving Change Pattern and are important from the perspective of refactoring and tracking. According to our investigation with rigorous manual analysis on thousands of revisions of six diverse subject systems covering two programming languages, overall 13.20% of all clones in a software system are important candidates for refactoring, and overall 10.27% of all clones are important candidates for tracking. Our implemented system can automatically identify these important candidates and thus, can help us in better maintenance of code clones in terms of refactoring and tracking. © 2014 IEEE.",Conference paper,Final,Scopus
Amal B.; Kessentini M.; Bechikh S.; Dea J.; Said L.B.,56310669500; 25653537200; 25924742700; 56310645900; 25925454000,On the use of machine learning and search-based software engineering for ill-defined fitness function: A case study on software refactoring,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8636 LNCS,,,31,45,14,30,10.1007/978-3-319-09940-8_3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84958543478&doi=10.1007%2f978-3-319-09940-8_3&partnerID=40&md5=c1149130a3b170bc01bb57adc55db78b,"The most challenging step when adapting a search-based technique for a software engineering problem is the definition of the fitness function. For several software engineering problems, a fitness function is ill-defined, subjective, or difficult to quantify. For example, the evaluation of a software design is subjective. This paper introduces the use of a neural network-based fitness function for the problem of software refactoring. The software engineers evaluate manually the suggested refactoring solutions by a Genetic Algorithm (GA) for few iterations then an Artificial Neural Network (ANN) uses these training examples to evaluate the refactoring solutions for the remaining iterations. We evaluate the efficiency of our approach using six different open-source systems through an empirical study and compare the performance of our technique with several existing refactoring studies. © 2014 Springer International Publishing Switzerland.",Conference paper,Final,Scopus
Lopez C.; Alonso J.M.; Marticorena R.; Maudes J.M.,57203418592; 26660718600; 25925158200; 23091296800,Design of e-activities for the learning of code refactoring tasks,2014,"2014 International Symposium on Computers in Education, SIIE 2014",,,7017701,35,40,5,10,10.1109/SIIE.2014.7017701,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84988290605&doi=10.1109%2fSIIE.2014.7017701&partnerID=40&md5=f085938c6a677391f0de881439515ec4,"In this work a number of online e-activities are presented for the process of teaching and learning of code refactoring tasks. The pedagogical design of the set of activities is progressive, according to the levels of knowledge of Bloom's taxonomy. First, activities to help knowing and understanding a concept are proposed, then activities to apply refactorings in the context of small software implementations, and last, the analysis and synthesis of the use of refactorings in software maintenance tasks in open source projects. The resources used to solve the activities are related to those the student may find during their professional career, if oriented towards software development: integrated development environments, task tracking systems and revision control systems. It is also described the use of these e-activities in the context of the course Software Engineering of the Bachelor's Degree in Computer Science at the University of Burgos, and the consequences of the experience are analyzed. © 2014 IEEE.",Conference paper,Final,Scopus
Concas G.; Monni C.; Orrù M.; Ortu M.; Tonelli R.,57105938400; 33568075100; 55982780800; 56313321800; 7004058057,Refactoring clustering in Java software networks,2014,Lecture Notes in Business Information Processing,199,,,121,135,14,0,10.1007/978-3-319-14358-3_11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84917737037&doi=10.1007%2f978-3-319-14358-3_11&partnerID=40&md5=82305946e7e610863a3831c5070c911a,"We present a study on the refactoring activities performed during the evolution of 7 popular Java open source software systems, using a complex network approach. We find that classes affected by refactorings are more likely to be interlinked than others, forming connected subgraphs. Our results show that in a software network, classes linked to refactored classes are likely to be refactored themselves. This result is meaningful because knowing how refactored classes are arranged inside a network could be useful to support developers in maintenance and refactoring activities. © Springer International Publishing Switzerland 2014.",Article,Final,Scopus
Shin W.-C.; Rho J.,7202123698; 13405799500,Implementation of software refactoring operation using a code model,2014,International Journal of Software Engineering and its Applications,8,6,,17,30,13,2,10.14257/ijseia.2014.8.6.02,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902601972&doi=10.14257%2fijseia.2014.8.6.02&partnerID=40&md5=7e7983f996f3a659845bf67131fed08c,"Enhancing software maintenance productivity is very important in the modern information society, where demand for software surges. To enhance productivity, active tool support is necessary. Especially, a refactoring tool that can alter the internal structure of software to more easily understandable and modifiable structure hugely affects software maintenance productivity. This paper proposes a code model to support software maintenance tool developers to easily access and handle software source codes. Also, this paper shows the implementation method of software refactoring operation using the proposed code model. © 2014 SERSC.",Article,Final,Scopus
Winetzhammer S.; Westfechtel B.,49965006900; 6603890434,Propagating model refactorings to graph transformation rules,2014,ICSOFT-PT 2014 - Proceedings of the 9th International Conference on Software Paradigm Trends,,,,17,28,11,2,10.5220/0005098900170028,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908894846&doi=10.5220%2f0005098900170028&partnerID=40&md5=44612377f95ad5dc44c3d7e873159073,"Model-driven software engineering reduces the effort of developing software by replacing low-level programming with the construction of high-level executable models. Refactoring improves the structure of software artifacts without changing external behavior. Originally, refactoring was developed for and applied to (objectoriented) programs. In the context of model-driven software engineering, refactoring has to be applied to both structural and behavioral models. In this paper, we present tool support for model refactoring in ModGraph, a tool which employs Ecore class diagrams for structural modeling and graph transformation rules for behavioral modeling. In particular, we focus on the propagation of refactorings of the structural model into the behavioral model. Copyright © 2014 SCITEPRESS - Science and Technology Publications.",Conference paper,Final,Scopus
Parreira Jr. P.A.; Viana M.C.; Durelli R.S.; De Camargo V.V.; Costa H.A.X.; Penteado R.A.D.,35273395300; 55350300800; 36184908100; 25654526700; 26031311400; 24436870900,Concern-based refactorings supported by class models to reengineer object-oriented software into aspect-oriented ones,2013,ICEIS 2013 - Proceedings of the 15th International Conference on Enterprise Information Systems,2,,,46,57,11,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84887691333&partnerID=40&md5=9badfc50e4b286061ca3bcdcecd90c8b,"Reengineering Object-Oriented Software (OO) into Aspect-Oriented Software (AO) is a challenging task, mainly when it is done by means of refactorings in the code-level. The reason for it is that direct transformations from OO code to AO one involve several design decisions due to syntactic and semantic differences of both paradigms. To make this task more controlled and systematic, we can make use of concern-based refactorings supported by models. This type of refactorings concentrates on transforming broader scenarios into a set of context-dependent scenarios, rather than specific ones, as in code-level refactorings. In this paper we propose a set of concern-based refactorings that allows design decisions to be made during the reengineering process, improving the quality of the final models. Two of them are presented in more details in this paper. An example is presented to assess the applicability of the proposed refactorings. Moreover, we also present a case study, in which AO class models created based on the refactorings are compared with AO class models obtained without the aid of these refactorings. The data obtained in this case study indicated to us that the use of the proposed refactorings can improve the efficacy and productivity of a maintenance group during the process of software reengineering.",Conference paper,Final,Scopus
Schmidt M.; Wider A.; Scheidgen M.; Fischer J.; Von Klinski S.,57199866300; 35319130900; 55888332900; 57013968800; 6505927527,Refactorings in language development with asymmetric bidirectional model transformations,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),7916 LNCS,,,222,238,16,4,10.1007/978-3-642-38911-5_13,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885802836&doi=10.1007%2f978-3-642-38911-5_13&partnerID=40&md5=e11820ec5499e68c9e5a43da85ca03c1,"Software language descriptions comprise several heterogeneous interdependent artifacts that cover different aspects of languages (abstract syntax, notation and semantics). The dependencies between those artifacts demand the simultaneous adaptation of all artifacts when the language is changed. Changes to a language that do not change semantics are referred to as refactorings. This class of changes can be handled automatically by applying predefined types of refactorings. Refactorings are therefore considered a valuable tool for evolving a language. We present a model transformation based approach for the refactoring of software language descriptions. We use asymmetric bidirectional model transformations to synchronize the various artifacts of language descriptions with a refactoring model that contains all elements that are changed in a particular refactoring. This allows for automatic, type-safe refactorings that also includes the language tooling. We apply this approach to an Ecore, Xtext, Xtend based language description and describe the implementation of a non-trivial refactoring. © 2013 Springer-Verlag.",Conference paper,Final,Scopus
Mahouachi R.; Kessentini M.; Cinnéide M.Ó.,55154472800; 25653537200; 55890614500,Search-based refactoring detection,2013,GECCO 2013 - Proceedings of the 2013 Genetic and Evolutionary Computation Conference Companion,,,,205,206,1,9,10.1145/2464576.2464680,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84882358048&doi=10.1145%2f2464576.2464680&partnerID=40&md5=f6cd3479b84e40349cf3be81e6ac7463,"We propose an approach to automate the detection of source code refactoring using structural information. Our approach takes as input a list of possible refactorings, a set of structural metrics and the initial and revised versions of the source code. It generates as output a sequence of detected changes in terms of refactorings. In this case, a solution is defined as the sequence of refactoring operations that minimizes the metrics variation between the revised version of the software and the version yielded by the application of the refactoring sequence to the initial version of the software. We use and adapt global and local heuristic search algorithms to explore the space of possible solutions.",Conference paper,Final,Scopus
Kallen M.; Holmgren S.; Hvannberg E.P.,57209429760; 7007059643; 6506621646,Impact of code refactoring using object-oriented methodology on a scientific computing application,2014,"Proceedings - 2014 14th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2014",,,6975646,125,134,9,14,10.1109/SCAM.2014.21,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924905235&doi=10.1109%2fSCAM.2014.21&partnerID=40&md5=52a887d8ecdf74d2cd5cd50cd90528fb,"Methods and tools for refactoring of software have been extensively studied during the last decades, and we argue that there is now a need for additional studies of the effects of refactoring on code quality and external code attributes such as computational performance. To study these effects, we have refactored the central parts of a code base developed in academia for a class of computationally demanding scientific computing problems. We made design choices on the basis of the SOLID principles and we used object-oriented techniques, such as the Gang of Four patterns, in the implementation. In this paper, we discuss the effect on maintainability qualitatively and also analyze it quantitatively using a set of software metrics extending the Chidamber-Kemerer suite. Not surprisingly, we find that maintainability has increased as an effect of the refactoring. We also study performance and find that dynamic binding, which inhibits in lining by the compiler, in the most frequently executed parts of the code makes the execution times increase by over 700%. By exploiting static polymorphism, we have been able able to reduce the relative increase in execution times to less than 100%. We argue that the code version implementing static polymorphism is less maintainable than the one using dynamic polymorphism, although both versions are considerably more maintainable than the original code. © 2014 IEEE.",Conference paper,Final,Scopus
Cheng Y.C.; Jwo J.-S.; Tsai C.-T.,55487650500; 7003386599; 7404968387,A leading indicator of post-release defect density in refactoring-based software maintenance- A case study,2015,Frontiers in Artificial Intelligence and Applications,274,,,1815,1821,6,0,10.3233/978-1-61499-484-8-1815,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84926433472&doi=10.3233%2f978-1-61499-484-8-1815&partnerID=40&md5=c6ed98b0a8df0cfbc4c3c5294866a386,"We look to create a leading indicator to relate, between two consecutive releases of a software product, the changes in post-release defect density to the changes of the internal factors identified as interrelated to refactoring. In the case study that involves a maintenance phase to bring the post-release defect densities of two suites of tools down to within the organization's upper limit, the proposed leading indicator correctly generated the desired negative correlation with the trend of changes in post-release defect density. © 2015 The authors and IOS Press. All rights reserved.",Conference paper,Final,Scopus
Liu H.; Guo X.; Shao W.,56862404100; 55811839400; 55178726400,Monitor-based instant software refactoring,2013,IEEE Transactions on Software Engineering,39,8,6568862,1112,1126,14,42,10.1109/TSE.2013.4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84881048345&doi=10.1109%2fTSE.2013.4&partnerID=40&md5=a23b18e13408ed8ba2db4e364e48bae6,"Software refactoring is an effective method for improvement of software quality while software external behavior remains unchanged. To facilitate software refactoring, a number of tools have been proposed for code smell detection and/or for automatic or semi-automatic refactoring. However, these tools are passive and human driven, thus making software refactoring dependent on developers' spontaneity. As a result, software engineers with little experience in software refactoring might miss a number of potential refactorings or may conduct refactorings later than expected. Few refactorings might result in poor software quality, and delayed refactorings may incur higher refactoring cost. To this end, we propose a monitor-based instant refactoring framework to drive inexperienced software engineers to conduct more refactorings promptly. Changes in the source code are instantly analyzed by a monitor running in the background. If these changes have the potential to introduce code smells, i.e., signs of potential problems in the code that might require refactorings, the monitor invokes corresponding smell detection tools and warns developers to resolve detected smells promptly. Feedback from developers, i.e., whether detected smells have been acknowledged and resolved, is consequently used to optimize smell detection algorithms. The proposed framework has been implemented, evaluated, and compared with the traditional human-driven refactoring tools. Evaluation results suggest that the proposed framework could drive inexperienced engineers to resolve more code smells (by an increase of 140 percent) promptly. The average lifespan of resolved smells was reduced by 92 percent. Results also suggest that the proposed framework could help developers to avoid similar code smells through timely warnings at the early stages of software development, thus reducing the total number of code smells by 51 percent. © 1976-2012 IEEE.",Article,Final,Scopus
Zanetti M.S.; Tessone C.J.; Scholtes I.; Schweitzer F.,55319930500; 6602779977; 19639626000; 7005771861,Automated software remodularization based on move refactoring a complex systems approach,2014,MODULARITY 2014 - Proceedings of the 13th International Conference on Modularity (Formerly AOSD),,,,73,83,10,20,10.1145/2577080.2577097,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84900026001&doi=10.1145%2f2577080.2577097&partnerID=40&md5=b6a1415821513986440ed3397426e57e,"Modular design is a desirable characteristic of complex software systems that can significantly improve their comprehensibility, maintainability and thus quality. While many software systems are initially created in a modular way, over time modularity typically degrades as components are reused outside the context where they were created. In this paper, we propose an automated strategy to re-modularize software based on move refactoring, i.e. moving classes between packages without changing any other aspect of the source code. Taking a complex systems perspective, our approach is based on complex networks theory applied to the dynamics of software modular structures and its relation to an n-state spin model known as the Potts Model. In our approach, nodes are probabilistically moved between modules with a probability that nonlinearly depends on the number and module membership of their adjacent neighbors, which are defined by the underlying network of software dependencies. To validate our method, we apply it to a dataset of 39 JAVA open source projects in order to optimize their modularity. Comparing the source code generated by the developers with the optimized code resulting from our approach, we find that modularity (i.e. quantified in terms of a standard measure from the study of complex networks) improves on average by 166 ± 77 percent. In order to facilitate the application of our method in practical studies, we provide a freely available ECLIPSE plug-in. Copyright © 2014 ACM.",Conference paper,Final,Scopus
Feldthaus A.; Møller A.,54395199400; 57195116933,Semi-automatic rename refactoring for javascript,2013,"Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA",,,,323,337,14,19,10.1145/2509136.2509520,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84888139847&doi=10.1145%2f2509136.2509520&partnerID=40&md5=51b1df238e31cb52f2826eceb7b5477b,"Modern IDEs support automated refactoring for many programming languages, but support for JavaScript is still primitive. To perform renaming, which is one of the fundamental refactorings, there is often no practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives have been developed, they are limited by wholeprogram assumptions and poor scalability. We propose a technique for semi-automatic refactoring for JavaScript, with a focus on renaming. Unlike traditional refactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction with the programmer.With this pragmatic approach, we can provide scalable and effective refactoring support for realworld code, including libraries and incomplete applications. Through a series of experiments that estimate how much manual effort our technique demands from the programmer, we show that our approach is a useful improvement compared to search-and-replace tools.",Conference paper,Final,Scopus
Gligoric M.; Schulte W.; Prasad C.; Van Velzen D.; Narasamdya I.; Livshits B.,26221765900; 7102823689; 56396187100; 56396385200; 13007832300; 12139816400,Automated migration of build scripts using dynamic analysis and search-based refactoring,2014,ACM SIGPLAN Notices,49,10,,599,616,17,17,10.1145/2660193.2660239,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84920864599&doi=10.1145%2f2660193.2660239&partnerID=40&md5=52e6a2b04fca6faddefedab84f1ae109,"The efficiency of a build system is an important factor for developer productivity. As a result, developer teams have been increasingly adopting new build systems that allow higher build parallelization. However, migrating the existing legacy build scripts to new build systems is a tedious and error-prone process. Unfortunately, there is insufficient support for automated migration of build scripts, making the migration more problematic. We propose the first dynamic approach for automated migration of build scripts to new build systems. Our approach works in two phases. First, from a set of execution traces, we synthesize build scripts that accurately capture the intent of the original build. The synthesized build scripts are typically long and hard to maintain. Second, we apply refactorings that raise the abstraction level of the synthesized scripts (e.g., introduce functions for similar fragments). As different refactoring sequences may lead to different build scripts, we use a search-based approach that explores various sequences to identify the best (e.g., shortest) build script. We optimize search-based refactoring with partial-order reduction to faster explore refactoring sequences. We implemented the proposed two-phase migration approach in a tool called Metamorphosis that has been recently used at Microsoft. Copyright © 2014 ACM.",Article,Final,Scopus
Raab F.; Wolff C.; Echtler F.,54791447800; 57203714801; 24821578300,RefactorPad: Editing source code on touchscreens,2013,EICS 2013 - Proceedings of the ACM SIGCHI Symposium on Engineering Interactive Computing Systems,,,,223,228,5,11,10.1145/2480296.2480317,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84880569464&doi=10.1145%2f2480296.2480317&partnerID=40&md5=60e38a2a39d93a321be8fa1686f66934,"Despite widespread use of touch-enabled devices, the field of software development has only slowly adopted new interaction methods for available tools. In this paper, we present our research on RefactorPad, a code editor for editing and restructuring source code on touchscreens. Since entering and modifying code with on-screen keyboards is time-consuming, we have developed a set of gestures that take program syntax into account and support common maintenance tasks on devices such as tablets. This work presents three main contributions: 1) a test setup that enables researchers and participants to collaboratively walk through code examples in real-time; 2) the results of a user study on editing source code with both finger and pen gestures; 3) a list of operations and some design guidelines for creators of code editors or software development environments who wish to optimize their tools for touchscreens. Copyright © 2013 ACM.",Conference paper,Final,Scopus
Gligoric M.; Schulte W.; Prasad C.; Van Velzen D.; Narasamdya I.; Livshits B.,26221765900; 7102823689; 56396187100; 56396385200; 13007832300; 12139816400,Automated migration of build scripts using dynamic analysis and search-based refactoring,2014,"Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA",,,,599,616,17,13,10.1145/2660193.2660239,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908283939&doi=10.1145%2f2660193.2660239&partnerID=40&md5=041abb513a5d68d649bc616ec96be96a,"The efficiency of a build system is an important factor for developer productivity. As a result, developer teams have been increasingly adopting new build systems that allow higher build parallelization. However, migrating the existing legacy build scripts to new build systems is a tedious and error-prone process. Unfortunately, there is insufficient support for automated migration of build scripts, making the migration more problematic. Copyright 2014 ACM.; We propose the first dynamic approach for automated migration of build scripts to new build systems. Our approach works in two phases. First, from a set of execution traces, we synthesize build scripts that accurately capture the intent of the original build. The synthesized build scripts are typically long and hard to maintain. Second, we apply refactorings that raise the abstraction level of the synthesized scripts (e.g., introduce functions for similar fragments). As different refactoring sequences may lead to different build scripts, we use a search-based approach that explores various sequences to identify the best (e.g., shortest) build script. We optimize search-based refactoring with partial-order reduction to faster explore refactoring sequences. We implemented the proposed two-phase migration approach in a tool called Metamorphosis that has been recently used at Microsoft.",Conference paper,Final,Scopus
Mandal M.; Roy C.K.; Schneider K.A.,56111903100; 36176304400; 7402470734,Automatic ranking of clones for refactoring through mining association rules,2014,"2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering, CSMR-WCRE 2014 - Proceedings",,,6747161,114,123,9,44,10.1109/CSMR-WCRE.2014.6747161,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84898404595&doi=10.1109%2fCSMR-WCRE.2014.6747161&partnerID=40&md5=8d265a0112b682f3dd87c634014a02a1,"In this paper, we present an in-depth empirical study on identifying clone fragments that can be important refactoring candidates. We mine association rules among clones in order to detect clone fragments that belong to the same clone class and have a tendency of changing together during software evolution. The idea is that if two or more clone fragments from the same class often change together (i.e., are likely to co-change) preserving their similarity, they might be important candidates for refactoring. Merging such clones into one (if possible) can potentially decrease future clone maintenance effort. We define a particular clone change pattern, the Similarity Preserving Change Pattern (SPCP), and consider the cloned fragments that changed according to this pattern (i.e., the SPCP clones) as important candidates for refactoring. For the purpose of our study, we implement a prototype tool called MARC that identifies SPCP clones and mines association rules among these. The rules as well as the SPCP clones are ranked for refactoring on the basis of their change-proneness. We applied MARC on thirteen subject systems and retrieved the refactoring candidates for three types of clones (Type 1, Type 2, and Type 3) separately. Our experimental results show that SPCP clones can be considered important candidates for refactoring. Clones that do not follow SPCP either evolve independently or are rarely changed. By considering SPCP clones for refactoring we not only can minimize refactoring effort considerably but also can reduce the possibility of delayed synchronizations among clones and thus, can minimize inconsistencies in software systems. © 2014 IEEE.",Conference paper,Final,Scopus
Laguna M.A.; Crespo Y.,7005147433; 22733838200,A systematic mapping study on software product line evolution: From legacy system reengineering to product line refactoring,2013,Science of Computer Programming,78,8,,1010,1034,24,89,10.1016/j.scico.2012.05.003,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84878225914&doi=10.1016%2fj.scico.2012.05.003&partnerID=40&md5=b8fba00f0623f75c93648c14304019ce,"Software product lines (SPLs) are used in industry to develop families of similar software systems. Legacy systems, either highly configurable or with a story of versions and local variations, are potential candidates for reconfiguration as SPLs using reengineering techniques. Existing SPLs can also be restructured using specific refactorings to improve their internal quality. Although many contributions (including industrial experiences) can be found in the literature, we lack a global vision covering the whole life cycle of an evolving product line. This study aims to survey existing research on the reengineering of legacy systems into SPLs and the refactoring of existing SPLs in order to identify proven approaches and pending challenges for future research in both subfields. We launched a systematic mapping study to find as much literature as possible, covering the diverse terms involved in the search string (restructuring, refactoring, reengineering, etc. always connected with SPLs) and filtering the papers using relevance criteria. The 74 papers selected were classified with respect to several dimensions: main focus, research and contribution type, academic or industrial validation if included, etc. We classified the research approaches and analyzed their feasibility for use in industry. The results of the study indicate that the initial works focused on the adaptation of generic reengineering processes to SPL extraction. Starting from that foundation, several trends have been detected in recent research: the integrated or guided reengineering of (typically object-oriented) legacy code and requirements; specific aspect-oriented or feature-oriented refactoring into SPLs, and more recently, refactoring for the evolution of existing product lines. A majority of papers include academic or industrial case studies, though only a few are based on quantitative data. The degree of maturity of both subfields is different: Industry examples for the reengineering of the legacy system subfield are abundant, although more evaluation research is needed to provide better evidence for adoption in industry. Product line evolution through refactoring is an emerging topic with some pending challenges. Although it has recently received some attention, the theoretical foundation is rather limited in this subfield and should be addressed in the near future. To sum up, the main contributions of this work are the classification of research approaches as well as the analysis of remaining challenges, open issues, and research opportunities. © 2012 Elsevier B.V. All rights reserved.",Conference paper,Final,Scopus
Arboleda H.; Paz A.; Royer J.-C.,37080075700; 55867922700; 7202753847,Component-based java legacy code refactoring,2013,Revista Facultad de Ingenieria,,68,,104,114,10,2,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84887139542&partnerID=40&md5=68d17b8e9e0b8d9bb2e133d5dc93119b,"Component-Based Software Engineering (CBSE) claims to improve software modularisation and to embed architectural concerns. Refactoring Java legacy code with CBSE in mind requires first assessing the compliance of legacy code with component programming principles. This paper presents a portfolio of rules to assess the compliance of Java legacy code with the Communication Integrity (CI) property, which is one of the major strengths of the CBSE approach. These rules are proposed with the objective of identifying implicit component types and thus provide a measure of the componentisation of an application. In order to help developers and legacy code maintainers when refactoring their applications, along with the rules, this work leads to define a set of refactoring actions. Additionally, the results of testing, comparing and analysing the outputs of refactoring several Java applications are also presented.",Article,Final,Scopus
Fanqi M.,55426663000,Using self organized mapping to seek refactorable code clone,2014,"Proceedings - 2014 4th International Conference on Communication Systems and Network Technologies, CSNT 2014",,,6821520,851,855,4,2,10.1109/CSNT.2014.177,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902589913&doi=10.1109%2fCSNT.2014.177&partnerID=40&md5=577e066a77a4f5deec895cdf866d0e6c,"Code reuse in the process of software development led to the generation of code clone. A large number of identical or similar code clones brought difficulties for the software maintenance. Sometimes bug may be introduced into software due to the inconsistent changes of code clones. In order to reduce the adverse impact that code clone made on the quality of software, refactorable code clones need to be found and then eliminated through refactoring. Aiming at the problem of how to find the refactorable code clone, this paper proposes a method based on SOM (Self Organized Mapping) clustering. Firstly, the samples of refactorable code clones are selected manually. Then, the values of the samples are normalized for creating SOM model. Finally, some probable refactorable code clones are found by SOM clustering, and the results will be recommended to programmer to verify which really refactorable code clones are. The experimental results show that the method has more precision than the method using single metric, and has more validity than the method using multiple metrics. © 2014 IEEE.",Conference paper,Final,Scopus
Kollár J.; Halupka I.,12759997100; 55452397300,Role of patterns in automated task-driven grammar refactoring,2013,OpenAccess Series in Informatics,29,,,171,186,15,6,10.4230/OASIcs.SLATE.2013.171,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893306427&doi=10.4230%2fOASIcs.SLATE.2013.171&partnerID=40&md5=9d15275af5a80bc4fbf5ef852d49f242,"Grammarware engineering, and grammar-dependent software development has received considerable attention in recent years. Despite of this fact, grammar refactoring as a significant cornerstone of grammarware engineering is still weakly understood and little practiced. In this paper, we address this issue by proposing universal algorithm for automated refactoring of context-free grammars called mARTINICA, and formal specification language for preserving knowledge of grammar engineers called pLERO. Significant advantage of mARTINICA with respect to other automated refactoring approaches is that it performs grammar refactoring on the bases of user-defined refactoring task, rather then operating under some fixed objective of refactoring process. In order to be able to understand unified refactoring process of mARTINICA this paper also provides brief insight in grammar refactoring operators, which in our approach provide universal refactoring transformations for specific context-free grammars. For preserving of knowledge considering refactoring process we propose formalism based on patterns which are well-proven method of knowledge preservation in variety of other domains, such as software architectures. © Ján Kollár and Ivan Halupka.",Conference paper,Final,Scopus
Martins P.; Pereira R.,57195251072; 35211356500,Refactoring smelly spreadsheet models,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8583 LNCS,PART 5,,556,571,15,1,10.1007/978-3-319-09156-3_39,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904878697&doi=10.1007%2f978-3-319-09156-3_39&partnerID=40&md5=1fe6d3804a3af333282924f166963321,"Identifying bad design patterns in software is a successful and inspiring research trend. While these patterns do not necessarily correspond to software errors, the fact is that they raise potential problematic issues, often referred to as code smells, and that can for example compromise maintainability or evolution. The identification of code smells in spreadsheets, which can be viewed as software development environments for non-professional programmers, has already been the subject of confluent researches by different groups. While these research groups have focused on detecting smells on concrete spreadsheets, or spreadsheet instances, in this paper we propose a comprehensive set of smells for abstract representations of spreadsheets, or spreadsheet models. We also propose a set of refactorings suggesting how spreadsheet models can become simpler to understand, manipulate and evolve. Finally we present the integration of both smells and refactorings under the MDSheet framework. © 2014 Springer International Publishing.",Conference paper,Final,Scopus
Mayer P.; Schroeder A.,22980557600; 8902630000,Automated multi-language artifact binding and rename refactoring between Java and DSLs used by Java frameworks,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8586 LNCS,,,437,462,25,15,10.1007/978-3-662-44202-9_18,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84905380688&doi=10.1007%2f978-3-662-44202-9_18&partnerID=40&md5=8f4017713eeb229a75f97abcaa86fcbe,"Developing non-trivial software applications involves using multiple programming languages. Although each language is used to describe a particular aspect of the system, artifacts defined inside those languages reference each other across language boundaries; such references are often only resolved at runtime. However, it is important for developers to be aware of these references during development time for programming understanding, bug prevention, and refactoring. In this work, we report on a) an approach and tool for automatically identifying multi-language relevant artifacts, finding references between artifacts in different languages, and (rename-) refactoring them, and b) on an experimental evaluation of the approach on seven open-source case studies which use a total of six languages found in three frameworks. As our main result, we provide insights into the incidence of multi-language bindings in the case studies as well as the feasibility of automated multi-language rename refactorings. © 2014 Springer-Verlag.",Conference paper,Final,Scopus
Liu W.; Hu Z.-G.; Liu H.-T.; Yang L.,56626205200; 57203298202; 56166575900; 57192064629,Automated pattern-directed refactoring for complex conditional statements,2014,Journal of Central South University,21,5,,1935,1945,10,8,10.1007/s11771-014-2140-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84900867599&doi=10.1007%2fs11771-014-2140-z&partnerID=40&md5=04ef8dd1be8888938a374dec1e77bd8e,"Complex conditional statement is one of the bad code smells, which affects the quality of the code and design of software. In the proposed approach, two commonly-used design patterns for handling complex conditional statements are selected, and they are the factory method pattern and the strategy pattern. Two pattern-directed refactoring approaches based on the two design patterns are proposed. Each approach contains a refactoring opportunities identification algorithm and an automated refactoring algorithm. After parsing the abstract syntax tree generated from source code, the refactoring opportunities are identified effectively and automatically. Then, for candidate code, refactoring algorithms are executed automatically, which are used to simplify or remove complex conditional statements. By empirical analysis and quality assessment, the code after refactoring has better maintainability and extensibility, and the proposed approach for automated pattern-directed refactoring succeeds to reduce code size and complexity of classes. © 2014 Central South University Press and Springer-Verlag Berlin Heidelberg.",Article,Final,Scopus
Ouni A.; Kessentini M.; Sahraoui H.,50761492200; 25653537200; 57196894039,Search-based refactoring using recorded code changes,2013,"Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR",,,6498470,221,230,9,45,10.1109/CSMR.2013.31,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84877273513&doi=10.1109%2fCSMR.2013.31&partnerID=40&md5=cdb402795b9bea8c679531aa65cb6d96,"Over the past decades, many techniques and tools have been developed to record the sequence of applied refactoring to improve design quality. We start from the observation that these recorded code changes can be used to propose new refactoring solutions in similar contexts. In addition, this knowledge can be combined with structural and semantic information, used by existing work, to improve the automation of refactoring. In this paper, we propose a multi-objective optimization approach to find the best sequence of refactorings that maximizes the use of refactoring applied in the past to similar contexts, minimizes semantic errors and minimizes the number of defects (improve code quality). To this end, we use the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-off between these three objectives. We report the results of our experiments on different open source java projects. © 2013 IEEE.",Conference paper,Final,Scopus
Bavota G.; Oliveto R.; Gethers M.; Poshyvanyk D.; De Lucia A.,57220148228; 15136561900; 36141662300; 13613571900; 7003641564,Methodbook: Recommending move method refactorings via relational topic models,2014,IEEE Transactions on Software Engineering,40,7,6684534,671,694,23,118,10.1109/TSE.2013.60,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904326575&doi=10.1109%2fTSE.2013.60&partnerID=40&md5=6003fc059f237e2353ef8923cad3dd01,"During software maintenance and evolution the internal structure of the software system undergoes continuous changes. These modifications drift the source code away from its original design, thus deteriorating its quality, including cohesion and coupling of classes. Several refactoring methods have been proposed to overcome this problem. In this paper we propose a novel technique to identify Move Method refactoring opportunities and remove the Feature Envy bad smell from source code. Our approach, coined as Methodbook, is based on relational topic models (RTM), a probabilistic technique for representing and modeling topics, documents (in our case methods) and known relationships among these. Methodbook uses RTM to analyze both structural and textual information gleaned from software to better support move method refactoring. We evaluated Methodbook in two case studies. The first study has been executed on six software systems to analyze if the move method operations suggested by Methodbook help to improve the design quality of the systems as captured by quality metrics. The second study has been conducted with eighty developers that evaluated the refactoring recommendations produced by Methodbook. The achieved results indicate that Methodbook provides accurate and meaningful recommendations for move method refactoring operations. © 1976-2012 IEEE.",Article,Final,Scopus
Mahouachi R.; Kessentini M.; Cinnéide M.Ó.,55154472800; 25653537200; 55890614500,Search-based refactoring detection using software metrics variation,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8084 LNCS,,,126,140,14,17,10.1007/978-3-642-39742-4_11,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84884914535&doi=10.1007%2f978-3-642-39742-4_11&partnerID=40&md5=7881b429a6decc95370873eafe3d37dd,"Software is frequently refactored to improve its design, either as part of an agile development process or as part of a major design overhaul. In either case, it is very useful to determine what refactorings have recently taken place in order to comprehend better the software and its development trajectory. To this end, we have developed an approach to automate the detection of source code refactorings using structural information extracted from the source code. Our approach takes as input a list of possible refactorings, a set of structural metrics and the initial and revised versions of the source code. It generates as output a sequence of detected changes expressed as refactorings. This refactoring sequence is determined by a search-based process that minimizes the metrics variation between the revised version of the software and the version yielded by the application of the refactoring sequence to the initial version of the software. We use both global and local heuristic search algorithms to explore the space of possible solutions. In applying our approach to several versions of four open source projects we find the average Precision and Recall to be over 90%, thus confirming the effectiveness of our detection approach. © 2013 Springer-Verlag.",Conference paper,Final,Scopus
Su X.; Zhang F.; Li X.; Ma P.; Wang T.,7402181881; 55614618400; 56589232400; 7201420926; 55430891400,Functionally equivalent C code clone refactoring by combining static analysis with dynamic testing,2014,Advances in Intelligent Systems and Computing,250,,,247,256,9,1,10.1007/978-81-322-1695-7_28,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84927565011&doi=10.1007%2f978-81-322-1695-7_28&partnerID=40&md5=651abb97bb5398aada8ced9353b186d4,"Software with code clones is difficult for maintenance. It increases the cost of software maintenance. To solve the key problems of function optimization and parameter matching during the process of functionally equivalent code clone refactoring, this paper puts forward an approach for restructuring the fourth type (functionally equivalent) code clone by combining static analysis and dynamic testing. First, two kinds of function optimization strategy are proposed, i.e., running time and static characteristics. Then, determine the optimization function in each functionally equivalent code clone group according to the proposed optimization strategy. Finally, use the method of static analysis and dynamic testing tomatch the parameter matching for the replacement of procedure. On the basis of parameter matching, replace other clones with the optimization function and then complete the C code clone refactoring. Functionally equivalent C code clone refactoring system prototype is developed. Experimental results on the open source program show that the method can be accurately and effectively refactor the functionally equivalent C clone code. © Springer India 2014.",Conference paper,Final,Scopus
Jurnecka P.; Hanacek P.; Kacic M.,24469637700; 6508388287; 55574681500,Concept of parallel code refactoring system for safety standards compliance,2013,"Proceedings of the 2013 IEEE 7th International Conference on Intelligent Data Acquisition and Advanced Computing Systems, IDAACS 2013",2,,6663001,630,634,4,1,10.1109/IDAACS.2013.6663001,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84892653513&doi=10.1109%2fIDAACS.2013.6663001&partnerID=40&md5=f9b2c3916ea6aac1dd843f51c99a5825,"The importance of safety standards of software systems is increasing as the use of software grows because of its convenience and flexibility. Software safety standards are very important in aircraft, military, automotive or medical devices. We are developing parallel code generating and refactoring system for safety standards compliance, which increases reliability of existing codes by refactoring of existing parallel source code, introducing parallel design patterns into this code. This paper describes the current status of these software safety standards, points out the common requirements of all these standards, specially the requirement for reliability. Reliability can be easily achieved using design patterns with verified reliable source code modules. In our research, we propose system for implementation of concurrency and synchronization design patterns into existing code. We have created parallel source code search API, which is planned to be used in our parallel code refactoring system for safety standards compliance. This API enables us to define appropriate places in source codes for introduction of parallel design patterns into existing parallel source codes. In next design iteration, the proposed system will provide suggestions of refactoring operations of found source codes, based on static code analysis and formal description of parallel design patterns. © 2013 IEEE.",Conference paper,Final,Scopus
Chaparro O.; Bavota G.; Marcus A.; Di Penta M.,25631575400; 57220148228; 9239576200; 6602794138,On the impact of refactoring operations on code quality metrics,2014,"Proceedings - 30th International Conference on Software Maintenance and Evolution, ICSME 2014",,,6976117,456,460,4,54,10.1109/ICSME.2014.73,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84931058154&doi=10.1109%2fICSME.2014.73&partnerID=40&md5=bd32f902be2003413ab3ff7166572bf6,"Refactorings are behavior-preserving source code transformations. While tool support exists for (semi) automatically identifying refactoring solutions, applying or not a recommended refactoring is usually up to the software developers, who have to assess the impact that the transformation will have on their system. Evaluating the pros (e.g., the bad smell removal) and cons (e.g., side effects of the change) of a refactoring is far from trivial. We present RIPE (Refactoring Impact Prediction), a technique that estimates the impact of refactoring operations on source code quality metrics. RIPE supports 12 refactoring operations and 11 metrics and it can be used together with any refactoring recommendation tool. RIPE was used to estimate the impact on 8,103 metric values, for 504 refactorings from 15 open source systems. 38% of the estimates are correct, whereas the median deviation of the estimates from the actual values is 5% (with a 31% average). © 2014 IEEE.",Conference paper,Final,Scopus
Jurne?ka P.; Haná?ek P.; Kacic M.,24469637700; 6508388287; 55574681500,"Code search API, base of parallel code refactoring system for safety standards compliance",2014,Journal of Cyber Security and Mobility,3,1,,47,64,17,0,10.13052/jcsm2245-1439.313,https://www.scopus.com/inward/record.uri?eid=2-s2.0-85000580170&doi=10.13052%2fjcsm2245-1439.313&partnerID=40&md5=504ea8998d64f20772f5024937eee68e,"New technologies of multi-core and massively parallel processors are becoming common parts of today's desktop computers. These state-of-the-art technologies allow programming of parallel applications and systems, however, creating parallel applications puts higher demands on programmers' skills, project maintenance and modification of existing source codes. Program flaws entered on source codes could have fatal consequences, specifically in aviation or medicine systems, due to possible fatal impacts in case of systems failure. This paper describes the current status of aviation and medicine software safety standards, points out the common requirements of all these standards, specially the requirement for reliability. Reliability can be easily achieved using design patterns with verified reliable source code modules. In our research, we propose system for implementation of concurrency and synchronization design patterns into existing code. We have created parallel source code search API which is described in this paper, and which is planned to be used in our parallel code refactoring system for safety standards compliance. This API enables us to define appropriate places in source codes for introduction of parallel design patterns into existing parallel source codes. In next design iteration, the proposed system will provide suggestions of refactoring operations of found source codes, based on static code analysis and formal description of parallel design patterns. © 2014 River Publishers. All rights reserved.",Article,Final,Scopus
Couturier B.; Kiagias E.; Lohn S.B.,55207422800; 56241142500; 35725788800,Systematic profiling to monitor and specify the software refactoring process of the LHCb experiment,2014,Journal of Physics: Conference Series,513,TRACK 5,52020,,,,2,10.1088/1742-6596/513/5/052020,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84903554780&doi=10.1088%2f1742-6596%2f513%2f5%2f052020&partnerID=40&md5=b7d081e5006c3376ec93b21b15794ea7,"The LHCb upgrade program implies a significant increase in data processing that will not be matched by additional computing resources. Furthermore, new architectures such as many-core platforms can currently not be fully exploited due to memory and I/O bandwidth limitations. A considerable refactoring effort will therefore be needed to vectorize and parallelize the LHCb software, to minimize hotspots and to reduce the impact of bottlenecks. It is crucial to guide refactoring with a profiling system that gives hints to regions in source-code for possible and necessary re-engineering and which kind of optimization could lead to final success. Software optimization is a sophisticated process where all parts, compiler, operating system, external libraries and chosen hardware play a role. Intended improvements can have different effects on different platforms. To obtain precise information of the general performance, to make profiles comparable, reproducible and to verify the progress of performance in the framework, it is crucial to produce profiles more systematically in terms of regular profiling based on representative use cases and to perform regression tests. Once a general execution, monitoring and analysis platform is available, software metrics can be derived from the collected profiling results to trace changes in performance back and to create summary reports on a regular basis with an alert system if modifications led to significant performance degradations. © Published under licence by IOP Publishing Ltd.",Conference paper,Final,Scopus
Kwon Y.-W.; Tilevich E.,57208480210; 6507251807,Cloud refactoring: Automated transitioning to cloud-based services,2014,Automated Software Engineering,21,3,,345,372,27,32,10.1007/s10515-013-0136-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902289227&doi=10.1007%2fs10515-013-0136-9&partnerID=40&md5=5cad7e9a46b0267e66dfed7804e05638,"Using cloud-based services can improve the performance, reliability, and scalability of a software application. However, transitioning an application to use cloud-based services is difficult, costly, and error-prone. The required re-engineering effort includes migrating to the cloud the functionality to be accessed as remote cloud-based services and re-targeting the client code accordingly. In addition, the client must be able to detect and handle the faults raised in the process of invoking the services. As a means of streamlining this transitioning, we developed a set of refactoring techniques - automated, IDE-assisted program transformations that eliminate the need to change programs by hand. In particular, we show how a programmer can extract services, add fault tolerance functionality, and adapt client code to invoke cloud services via refactorings integrated with a modern IDE. As a validation, we have applied our approach to automatically transform two third-party Java applications to use cloud-based services. We have also applied our approach to re-engineer a suite of services operated by General Electric to use cloud-based resources to better satisfy the GE business requirements. © 2013 Springer Science+Business Media New York.",Article,Final,Scopus
Fernández-Ropero M.; Pérez-Castillo R.; Cruz-Lemus J.A.; Piattini M.,54683892800; 34977424500; 35578821900; 7004203473,Assessing the best-order for business process model refactoring,2013,Proceedings of the ACM Symposium on Applied Computing,,,,1397,1402,5,14,10.1145/2480362.2480625,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84877994649&doi=10.1145%2f2480362.2480625&partnerID=40&md5=86652d424be4ac8267689bc97f6bf03c,"Quality assurance is one of the most critical activities in business process models which are obtained by reverse engineering, e.g., from existing information systems. Companies must deal with several quality faults in business process models such as irrelevant elements, fine-grain granularity or incompleteness, which affect understandability and modifiability of business process models. Hence, business process refactoring techniques are often used to improve these features, which change the internal structure of business process models while its external behavior is preserved. Unfortunately, different refactoring operators do not fulfill commutative property among them. For this reason, this paper addresses the challenge of establishing the best order in which to apply all the different refactoring operators and, therefore, to achieve the highest quality improvement. The research methodology consists of conducting a real-life case study to assess the influence of the refactoring operator's order in the understandability and modifiability of business process models. The case study demonstrates that there is a clear influence in these quality features in terms of the size and separability of the business process models under study. Copyright 2013 ACM.",Conference paper,Final,Scopus
Ouni A.; Kessentini M.; Sahraoui H.,50761492200; 25653537200; 57196894039,Multiobjective optimization for software refactoring and evolution,2014,Advances in Computers,94,,,103,167,64,16,10.1016/B978-0-12-800161-5.00004-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84906851637&doi=10.1016%2fB978-0-12-800161-5.00004-9&partnerID=40&md5=39a0c1b788d1bf4a488fe891b2a1e1d9,"Many studies reported that software maintenance, traditionally defined as any modification made on a software system after its delivery, consumes up to 90% of the total cost of a typical software project. Adding new functionalities, correcting bugs, and modifying the code to improve its quality are major parts of those costs. To ease these maintenance activities, one of the most used techniques is the refactoring which improves design structure while preserving the external behavior.In general, refactoring is performed through two main steps: (1) detection of code fragments corresponding to design defects that need to be improved/fixed and (2) identification of refactoring solutions to achieve this goal. Our research project targets the automation of these two refactoring steps. Concretely, we consider the detection step as a search-based process to find the suitable detection rules for each type of design defect, by means of a genetic algorithm. To guide the rule-derivation process, real examples of design defects are used. For the refactoring identification step, a multiobjective search-based approach is also used. The process aims at finding the optimal sequence of refactoring operations that improve the software quality by minimizing the number of detected defects. In addition, we explore other objectives to optimize: the effort needed to apply refactorings, semantic preservation, and the similarity with good refactorings applied in the past to similar contexts. Hence, the effort corresponds to the code modification/adaptation score needed to apply the suggested refactoring solutions. On the other hand, the semantic preservation insures that the refactored program is semantically equivalent to the original one, and that it models correctly the domain semantics. Indeed, we use knowledge from historical code changes to propose new refactoring solutions in similar contexts to improve the automation of refactoring. © 2014 Elsevier Inc.",Book chapter,Final,Scopus
Kaur L.; Kaur K.; Gupta A.,57212982740; 57723788800; 57209589365,Resolving conflict in code refactoring,2013,"Designing, Engineering, and Analyzing Reliable and Efficient Software",,,,149,161,12,0,10.4018/978-1-4666-2958-5.ch009,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84898367919&doi=10.4018%2f978-1-4666-2958-5.ch009&partnerID=40&md5=a74a359e63498fdf0a33b690678a5d10,"Refactoring is a process that attempts to enhance software code quality by using small transforming functions and modifying the structure of the program through slightly different algorithm. It is important to analyze the design pattern of the software code as well as the impact and possibility of the application of some conflicting refactorings on it. The objective of this chapter is to present an approach for analyzing software design patterns in order to avoid the conflict in application of available refactoring techniques. This chapter discusses the mechanism to study software code or design patterns to automate the process of applying available refactorings while addressing the problem of conflict in their application. © 2013, IGI Global.",Book chapter,Final,Scopus
Ge X.; Murphy-Hill E.,42161436200; 16307910100,Manual refactoring changes with automated refactoring validation,2014,Proceedings - International Conference on Software Engineering,,1,,1095,1105,10,47,10.1145/2568225.2568280,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84994104671&doi=10.1145%2f2568225.2568280&partnerID=40&md5=61da2d6325b165a5e8c4301c2d667470,"Refactoring, the practice of applying behavior-preserving changes to existing code, can enhance the quality of software systems. Refactoring tools can automatically perform and check the correctness of refactorings. However, even when developers have these tools, they still perform about 90% of refactorings manually, which is error-prone. To address this problem, we propose a technique called GhostFactor separating transformation and correctness checking: we allow the developer to transform code manually, but check the correctness of her transformation automatically. We implemented our technique as a Visual Studio plugin, then evaluated it with a human study of eight software developers; GhostFactor improved the correctness of manual refactorings by 67%. © 2014 ACM.",Conference paper,Final,Scopus
Molitorisz K.,35190690900,Pattern-based refactoring process of sequential source code,2013,"Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR",,,6498488,357,360,3,8,10.1109/CSMR.2013.49,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84877267515&doi=10.1109%2fCSMR.2013.49&partnerID=40&md5=e6443f7a8a555a441106b8deac8fd9cc,"Software refactoring is a very well-studied subject, but with the huge gap between omnipresent multicore processors and the vast majority of software that has not been developed with multicore in mind, it gains new and important significance: At what locations should the sequential code be refactored? How should this be done for a given location? Is the code still correct? And finally: Does it execute faster? In this paper we present a refactoring concept to exploit parallelizable regions in legacy software. Our concept relies on the presence of recurring patterns and identifies potential regions, transforms them to parallel versions, tests them for correctness and tunes their parallel performance. We show early implementation results. © 2013 IEEE.",Conference paper,Final,Scopus
Franklin L.; Gyori A.; Lahoda J.; Dig D.,57215745886; 55849564000; 24724354600; 13404654100,LambdaFicator: From imperative to functional programming through automated refactoring,2013,Proceedings - International Conference on Software Engineering,,,6606699,1287,1290,3,30,10.1109/ICSE.2013.6606699,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84886420321&doi=10.1109%2fICSE.2013.6606699&partnerID=40&md5=c097d7a5ea555e899f22c803f809ba51,"Java 8 introduces two functional features: lambda expressions and functional operations like map or filter that apply a lambda expression over the elements of a Collection. Refactoring existing code to use these new features enables explicit but unobtrusive parallelism and makes the code more succinct. However, refactoring is tedious (it requires changing many lines of code) and error-prone (the programmer must reason about the control-flow, data-flow, and side-effects). Fortunately, these refactorings can be automated. We present LambdaFicator, a tool which automates two refactorings. The first refactoring converts anonymous inner classes to lambda expressions. The second refactoring converts for loops that iterate over Collections to functional operations that use lambda expressions. In 9 open-source projects we have applied these two refactorings 1263 and 1595 times, respectively. The results show that LambdaFicator is useful. A video highlighting the main features can be found at: http://www.youtube.com/watch?v=EIyAflgHVpU. © 2013 IEEE.",Conference paper,Final,Scopus
Liu W.; Hu Z.-G.; Liu H.-T.,56626205200; 57203298202; 56166575900,Automatic refactoring for complex conditional statements based on abstract syntax tree and polymorphism,2014,Dianzi Keji Daxue Xuebao/Journal of the University of Electronic Science and Technology of China,43,5,,736,741,5,1,10.3969/j.issn.1001-0548.2014.05.018,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908039790&doi=10.3969%2fj.issn.1001-0548.2014.05.018&partnerID=40&md5=d5cb6e99a5055349b6e3a206da56015a,"In order to solve the problems that complex conditional statements increase the complexity of program, and affect the understandability, testability, maintainability, and extendibility of existing code, a novel approach for automatic refactoring of complex conditional statements based on abstract syntax tree and polymorphism is proposed. The approach can be used to detect the refactoring opportunities for complex conditional statements and implement automatic refactoring. In this approach, the source code file is transformed to an abstract syntax tree at first; then all of the conditional statements are detected and the candidate statements which meet the preconditions are identified; and finally, the conditional statements are refactored automatically by introducing polymorphism, and each branch of the them is encapsulated into a subclass. Four projects are tested to identify refactoring opportunities and implement automatic refactoring. The results show that the precision of the identification algorithm for refactoring opportunities is 100%. Meanwhile, the approach can execute automatic refactoring correctly. The regression testing shows that none error is imported after refactoring. In addition, this approach has good efficiency and the execution time has a linear relationship with the size of system. It means that this approach can be used for projects of different scales.",Article,Final,Scopus
Ghannem A.; El Boussaidi G.; Kessentini M.,55871956200; 13104902500; 25653537200,Model refactoring using examples: A search-based approach,2014,Journal of Software: Evolution and Process,26,7,,692,713,21,18,10.1002/smr.1644,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904659752&doi=10.1002%2fsmr.1644&partnerID=40&md5=1978e77d0ab42af65d89d89e2ba0bb95,"One of the important challenges in model-driven engineering is how to improve the quality of the models' design in order to help designers understand them. Refactoring represents an efficient technique to improve the quality of a design while preserving its behavior. Most of existing work on model refactoring relies on declarative rules to detect refactoring opportunities and to apply the appropriate refactorings. However, a complete specification of refactoring opportunities requires a huge number of rules. In this paper, we consider the refactoring mechanism as a combinatorial optimization problem where the goal is to find good refactoring suggestions starting from a small set of refactoring examples applied to similar contexts. Our approach, named model refactoring by example, takes as input an initial model to refactor, a set of structural metrics calculated on both initial model and models in the base of examples, and a base of refactoring examples extracted from different software systems and generates as output a sequence of refactorings. A solution is defined as a combination of refactoring operations that should maximize as much as possible the structural similarity based on metrics between the initial model and the models in the base of examples. A heuristic method is used to explore the space of possible refactoring solutions. To this end, we used and adapted a genetic algorithm as a global heuristic search. The validation results on different systems of real-world models taken from open-source projects confirm the effectiveness of our approach. Copyright © 2014 John Wiley & Sons, Ltd. Copyright © 2014 John Wiley & Sons, Ltd.",Article,Final,Scopus
Guo J.-J.; Hsueh N.-L.; Lee W.-T.; Hwang S.-C.,55368625800; 9276504400; 36166800600; 56438357600,Improving software maintenance for pattern-based software development: A comment refactoring approach,2014,"Proceedings - 1st International Conference on Trustworthy Systems and Their Applications, TSA 2014",,,6956715,75,79,4,5,10.1109/TSA.2014.21,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84915751298&doi=10.1109%2fTSA.2014.21&partnerID=40&md5=ea2751999336dc321655bcbd91ea27be,"The effectiveness of the design patterns has been an important research topic in the software engineering area. Since uncontrolled use of design patterns results in serious problem of maintenance. Good code comments can help maintainers understand the design of the software, thus avoid the wrong utilization of design patterns. In this paper we will in our refactoring approach that can add pattern comment line to improve the software maintains for a pattern-based software. © 2014 IEEE.",Conference paper,Final,Scopus
Bavota G.; De Lucia A.; Marcus A.; Oliveto R.,57220148228; 7003641564; 9239576200; 15136561900,Automating extract class refactoring: an improved method and its evaluation,2014,Empirical Software Engineering,19,6,,1617,1664,47,68,10.1007/s10664-013-9256-x,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84909999876&doi=10.1007%2fs10664-013-9256-x&partnerID=40&md5=a9c97552aca1cd265b4034330f680669,"During software evolution the internal structure of the system undergoes continuous modifications. These continuous changes push away the source code from its original design, often reducing its quality, including class cohesion. In this paper we propose a method for automating the Extract Class refactoring. The proposed approach analyzes (structural and semantic) relationships between the methods in a class to identify chains of strongly related methods. The identified method chains are used to define new classes with higher cohesion than the original class, while preserving the overall coupling between the new classes and the classes interacting with the original class. The proposed approach has been first assessed in an artificial scenario in order to calibrate the parameters of the approach. The data was also used to compare the new approach with previous work. Then it has been empirically evaluated on real Blobs from existing open source systems in order to assess how good and useful the proposed refactoring solutions are considered by software engineers and how well the proposed refactorings approximate refactorings done by the original developers. We found that the new approach outperforms a previously proposed approach and that developers find the proposed solutions useful in guiding refactorings. © 2013, Springer Science+Business Media New York.",Article,Final,Scopus
Roman P.; Polasek I.,56032001500; 35090472200,Semi-automatic refactoring to aspect-oriented platform,2013,"CINTI 2013 - 14th IEEE International Symposium on Computational Intelligence and Informatics, Proceedings",,,6705180,141,145,4,4,10.1109/CINTI.2013.6705180,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893746495&doi=10.1109%2fCINTI.2013.6705180&partnerID=40&md5=db0079bf17e8b1c49e68e03f2880b13e,"Refactoring is necessary in large software projects and an aspect-oriented approach can help to maintain concerns in the source code. While tools for object-oriented refactoring are the usual part of development environments, support for aspect-oriented refactoring is minimal. We analyzed object-oriented bad smells applicable for an aspect-oriented approach and propose a method for the detection of crosscutting concerns and consecutive refactoring. © 2013 IEEE.",Conference paper,Final,Scopus
Ghannem A.; El Boussaidi G.; Kessentini M.,55871956200; 13104902500; 25653537200,Model refactoring using interactive genetic algorithm,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8084 LNCS,,,96,110,14,40,10.1007/978-3-642-39742-4_9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84884916788&doi=10.1007%2f978-3-642-39742-4_9&partnerID=40&md5=3795852b074046927aa9f24048496308,"Refactoring aims at improving the quality of design while preserving its semantic. Providing an automatic support for refactoring is a challenging problem. This problem can be considered as an optimization problem where the goal is to find appropriate refactoring suggestions using a set of refactoring examples. However, some of the refactorings proposed using this approach do not necessarily make sense depending on the context and the semantic of the system under analysis. This paper proposes an approach that tackles this problem by adapting the Interactive Genetic Algorithm (IGA) which enables to interact with users and integrate their feedbacks into a classic GA. The proposed algorithm uses a fitness function that combines the structural similarity between the analyzed design model and models from a base of examples, and the designers' ratings of the refactorings proposed during execution of the classic GA. Experimentation with the approach yielded interesting and promising results. © 2013 Springer-Verlag.",Conference paper,Final,Scopus
Arcelli D.,55317293800,Model-based software refactoring driven by performance analysis,2014,CEUR Workshop Proceedings,1321,,,,,,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921038531&partnerID=40&md5=9e48238ad99222bdd13974493d814866,"In order to deal with performance of software systems, it is important to introduce approaches that work in the early phases of the software life-cycle, even before the code is developed. In fact, if performance requirements are not met, there may be negative consequences on significant parts of the project. Some work has been done in the last few years to tackle the problem of automatically interpreting model-based performance analysis results and translating them into architectural feedback. In this context, software and performance models are typical artifacts involved in the interpretation, and architectural feedback consists of refactoring that can take place either on the software or the performance model. We present here this problem context, by means of a unifying framework that supports model-based software refactoring driven by performance analysis. Copyright © 2014 for the individual papers by the papers' authors.",Conference paper,Final,Scopus
Ouni A.; Kessentini M.; Sahraoui H.; Hamdi M.S.,50761492200; 25653537200; 57196894039; 57200926729,The use of development history in software refactoring using a multi-objective evolutionary algorithm,2013,GECCO 2013 - Proceedings of the 2013 Genetic and Evolutionary Computation Conference,,,,1461,1468,7,47,10.1145/2463372.2463554,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84883125873&doi=10.1145%2f2463372.2463554&partnerID=40&md5=fe907fab6ef2e9dca62b99a5a46464c7,"One of the widely used techniques for evolving software systems is refactoring, a maintenance activity that improves design structure while preserving the external behavior. Exploring past maintenance and development history can be an effective way of finding refactoring opportunities. Code elements which undergo changes in the past, at approximately the same time, bear a good probability for being semantically related. Moreover, these elements that experienced a huge number of refactoring in the past have a good chance for refactoring in the future. In addition, the development history can be used to propose new refactoring solutions in similar contexts. In this paper, we propose a multi-objective optimization-based approach to find the best sequence of refactorings that minimizes the number of bad-smells, and maximizes the use of development history and semantic coherence. To this end, we use the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-off between these three objectives. We report the results of our experiments using different large open source projects. Copyright © 2013 ACM.",Conference paper,Final,Scopus
Gonzalez A.; Uva M.; Frutos M.,25026060000; 15058367700; 55606411100,Refactoring Java code by transformation rules in QVT-Relation,2013,"Proceedings of the 2013 39th Latin American Computing Conference, CLEI 2013",,,6670658,,,,2,10.1109/CLEI.2013.6670658,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893290973&doi=10.1109%2fCLEI.2013.6670658&partnerID=40&md5=20cf4bf5c62cbe04181640f723485c1b,"Model Driven Architecture (MDA) defines a software building process based on the production and transformation of models. In this context, QVT-Relations is a declarative language designed to permit both unidirectional and bidirectional model transformations. QVT Relations is a standard defined by the Object Management Group(OMG). On the other hand, the code optimization is the process of modifying a system to make some aspect of it work more efficiently or use fewer resources. Refactoring code define the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure. In this work, we propose a technique based on MDA. This technique implements a set of refactoring rules in QVT-Relations. © 2013 IEEE.",Conference paper,Final,Scopus
Wright H.K.; Jasper D.; Klimek M.; Carruth C.; Wan Z.,35079932300; 57197127302; 57197724284; 55988310400; 55986809100,Large-scale automated refactoring using ClangMR,2013,"IEEE International Conference on Software Maintenance, ICSM",,,6676954,548,551,3,22,10.1109/ICSM.2013.93,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84891709165&doi=10.1109%2fICSM.2013.93&partnerID=40&md5=1d4e7b02edaf25f43b4b85e1a0cb95a0,"Maintaining large code bases can be a challenging endeavour. As new libraries, APIs and standards are introduced, old code is migrated to use them. To provide as clean and succinct an interface as possible for developers, old APIs are ideally removed as new ones are introduced. In practice, this becomes difficult as automatically finding and transforming code in a semantically correct way can be challenging, particularly as the size of a code base increases. In this paper, we present a real-world implementation of a system to refactor large C++ code bases efficiently. A combination of the Clang compiler framework and the MapReduce parallel processor, ClangMR enables code maintainers to easily and correctly transform large collections of code. We describe the motivation behind such a tool, its implementation and then present our experiences using it in a recent API update with Google's C++ code base. © 2013 IEEE.",Conference paper,Final,Scopus
Alves E.L.G.; Song M.; Kim M.,35185930600; 32868182400; 57203466476,RefDistiller: A refactoring aware code review tool for inspecting manual refactoring edits,2014,Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering,16-21-November-2014,,,751,754,3,28,10.1145/2635868.2661674,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84986919225&doi=10.1145%2f2635868.2661674&partnerID=40&md5=400e1b370ef5138af326419cc5709fdf,"Manual refactoring edits are error prone, as refactoring requires developers to coordinate related transformations and understand the complex inter-relationship between affected types, methods, and variables. We present REFDISTILLER, a refactoring-aware code review tool that can help developers detect potential behavioral changes in manual refactoring edits. It first detects the types and locations of refactoring edits by comparing two program versions. Based on the reconstructed refactoring information, it then detects potential anomalies in refactoring edits using two techniques: (1) a template-based checker for detecting missing edits and (2) a refactoring separator for detecting extra edits that may change a program's behavior. By helping developers be aware of deviations from pure refactoring edits, REFDISTILLER can help developers have high confidence about the correctness of manual refactoring edits. REFDISTILLER is available as an Eclipse plug-in at https://sites.google.com/site/refdistiller/and its demonstration video is available at http://youtu.be/0Iseoc5HRpU. © Copyright 2014 ACM.",Conference paper,Final,Scopus
Mahmood J.; Reddy Y.R.,56125507400; 55749120700,Automated refactorings in Java using IntelliJ IDEA to extract and propogate constants,2014,"Souvenir of the 2014 IEEE International Advance Computing Conference, IACC 2014",,,6779532,1406,1414,8,2,10.1109/IAdCC.2014.6779532,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84899122911&doi=10.1109%2fIAdCC.2014.6779532&partnerID=40&md5=e8ec61cb5f4aa01acc7697412f241ccc,"Refactoring tools suffer from usability in the areas of automating mundane tasks, providing user customization, and providing strategies for error recovery. The automation of refactoring tools can be a risky undertaking since user intervention is required in many scenarios to maintain the internal quality of the system. Any type of design level refactoring requires complex changes to the code, the validation of preconditions, and could potentially harm the system. Smaller refactorings that handle code-smells can be carried out automatically with considerably lower risk. This paper discusses the current state of automated refactoring tools, and the development of an automated refactoring tool to extract and propagate Java literal expressions in IntelliJ IDEA. © 2014 IEEE.",Conference paper,Final,Scopus
Sahin C.; Pollock L.; Clause J.,55319956100; 7005623618; 12645779800,How do code refactorings affect energy usage?,2014,International Symposium on Empirical Software Engineering and Measurement,,,a36,,,,87,10.1145/2652524.2652538,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84907819253&doi=10.1145%2f2652524.2652538&partnerID=40&md5=24ab5bd45843743249a3138164462459,"Context: Code refactoring's benefits to understandability, maintainability and extensibility are well known enough that automated support for refactoring is now common in IDEs. However, the decision to apply such transformations is currently performed without regard to the impacts of the refactorings on energy consumption. This is primarily due to a lack of information and tools to provide such relevant information to developers. Unfortunately, concerns about energy efficiency are rapidly becoming a high priority concern in many environments, including embedded systems, laptops, mobile devices, and data centers. Goal: We aim to address the lack of information about the energy efficiency impacts of code refactorings. Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings. Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring. Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy efficient software. © 2014 ACM.",Conference paper,Final,Scopus
Mkaouer W.; Kessentini M.; Bechikh S.; Deb K.; Cinnéide M.Ó.,55904259300; 25653537200; 25924742700; 7006019904; 55890614500,Recommendation system for software refactoring using innovization and interactive dynamic optimization,2014,ASE 2014 - Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering,,,,331,336,5,74,10.1145/2642937.2642965,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908637440&doi=10.1145%2f2642937.2642965&partnerID=40&md5=a5ffd5bde630263f59573b3cd4677509,"We propose a novel recommendation tool for software refactoring that dynamically adapts and suggests refactorings to developers interactively based on their feedback and introduced code changes. Our approach starts by finding upfront a set of nondominated refactoring solutions using NSGA-II to improve software quality, reduce the number of refactorings and increase semantic coherence. The generated non-dominated refactoring solutions are analyzed using our innovization component to extract some interesting common features between them. Based on this analysis, the suggested refactorings are ranked and suggested to the developer one by one. The developer can approve, modify or reject each suggested refactoring, and this feedback is used to update the ranking of the suggested refactorings. After a number of introduced code changes, a local search is performed to update and adapt the set of refactoring solutions suggested by NSGA-II. We evaluated this tool on four large open source systems and one industrial project provided by our partner. Statistical analysis of our experiments over 31 runs shows that the dynamic refactoring approach performed significantly better than three other search-based refactoring techniques, manual refactorings, and one refactoring tool not based on heuristic search. © 2014 ACM.",Conference paper,Final,Scopus
Khan M.U.; Iqbal M.Z.; Ali S.,55602694800; 57222997737; 56962801700,A heuristic-based approach to refactor crosscutting behaviors in UML state machines,2014,"Proceedings - 30th International Conference on Software Maintenance and Evolution, ICSME 2014",,,6976138,557,560,3,7,10.1109/ICSME.2014.94,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84931080483&doi=10.1109%2fICSME.2014.94&partnerID=40&md5=06e928d1a35649d4410dd9bd46ffc950,"UML state machines are commonly used to model the state-based behavior of communication and control systems to support various activities such as test cases and code generation. Standard UML state machines are well suited to model functional behavior, however extra-functional behavior such as robustness and security can also be directly modeled on them, but this often results in cluttered models since extra-functional behaviors are often crosscutting. Such modeling crosscutting behavior directly on UML state machines is a common practice. Aspect-Oriented Modeling (AOM) allows systematically modeling of crosscutting behavior and has shown to provide a scalable solution in the recent years. However, due to lack of familiarity of AOM in both academic and industry, extra-functional behavior is often modeled directly on UML state machines and as a result those UML state machines are difficult to read and maintain. To improve the readability of already developed UML state machines and ease maintenance, we propose a set of heuristics, derived from two industrial cases studies, implemented in a tool to automatically identify commonly observed crosscutting behaviors in UML state machines and refactor them as Aspect State Machines. Such refactoring makes the state machines easier to maintain and comprehend. We present the results of applying our proposed heuristics to the existing UML state machines of two industrial case studies developed for model-based testing. © 2014 IEEE.",Conference paper,Final,Scopus
Chitra M.T.; Sherly E.,57198084599; 36069768600,Refactoring sequence diagrams for code generation in UML models,2014,"Proceedings of the 2014 International Conference on Advances in Computing, Communications and Informatics, ICACCI 2014",,,6968414,208,212,4,3,10.1109/ICACCI.2014.6968414,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84927655178&doi=10.1109%2fICACCI.2014.6968414&partnerID=40&md5=b33feb474dc73d8a902bc1fd2ae47687,"The UML Sequence Diagram along with Model Driven Architecture in software development helps to model the time constraint behavior that enhances the legibility of the structure and behavior of a system. The Object Constraint Language (OCL) helps to convey additional constraints and invariants required, but OCL confines into an expression language. The lack of program logic and flow of control limit these models to generate codes and also for proper verifications. This paper concentrates on refactoring XMI of Sequence diagram, an XML Meta data Interchange, with OCL constraints to build a framework for automatic code generation. The proposed model is tested in a coal mill of a Thermal Power Plant, a highly complex time constrained system. The source code generated from the refactored XMI is able to generate the set of coal mill parameters that matches to the real plant data results. © 2014 IEEE.",Conference paper,Final,Scopus
Concas G.; Monni C.; Orru M.; Tonelli R.,57105938400; 33568075100; 55982780800; 7004058057,Are refactoring practices related to clusters in java software?,2014,Lecture Notes in Business Information Processing,179 LNBIP,,,269,276,7,5,10.1007/978-3-319-06862-6_20,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904555590&doi=10.1007%2f978-3-319-06862-6_20&partnerID=40&md5=ee265415286a59c7f0890c4d1e2bf335,"Refactoring is widely used among the practices of Agile software development. In this preliminary work we present an empirical study carried out on several releases of 5 software systems written in Java. We focus our attention on the effect of refactoring activities on the topology of the software network. We find that refactoring activities involve classes linked together into clusters inside the software network and the clusters may be modified in different ways by the refactoring activity. This could lead to significative changes in source code, whose knowledge could be valuable for people involved in software development. © Springer International Publishing Switzerland 2014.",Conference paper,Final,Scopus
Ge X.; Sarkar S.; Murphy-Hill E.,42161436200; 57198931976; 16307910100,Towards refactoring-aware code review,2014,"8th International Workshop on Cooperative and Human Aspects of Software Engineering, CHASE 2014 - Proceedings",,,,99,102,3,16,10.1145/2593702.2593706,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963988878&doi=10.1145%2f2593702.2593706&partnerID=40&md5=f7a924709f1914e56ad0ab4997f50259,"Software developers review changes to a code base to prevent new bugs from being introduced. However, some parts of a change are more likely to introduce bugs than others, and thus deserve more care in reviewing. In this short paper, we discuss our ongoing work to build a reviewing tool that automatically determines which changes in a change set are refactorings, uses this information to help the developer distinguish between refactoring and non-refactoring changes, and ultimately reduces the time it takes developers to review code accurately. We also discuss the challenges and opportunities we have faced when building this refactoring-aware code review tool. Copyright 2014 ACM.",Conference paper,Final,Scopus
Kaur L.; Kaur K.; Gupta A.,57212982740; 57723788800; 57209589365,Resolving conflict in code refactoring,2013,"Software Design and Development: Concepts, Methodologies, Tools, and Applications",4-Apr,,,1787,1800,13,0,10.4018/978-1-4666-4301-7.ch085,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84944678478&doi=10.4018%2f978-1-4666-4301-7.ch085&partnerID=40&md5=15618b735eb5e45dab90a00c5dbf6cba,"Refactoring is a process that attempts to enhance software code quality by using small transforming functions and modifying the structure of the program through slightly different algorithm. It is important to analyze the design pattern of the software code as well as the impact and possibility of the application of some conflicting refactorings on it. The objective of this chapter is to present an approach for analyzing software design patterns in order to avoid the conflict in application of available refactoring techniques. This chapter discusses the mechanism to study software code or design patterns to automate the process of applying available refactorings while addressing the problem of conflict in their application. © 2014, IGI Global.",Book chapter,Final,Scopus
Jurne?ka P.; Haná?ek P.; Barabas M.; Henzl M.; Ka?ic M.,24469637700; 6508388287; 54419470200; 55575537000; 55574681500,A method for parallel software refactoring for safety standards compliance,2013,IET Conference Publications,2013,620 CP,,,,,1,10.1049/cp.2013.1724,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893010352&doi=10.1049%2fcp.2013.1724&partnerID=40&md5=3a37c4cfbddb9a50675f87d01b6c26c2,"The importance of safety standards of software systems is increasing as the use of software grows because of its convenience and flexibility. Software safety standards are very important in aircraft, automotive or medical devices. Common requirement of all these standards is the requirement of reliability, which can be easily achieved by verified usage of design patterns. We have developed parallel code generating and refactoring system for safety standards compliance, which increases reliability of existing codes by refactoring and parallel design patterns. In our research, we have created system for implementation of concurrency and synchronization design patterns into (previously created) poor quality parallel source codes, which is the most important part of reducing potential sources of faults. An important part of our system is a method for specification of verifiable parallel design patterns, which is the main contribution described by this article.",Conference paper,Final,Scopus
Liu H.; Liu Y.; Xue G.; Gao Y.,56862404100; 56900894500; 56017754800; 57109537700,Case study on software refactoring tactics,2014,IET Software,8,1,,1,11,10,3,10.1049/iet-sen.2012.0121,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893154507&doi=10.1049%2fiet-sen.2012.0121&partnerID=40&md5=92f781e0685bade92d458a5349fa313a,"Refactorings might be done using two different tactics: root canal refactoring and floss refactoring. Root canal refactoring is to set aside an extended period specially for refactoring. Floss refactoring is to interleave refactorings with other programming tasks. However, no large-scale case study on refactoring tactics is available. To this end, the authors carry out a case study to investigate the following research questions. (i) How often are root canal refactoring and floss refactoring employed, respectively? (ii) Are some kinds of refactorings more likely than others to be applied as floss refactorings or root canal refactorings? (iii) Do engineers employing both tactics have obvious bias to or against either of the tactics? They analyse the usage data information collected by Eclipse usage data collector. Results suggest that about 14% of refactorings are root canal refactorings. These findings reconfirm the hypothesis that, in general, floss refactoring is more common than root canal refactoring. The relative popularity of root canal refactoring, however, is much higher than expected. They also find that some kinds of refactorings are more likely than others to be performed as root canal refactorings. Results also suggest that engineers who have explored both tactics obviously tended towards root canal refactoring.©The Institution of Engineering and Technology 2014.",Article,Final,Scopus
Mahmoud A.; Niu N.,36559998700; 36856329200,Supporting requirements to code traceability through refactoring,2014,Requirements Engineering,19,3,,309,329,20,30,10.1007/s00766-013-0197-0,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84906310312&doi=10.1007%2fs00766-013-0197-0&partnerID=40&md5=f697420ea2703a23509719e0159153bc,"In this paper, we hypothesize that the distorted traceability tracks of a software system can be systematically re-established through refactoring, a set of behavior-preserving transformations for keeping the system quality under control during evolution. To test our hypothesis, we conduct an experimental analysis using three requirements-to-code datasets from various application domains. Our objective is to assess the impact of various refactoring methods on the performance of automated tracing tools based on information retrieval. Results show that renaming inconsistently named code identifiers, using Rename Identifier refactoring, often leads to improvements in traceability. In contrast, removing code clones, using eXtract Method (XM) refactoring, is found to be detrimental. In addition, results show that moving misplaced code fragments, using Move Method refactoring, has no significant impact on trace link retrieval. We further evaluate Rename Identifier refactoring by comparing its performance with other strategies often used to overcome the vocabulary mismatch problem in software artifacts. In addition, we propose and evaluate various techniques to mitigate the negative impact of XM refactoring. An effective traceability sign analysis is also conducted to quantify the effect of these refactoring methods on the vocabulary structure of software systems. © 2013 Springer-Verlag London.",Article,Final,Scopus
Sharma T.; Murthy P.,25224153100; 55263117100,ESA: The exclusive-similarity algorithm for identifying extract-class refactoring candidates automatically,2014,ACM International Conference Proceeding Series,,,,,,,0,10.1145/2590748.2590763,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902590038&doi=10.1145%2f2590748.2590763&partnerID=40&md5=7bb95fe42bfdead6d7b8203696cbf05d,"Refactoring has become an essential part of software development process especially for large and long lasting projects. Extract-class is one of the vital refactorings that is used to improve cohesion of a class by splitting large in-cohesive classes into more cohesive ones. Providing automated means of identifying opportunities for extract-class refactoring could make the software maintenance effecient. In this paper, a novel algorithm viz. ESA (""Exclusive-Similarity"" Algorithm) is proposed to identify extract-class refactoring candidates automatically. The algorithm proposes new metrics viz. Exclusive-Similarity metric (ESM), Cohesion among Method-Clusters, (CMC) and Method-Similarity with Attribute-Clusters (MSAC). The proposed algorithm has been realized into a tool as an add-in to Visual Studio and the tool is exercised with 3 open-source projects to demonstrate applicability. Copyright 2014 ACM.",Conference paper,Final,Scopus
Guerra E.; Aguiar A.,24476299600; 35753041400,Support for refactoring an application towards an adaptive object model,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8583 LNCS,PART 5,,73,89,16,4,10.1007/978-3-319-09156-3_6,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904868453&doi=10.1007%2f978-3-319-09156-3_6&partnerID=40&md5=3a2640e08fece573fa22b069a2606cf6,"Flexibility requirements can appear in the middle of a software development, perceived by several client requests to change the application. A flexible domain model, usually implemented with using the adaptive object model (AOM) architectural style, required custom-made components to handle the current implementation of the domain entities. The problem is that by evolving an AOM model, the components need to be evolved as well, which generates constant rework. This work studied the possible AOM evolution paths, in order to provide support in the components for model changing. An evolution of the Esfinge AOM RoleMapper framework were developed to provide this functionality, allowing AOM models in different stages to be mapped to a single structure. The study was evaluated using a set of tests that were applied in each possible structure for the model. © 2014 Springer International Publishing.",Conference paper,Final,Scopus
Vidal S.A.; Marcos C.A.,36142371300; 15124839500,Toward automated refactoring of crosscutting concerns into aspects,2013,Journal of Systems and Software,86,6,,1482,1497,15,9,10.1016/j.jss.2012.12.045,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84876418498&doi=10.1016%2fj.jss.2012.12.045&partnerID=40&md5=acc83d530ae9a448f8bd4f7f235a5ad7,"Aspect-oriented programing (AOP) improves the separation of concerns by encapsulating crosscutting concerns into aspects. Thus, aspect-oriented programing aims to better support the evolution of systems. Along this line, we have defined a process that assists the developer to refactor an object-oriented system into an aspect-oriented one. In this paper we propose the use of association rules and Markov models to improve the assistance in accomplishing some of the tasks of this process. Specifically, we use these techniques to help the developer in the task of encapsulating a fragment of aspectizable code into an aspect. This includes the choice of a fragment of aspectizable code to be encapsulated, the selection of a suitable aspect refactoring, and the analysis and application of additional restructurings when necessary. Our case study of the refactoring of a J2EE system shows that the use of the process reduces the intervention of the developer during the refactoring. © 2013 Elsevier Inc. All rights reserved.",Article,Final,Scopus
Ordiales Coscia J.L.; Mateos C.; Crasso M.; Zunino A.,55303736600; 24171844000; 15073886400; 8688799600,Refactoring code-first Web Services for early avoiding WSDL anti-patterns: Approach and comprehensive assessment,2014,Science of Computer Programming,89,PART C,,374,407,33,21,10.1016/j.scico.2014.03.015,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84900310154&doi=10.1016%2fj.scico.2014.03.015&partnerID=40&md5=79cab09e033a159e067b29242f483bbc,"Previous research of our own [34] has shown that by avoiding certain bad specification practices, or WSDL anti-patterns, contract-first Web Service descriptions expressed in WSDL can be greatly improved in terms of understandability and retrievability. The former means the capability of a human discoverer to effectively reason about a Web Service functionality just by inspecting its associated WSDL description. The latter means correctly retrieving a relevant Web Service by a syntactic service registry upon a meaningful user's query. However, code-first service construction dominates in the industry due to its simplicity. This paper proposes an approach to avoid WSDL anti-patterns in code-first Web Services. We also evaluate the approach in terms of services understandability and retrievability, deeply discuss the experimental results, and delineate some guidelines to help code-first Web Service developers in dealing with the trade-offs that arise between these two dimensions. Certainly, our approach allows services to be more understandable, due to anti-pattern remotion, and retrievable as measured by classical Information Retrieval metrics. © 2014 Elsevier B.V. All rights reserved.",Article,Final,Scopus
Chen J.; Xiao J.; Wang Q.; Osterweil L.J.; Li M.,57203335145; 14038341400; 55698296000; 7003878989; 14037679100,Refactoring planning and practice in agile software development: An empirical study,2014,ACM International Conference Proceeding Series,,,,55,64,9,4,10.1145/2600821.2600829,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902520233&doi=10.1145%2f2600821.2600829&partnerID=40&md5=60dd984b811cb0ae589b8381420cebbf,"Agile software engineering increasingly seeks to incorporate design modification and continuous refactoring in order to maintain code quality even in highly dynamic environments. However, there does not currently appear to be an industry-wide consensus on how to do this and research in this area expresses conflicting opinions. This paper presents an empirical study based upon an industry survey aimed at understanding the different ways that refactoring is thought of by the different people carrying out different roles in agile processes and how these different people weigh the importance of refactoring versus other kinds of tasks in the process. The study found good support for the importance of refactoring, but most respondents agreed that deferred refactoring impacts the agility of their process. Thus there was no universally agreed-upon strategy for planning refactoring. The survey findings also indicated that different roles have different perspectives on the different kinds of tasks in an agile process although all seem to want to increase the priority given to refactoring during planning for the iterations in agile development. Analysis of the survey raised many interesting questions suggesting the need for a considerable amount of future research. © 2014 ACM.",Conference paper,Final,Scopus
Chen L.; Babar M.A.,36090727600; 6602842620,Towards an evidence-based understanding of emergence of architecture through continuous refactoring in agile software development,2014,"Proceedings - Working IEEE/IFIP Conference on Software Architecture 2014, WICSA 2014",,,6827119,195,204,9,22,10.1109/WICSA.2014.45,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84903715982&doi=10.1109%2fWICSA.2014.45&partnerID=40&md5=5bbdbbc013f58d1ab8e977d595864ef5,"The proponents of Agile software development approaches claim that software architecture emerges from continuous small refactoring, hence, there is not much value in spending upfront effort on architecture related issues. Based on a large-scale empirical study involving 102 practitioners who had worked with agile and architecture approaches, we have found that whether or not architecture emerges through continuous refactoring depends upon several contextual factors. Our study has identified 20 factors that have been categorized into four elements: project, team, practices, and organization. These empirically identified contextual factors are expected to help practitioners to make informed decisions about their architecture practices in agile software development. © 2014 IEEE.",Conference paper,Final,Scopus
Cunha J.; Fernandes J.P.; Martins P.; Pereira R.; Saraiva J.,23983985900; 7201540314; 57195251072; 35211356500; 57203315736,Refactoring meets model-driven spreadsheet evolution,2014,"Proceedings - 2014 9th International Conference on the Quality of Information and Communications Technology, QUATIC 2014",,,6984117,196,201,5,6,10.1109/QUATIC.2014.34,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921061977&doi=10.1109%2fQUATIC.2014.34&partnerID=40&md5=4dda9d4622a37dc66f20eb5488a55794,"Software refactoring is a well-known technique that provides transformations on software artifacts with the aim of improving their overall quality. In this paper we present a set of refactoring for Class Sheets, a modelling language that allows to specify the business logic of a spreadsheet in an object-oriented fashion. The set of refactoring that we propose allows us to improve the quality of these spreadsheet models. Moreover, it is implemented in a setting that guarantees that all model refactoring are automatically carried to all the corresponding (spreadsheet) instances, thus providing an automatic evolution of the data so it is always synchronized with the model. © 2014 IEEE.",Conference paper,Final,Scopus
Li H.; Qin J.; Yuan S.; Bian J.,35234042400; 56257866200; 36440579900; 56258719900,Code parallel refactoring of the Zebiak-Cane model based on JASMIN,2014,"Proceedings of 2013 3rd International Conference on Computer Science and Network Technology, ICCSNT 2013",,,6967098,213,217,4,0,10.1109/ICCSNT.2013.6967098,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84919445320&doi=10.1109%2fICCSNT.2013.6967098&partnerID=40&md5=ab6e782462fcae5d5cb7bf277dd18183,"As a new parallel framework, J Adaptive Structured Meshes applications Infrastructure (JASMIN) is designed for minimizing the impact of parallelization on serial codes. It has been widely used in fluid mechanics research and Simulation of laser, and shows good performance in grid computing. To our knowledge, however, there are no related studies in meteorological science until now. In this paper, we propose a new framework of code parallel refactoring for numerical meteorological model based on JASMIN. The refactoring process is introduced step by step, of the difficulties of such refactoring are discussed and the corresponding solutions are put forward in this paper. To demonstrate the feasibility of the proposed framework, Zebiak-Cane (ZC) model is studied as a case and refactored in a parallel way with JASMIN. Experimental results show that the proposed framework for code parallel refactoring is feasible in practical applications and can reduce the complexity of parallelization. In addition, this framework will have evident advantage in the improvement of the computing efficiency for more complex numerical models. © 2013 IEEE.",Conference paper,Final,Scopus
Zibran M.F.; Roy C.K.,36643166200; 36176304400,Conflict-aware optimal scheduling of prioritised code clone refactoring,2013,IET Software,7,3,,167,186,19,38,10.1049/iet-sen.2012.0058,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84879668288&doi=10.1049%2fiet-sen.2012.0058&partnerID=40&md5=366f88ca90e60c93313a7a69e620bebf,"Duplicated or similar source code, also known as code clones, are possible malicious 'code smells' that may need to be removed through refactoring to enhance maintainability. Among many potential refactoring opportunities, the choice and order of a set of refactoring activities may have distinguishable effect on the design/code quality measured in terms of software metrics. Moreover, there may be dependencies and conflicts among those refactorings of different priorities. Addressing all the conflicts, priorities and dependencies, a manual formulation of an optimal refactoring schedule is very expensive, if not impossible. Therefore an automated refactoring scheduler is necessary to 'maximise benefit and minimise refactoring effort'. However, the estimation of the efforts required to perform code clone refactoring is a challenging task. This study makes two contributions. First, the authors propose an effort model for the estimation of code clone refactoring efforts. Second, the authors propose a constraint programming (CP) approach for conflict-aware optimal scheduling of code clone refactoring. A qualitative evaluation of the effort model from the developers' perspective suggests that the model is complete and useful for code clone refactoring effort estimation. The authors also quantitatively compared their refactoring scheduler with other wellknown scheduling techniques such as the genetic algorithm, greedy approaches and linear programming. The authors' empirical study suggests that the proposed CP-based approach outperforms other approaches they considered. © 2013 The Institution of Engineering and Technology.",Article,Final,Scopus
Von Pilgrim J.; Ulke B.; Thies A.; Steimann F.,24475602300; 54795948000; 34870921900; 55910765900,Model/code co-refactoring: An MDE approach,2013,"2013 28th IEEE/ACM International Conference on Automated Software Engineering, ASE 2013 - Proceedings",,,6693133,682,687,5,9,10.1109/ASE.2013.6693133,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893601086&doi=10.1109%2fASE.2013.6693133&partnerID=40&md5=5fe675027debda83dbc2db99d1f13c0b,"Model-driven engineering suggests that models are the primary artefacts of software development. This means that models may be refactored even after code has been generated from them, in which case the code must be changed to reflect the refactoring. However, as we show neither re-generating the code from the refactored model nor applying an equivalent refactoring to the generated code is sufficient to keep model and code in sync - rather, model and code need to be refactored jointly. To enable this, we investigate the technical requirements of model/code co-refactoring, and implement a model-driven solution that we evaluate using a set of open-source programs and their structural models. Results suggest that our approach is feasible. © 2013 IEEE.",Conference paper,Final,Scopus
Szoke G.; Antal G.; Nagy C.; Ferenc R.; Gyimothy T.,55803891600; 6701427737; 26667913000; 6603559878; 6603266536,Bulk fixing coding issues and its effects on software quality: Is it worth refactoring?,2014,"Proceedings - 2014 14th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2014",,,6975643,95,104,9,32,10.1109/SCAM.2014.18,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924898265&doi=10.1109%2fSCAM.2014.18&partnerID=40&md5=1c2f8a4e71cfefaa290c6500c4d25b26,"The quality of a software system is mostly defined by its source code. Software evolves continuously, it gets modified, enhanced, and new requirements always arise. If we do not spend time periodically on improving our source code, it becomes messy and its quality will decrease inevitably. Literature tells us that we can improve the quality of our software product by regularly refactoring it. But does refactoring really increase software quality? Can it happen that a refactoring decreases the quality? Is it possible to recognize the change in quality caused by a single refactoring operation? In our paper, we seek answers to these questions in a case study of refactoring large-scale proprietary software systems. We analyzed the source code of 5 systems, and measured the quality of several revisions for a period of time. We analyzed 2 million lines of code and identified nearly 200 refactoring commits which fixed over 500 coding issues. We found that one single refactoring only makes a small change (sometimes even decreases quality), but when we do them in blocks, we can significantly increase quality, which can result not only in the local, but also in the global improvement of the code. © 2014 IEEE.",Conference paper,Final,Scopus
Szoke G.; Nagy C.; Ferenc R.; Gyimóthy T.,55803891600; 26667913000; 6603559878; 6603266536,A case study of refactoring large-scale industrial systems to efficiently improve source code quality,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8583 LNCS,PART 5,,524,540,16,16,10.1007/978-3-319-09156-3_37,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904878254&doi=10.1007%2f978-3-319-09156-3_37&partnerID=40&md5=7d5349487fc3a7d9b3f3b9ab463ba18f,"Refactoring source code has many benefits (e.g. improving maintainability, robustness and source code quality), but it takes time away from other implementation tasks, resulting in developers neglecting refactoring steps during the development process. But what happens when they know that the quality of their source code needs to be improved and they can get the extra time and money to refactor the code? What will they do? What will they consider the most important for improving source code quality? What sort of issues will they address first or last and how will they solve them? In our paper, we look for answers to these questions in a case study of refactoring large-scale industrial systems where developers participated in a project to improve the quality of their software systems. We collected empirical data of over a thousand refactoring patches for 5 systems with over 5 million lines of code in total, and we found that developers really optimized the refactoring process to significantly improve the quality of these systems. © 2014 Springer International Publishing.",Conference paper,Final,Scopus
Kolahdouz-Rahimi S.; Lano K.; Pillay S.; Troya J.; Van Gorp P.,36655800400; 57204335207; 55832222700; 55409920800; 8227708000,Evaluation of model transformation approaches for model refactoring,2014,Science of Computer Programming,85,PART A,,5,40,35,39,10.1016/j.scico.2013.07.013,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84897094918&doi=10.1016%2fj.scico.2013.07.013&partnerID=40&md5=037a6634cf829c4d190c63ace2746d24,"This paper provides a systematic evaluation framework for comparing model transformation approaches, based upon the ISO/IEC 9126-1 quality characteristics for software systems. We apply this framework to compare five transformation approaches (QVT-R, ATL, Kermeta, UML-RSDS and GrGen.NET) on a complex model refactoring case study: the amalgamation of apparent attribute clones in a class diagram. The case study highlights the problems with the specification and design of the refactoring category of model transformations, and provides a challenging example by which model transformation languages and approaches can be compared. We take into account a wide range of evaluation criteria aspects such as correctness, efficiency, flexibility, interoperability, re-usability and robustness, which have not been comprehensively covered by other comparative surveys of transformation approaches. The results show clear distinctions between the capabilities and suitabilities of different approaches to address the refactoring form of transformation problem. © 2013 Elsevier B.V.",Article,Final,Scopus
Al-Refai M.; Cazzola W.; France R.,57222159787; 6602449966; 7101667540,Using models to dynamically refactor runtime code,2014,Proceedings of the ACM Symposium on Applied Computing,,,,1108,1113,5,3,10.1145/2554850.2554954,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84905668815&doi=10.1145%2f2554850.2554954&partnerID=40&md5=f4b07c8c0f89b9aa5b55f1961d3f252c,"Modern software systems that play critical roles in society's infrastructures are often required to change at runtime so that they can continuously provide essential services in the dynamic environments they operate in. Updating open, distributed software systems at runtime is very challenging. Using runtime models as an interface for updating software at runtime can help developers manage the complexity of updating software while it is executing. To support this idea, we developed the FiGA framework that permits developers to update running software through changes made to UML models of the running software. In this paper, we address the following question: can the UML models be used to express any type of code change a developer desires? Specifically, we report our experience on applying Fowler's code refactoring catalog through model refactoring in the FiGA framework. The goal of this work is to show that the set of FiGA change operators is complete by showing that the refactorings at the source code level can be expressed as model changes in the FiGA approach. Copyright 2014 ACM.",Conference paper,Final,Scopus
Suryanarayana G.; Samarthyam G.; Sharma T.,57190844683; 55320970300; 25224153100,Refactoring for Software Design Smells: Managing Technical Debt,2014,Refactoring for Software Design Smells: Managing Technical Debt,,,,1,237,236,143,10.1016/C2013-0-23413-9,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942357945&doi=10.1016%2fC2013-0-23413-9&partnerID=40&md5=91e25968ebc01b223b2eebf726af6939,"Awareness of design smells - indicators of common design problems - helps developers or software engineers understand mistakes made while designing, what design principles were overlooked or misapplied, and what principles need to be applied properly to address those smells through refactoring. Developers and software engineers may ""know"" principles and patterns, but are not aware of the ""smells"" that exist in their design because of wrong or mis-application of principles or patterns. These smells tend to contribute heavily to technical debt - further time owed to fix projects thought to be complete - and need to be addressed via proper refactoring. Refactoring for Software Design Smells presents 25 structural design smells, their role in identifying design issues, and potential refactoring solutions. Organized across common areas of software design, each smell is presented with diagrams and examples illustrating the poor design practices and the problems that result, creating a catalog of nuggets of readily usable information that developers or engineers can apply in their projects. The authors distill their research and experience as consultants and trainers, providing insights that have been used to improve refactoring and reduce the time and costs of managing software projects. Along the way they recount anecdotes from actual projects on which the relevant smell helped address a design issue. Contains a comprehensive catalog of 25 structural design smells (organized around four fundamental design principles) that contribute to technical debt in software projects Presents a unique naming scheme for smells that helps understand the cause of a smell as well as points toward its potential refactoring Includes illustrative examples that showcase the poor design practices underlying a smell and the problems that result Covers pragmatic techniques for refactoring design smells to manage technical debt and to create and maintain high-quality software in practice Presents insightful anecdotes and case studies drawn from the trenches of real-world projects. © 2015 Elsevier Inc. All rights reserved.",Book,Final,Scopus
Rama G.M.; Komondoor R.,35614628200; 8728279600,A dynamic analysis to support object-sharing code refactorings,2014,ASE 2014 - Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering,,,,713,723,10,6,10.1145/2642937.2642992,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908615845&doi=10.1145%2f2642937.2642992&partnerID=40&md5=1d2086353565526af0f58694f845e74b,"Creation of large numbers of co-existing long-lived isomorphic objects increases the memory footprint of applications significantly. In this paper we propose a dynamic-analysis based approach that detects allocation sites that create large numbers of long-lived isomorphic objects, estimates quantitatively the memory savings to be obtained by sharing isomorphic objects created at these sites, and also checks whether certain necessary conditions for safely employing object sharing hold. We have implemented our approach as a tool, and have conducted experiments on several real-life Java benchmarks. The results from our experiments indicate that in real benchmarks a significant amount of heap memory, ranging up to 37% in some benchmarks, can be saved by employing object sharing. We have also validated the precision of estimates from our tool by comparing these with actual savings obtained upon introducing object-sharing at selected sites in the real benchmarks. © 2014 ACM.",Conference paper,Final,Scopus
Rochimah S.; Arifiani S.; Insanittaqwa V.F.,24476646200; 56766258700; 56766076000,Non-source code refactoring: A systematic literature review,2015,International Journal of Software Engineering and its Applications,9,6,,197,214,17,9,10.14257/ijseia.2015.9.6.19,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84938676282&doi=10.14257%2fijseia.2015.9.6.19&partnerID=40&md5=a75883a98f766dba9b8b68b5952c83b6,"Since software refactoring techniques were introduced, the process is commonly applied to alter the structure of source code. However, there is also increasing popularity in the topic of refactoring in other software artifacts at non-source code level. This paper provides a systematic literature review of existing studies in non-source code refactoring. We use two digital libraries as publication source, IEEExplore and Science Direct, to obtain published articles in non-source code refactoring topic published in between 2002 - 2014 with certain keywords. The 20 selected literatures then processed based on certain criteria, including the refactoring method and refactoring identification source. Then we use this information to provide categorization of non-source code refactoring activity and the advantages and disadvantages of each category. The systematic literature review performed has provided categorization of non-source code refactoring method and has shown that each method has certain advantages and disadvantages. Refactoring detection at non-source code level can be done in the software design model, source code with non-conventional detection, and other software artifacts. The methods used can be categorized as heuristic method, where the refactoring identification is done based on certain rules, and non-heuristic method, where the refactoring identification is done with a certain algoritm that explores every possibility of refactoring opportunities. The advantage of heuristic method is the speed and precision. The disadvantage of this method is the needed effort to produce the rules and the possibility of the non optimal result. The advantage of non-heuristic method is it can yield a generally more optimal result. The disadvantage of non-heuristic method is that the result depends strongly on the robustness of each algorithm. © 2015 SERSC.",Article,Final,Scopus
Chen R.; Miao H.,55903300700; 16176008900,A Selenium based approach to automatic test script generation for refactoring JavaScript code,2013,"2013 IEEE/ACIS 12th International Conference on Computer and Information Science, ICIS 2013 - Proceedings",,,6607864,341,346,5,8,10.1109/ICIS.2013.6607864,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84886493766&doi=10.1109%2fICIS.2013.6607864&partnerID=40&md5=502f84195429bfc17fe463e1f1919800,"During the development process of Web application, two essential phases are software testing and code refactoring. However, automatic testing script plays an important role in test automation. It has been a hot research topic in Web application. In order to refactor the JavaScript code of Web application more conveniently, an approach to automatic script generation from the defined test case is introduced in this paper. First, it describes the test case using customized XML format. Then, since Selenium platform supports multi-browsers testing, a method to transform XML description into test scripts based on Selenium framework is proposed as the emphasis. © 2013 IEEE.",Conference paper,Final,Scopus
Abebe M.; Yoo C.-J.,56208636200; 7201746348,"Trends, opportunities and challenges of software refactoring: A systematic literature review",2014,International Journal of Software Engineering and its Applications,8,6,,299,318,19,29,10.14257/ijseia.2014.8.6.24,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902583295&doi=10.14257%2fijseia.2014.8.6.24&partnerID=40&md5=72149ff4550669b3bb4b5bb99c9c3a1c,"Software refactoring is a technique that transforms the various types of software artifacts to improve the software internal structure without affecting the external behavior. Refactoring is commonly applied to improve the software quality after a significant amount of features are added. Researchers in the area have studied the different angles of refactoring and developed the right evidence, knowledge and skill. And they published their research findings through journals and conference papers to provide an easy access to everyone. Eventually, the knowledge accumulated in these literatures is huge, so that it needs structuring and organizing. The main purpose of this study is to extend a previously conducted study by covering more literatures and applying a systematic literature review method to increase the accuracy and validity of the study. We study a collection of literature from different electronic databases, published since 1999 to understand and extract the software refactoring knowledge through classification and summarization. The classification and summarization can reveal the research pattern, common concerns and statistics of the published papers in the last fifteen years. The extracted information should help the researchers to formulate better research topics that can solve the crucial problems in software refactoring and save the researchers effort and time. © 2014 SERSC.",Article,Final,Scopus
Mkaouer M.W.; Kessentini M.; Bechikh S.; Cinnéide M.O.,55904259300; 25653537200; 25924742700; 55890614500,A robust multi-objective approach for software refactoring under uncertainty,2014,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8636 LNCS,,,168,183,15,31,10.1007/978-3-319-09940-8_12,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84958536968&doi=10.1007%2f978-3-319-09940-8_12&partnerID=40&md5=55654884e35f538e10d6da958badaebf,"Refactoring large systems involves several sources of uncertainty related to the severity levels of code smells to be corrected and the importance of the classes in which the smells are located. Due to the dynamic nature of software development, these values cannot be accurately determined in practice, leading to refactoring sequences that lack robustness. To address this problem, we introduced a multi-objective robust model, based on NSGA-II, for the software refactoring problem that tries to find the best trade-off between quality and robustness. We evaluated our approach using six open source systems and demonstrated that it is significantly better than state-of-the-art refactoring approaches in terms of robustness in 100% of experiments based on a variety of real-world scenarios. Our suggested refactoring solutions were found to be comparable in terms of quality to those suggested by existing approaches and to carry an acceptable robustness price. Our results also revealed an interesting feature about the trade-off between quality and robustness that demonstrates the practical value of taking robustness into account in software refactoring. © 2014 Springer International Publishing Switzerland.",Conference paper,Final,Scopus
Creager R.; Whitehead M.,36674555400; 56349237700,Refactoring GBT software to support high data rate instruments using data streaming technology,2014,Proceedings of SPIE - The International Society for Optical Engineering,9152,,91520X,,,,1,10.1117/12.2055182,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84906910458&doi=10.1117%2f12.2055182&partnerID=40&md5=2bccd9e6ce1152c572fdedd9288750c6,"This paper describes the motivation, design and implementation for re-factoring the Robert C. Byrd Green Bank Telescope (GBT) monitor and control software to utilize the ZeroMQ messaging library. © 2014 SPIE.",Conference paper,Final,Scopus
Shah S.M.A.; Dietrich J.; McCartin C.,57199298346; 13411598100; 12768581600,On the automation of dependency-breaking refactorings in java,2013,"IEEE International Conference on Software Maintenance, ICSM",,,6676887,160,169,9,8,10.1109/ICSM.2013.27,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84891682700&doi=10.1109%2fICSM.2013.27&partnerID=40&md5=068e2b582b5f998a65ceda688666bf82,"The architecture and design of object-oriented systems is often described in terms of dependencies between program artefacts like classes, packages and libraries. In particular, there are many heuristics that mandate that certain dependencies should be avoided, and there are increasingly popular frameworks that focus on actively managed dependencies between artefacts, such as the Spring framework and the OSGi dynamic module system. However, empirical studies have shown that many real-world Java programs are riddled with dependency related problems. The question arises whether it is possible to automatically refurbish Java programs by removing unwanted dependencies without affecting the functionality of the program. We present an algorithm and a proof-of-concept implementation that does this. Our approach uses several refactorings: move class, type generalisation, service locator, and in lining and is validated on the Qualitas Corpus set of Java programs. © 2013 IEEE.",Conference paper,Final,Scopus
Mancuso R.; Dudko R.; Caccamo M.,55812854400; 55812080300; 7003738186,Light-PREM: Automated software refactoring for predictable execution on COTS embedded systems,2014,RTCSA 2014 - 20th IEEE International Conference on Embedded and Real-Time Computing Systems and Applications,,,6910515,,,,22,10.1109/RTCSA.2014.6910515,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908608912&doi=10.1109%2fRTCSA.2014.6910515&partnerID=40&md5=159b088a2f19282f6bb6ccc51a47e459,"As real-time embedded systems become more complex, there is the need to build them using high performance commercial off-The-shelf (COTS) components. However, tasks can exhibit hard to predict worst case execution times (WCET) when executing on commodity hardware, due to contention among shared physical resources. Past work has introduced the PRedictable Execution Model (PREM) [1] to solve this issue, but unfortunately, the time required to manually refactor existing code according to this model is too high. Light-PREM proposes a novel technique that automates the refactoring process needed to convert legacy software applications to PREM-compliant code. The advantage of Light-PREM is twofold. On one side, it makes the adoption of PREM more attractive from an industrial point of view, because it significantly reduces the amount of work that is needed to generate PREM-compliant code. On the other hand, the proposed methodology is general enough to be used with any embedded software design. Experimental results show that Light-PREM significantly improves the predictability of real-time applications without requiring software engineers to gain a deep understanding about software memory usage. © 2014 IEEE.",Conference paper,Final,Scopus
Pan W.; Li B.; Jiang B.; Liu K.,35230163600; 55628528674; 57193331129; 57197928319,Recode: Software package refactoring via community detection in bipartite software networks,2014,Advances in Complex Systems,17,8-Jul,1450006,,,,13,10.1142/S0219525914500064,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84929958446&doi=10.1142%2fS0219525914500064&partnerID=40&md5=e04a5bd89078e20beb059cde26f3a356,"It is an intrinsic property of real-world software to evolve, which is usually accompanied by the increase of software complexity and deterioration of software quality. So successful software has to be reconditioned from time to time. Though many refactoring approaches have been proposed, only a few of them are performed at the package level. In this paper, we present a novel approach to refactor the package structure of object-oriented (OO) software. It uses weighted bipartite software networks to represent classes, packages, and their dependencies; it proposes a guidance community detection algorithm (GUIDA) to obtain the optimized package structure; and it finally provides a list of classes as refactoring candidates by comparing the optimized package structure with the real package structure. Through a set of experiments we have shown that the proposed approach is able to identify a majority of classes that experts recognize as refactoring candidates, and the benefits of our approach are illustrated in comparison with other two approaches. © 2014 World Scientific Publishing Company.",Article,Final,Scopus
França J.M.S.; Dos Santos C.A.R.; De Oliveira K.S.; Soares M.S.,55351476400; 55907549800; 55907695400; 55804425900,An empirical evaluation of refactoring crosscutting concerns into aspects using software metrics,2013,"Proceedings of the 2013 10th International Conference on Information Technology: New Generations, ITNG 2013",,,6614385,674,679,5,2,10.1109/ITNG.2013.104,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84886648265&doi=10.1109%2fITNG.2013.104&partnerID=40&md5=a4b9f5e5fe13f7156bb4964b9d951b10,"Code scattering and code tangling affect software development in many ways, including poor traceability of requirements, low productivity, poor overall quality and increased efforts for software maintenance. One proposed solution to solve these issues is to use a specific software construction known as aspect. Aspect-oriented programming (AOP) has been widely studied since its introduction with the promise of improving modularization by addressing crosscutting concerns. Few studies on empirical evaluation of the benefits of aspect-oriented paradigm were published. Results presented in these studies are frequently subjective, and some studies are non-conclusive. In addition, these studies are based on the implementation of only one or two crosscutting concerns into aspects, and the evaluation is based on few software metrics. In this article, the evaluation of AOP implementation through software metrics is proposed. The main idea is to implement crosscutting concerns as aspects, with focus on those that were not given properly attention in the literature. Two softwares were used as case studies. © 2013 IEEE.",Conference paper,Final,Scopus
Veerappa V.; Harrison R.,37056486800; 57200948126,An empirical validation of coupling metrics using automated refactoring,2013,International Symposium on Empirical Software Engineering and Measurement,,,6681364,271,274,3,9,10.1109/ESEM.2013.37,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893293391&doi=10.1109%2fESEM.2013.37&partnerID=40&md5=6f8293644a783e4415a8780bf3dd0274,The validation of software metrics has received much interest over the years due to a desire to promote metrics which are both well-founded theoretically and have also been shown empirically to reflect our intuition and be practically useful. In this paper we describe how we used automatic refactoring to investigate the changes which occur to a number of metrics as software evolves. We use the concept of software volatility to quantify our comparison of the metrics. © 2013 IEEE.,Conference paper,Final,Scopus
Soares G.; Gheyi R.; Massoni T.,36132146800; 8365747700; 8327557600,Automated behavioral testing of refactoring engines,2013,IEEE Transactions on Software Engineering,39,2,6175911,147,162,15,93,10.1109/TSE.2012.19,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84873300547&doi=10.1109%2fTSE.2012.19&partnerID=40&md5=a680a7cbb922aa0fc52cd2a3f889f7bd,"Refactoring is a transformation that preserves the external behavior of a program and improves its internal quality. Usually, compilation errors and behavioral changes are avoided by preconditions determined for each refactoring transformation. However, to formally define these preconditions and transfer them to program checks is a rather complex task. In practice, refactoring engine developers commonly implement refactorings in an ad hoc manner since no guidelines are available for evaluating the correctness of refactoring implementations. As a result, even mainstream refactoring engines contain critical bugs. We present a technique to test Java refactoring engines. It automates test input generation by using a Java program generator that exhaustively generates programs for a given scope of Java declarations. The refactoring under test is applied to each generated program. The technique uses SafeRefactor, a tool for detecting behavioral changes, as an oracle to evaluate the correctness of these transformations. Finally, the technique classifies the failing transformations by the kind of behavioral change or compilation error introduced by them. We have evaluated this technique by testing 29 refactorings in Eclipse JDT, NetBeans, and the JastAdd Refactoring Tools. We analyzed 153,444 transformations, and identified 57 bugs related to compilation errors, and 63 bugs related to behavioral changes. © 1976-2012 IEEE.",Article,Final,Scopus
Takizawa H.; Egawa R.; Takahashi D.; Suda R.,7201843647; 6602982977; 8573002100; 7003971115,HPC refactoring with hierarchical abstractions to help software evolution,2013,"Sustained Simulation Performance 2012 - Proceedings of the Joint Workshop on High Performance Computing on Vector Systems, and Workshop on Sustained Simulation Performance",,,,27,33,6,0,10.1007/978-3-642-32454-3_3,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84896631621&doi=10.1007%2f978-3-642-32454-3_3&partnerID=40&md5=e20cda18305fad6d26c4d946d3de1f35,"This article briefly introduces the concept of our new research project, JST CREST ""An Evolutionary Approach to Construction of a Software Development Environment for Massively-Parallel Computing Systems."" Since high-performance computing system architectures are going to change drastically, existing application programs will need to evolve for adapting to the new-generation systems. Motivated by this, our project will explore an effective methodology to support the programming for software evolution of valuable existing applications, and also develop a programming framework to bridge the gap between system generations and thereby to encourage migration of existing applications to the new systems. The programming framework will provide abstractions of complicated system configurations at multiple levels, and refactoring tools to help evolving applications to use the abstractions. © Springer-Verlag Berlin Heidelberg 2013.",Conference paper,Final,Scopus
Fördos V.; Tóth M.,56369038600; 26422511300,Identifying code clones with refactorErl,2013,"13th Symposium on Programming Languages and Software Tools, SPLST 2013 - Proceedings",,,,31,45,14,4,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84909981874&partnerID=40&md5=e7a13f4feebd8ce7482f59d5009ce7ed,"Code clones, the results of ""copy paste programming"", have a negative impact on software maintenance. Therefore several tools and techniques have been developed to identify them in the source code. However most of them concentrate on imperative, well known languages. In this paper we give an AST/metric based clone detection algorithm for the functional programming language Erlang and evaluate it on an open source project.",Conference paper,Final,Scopus
Põld J.; Robal T.; Kalja A.,53464096400; 21743794200; 21742615900,On proving the concept of an ontology aided software refactoring tool,2013,Frontiers in Artificial Intelligence and Applications,249,,,84,94,10,2,10.3233/978-1-61499-161-8-84,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84873584579&doi=10.3233%2f978-1-61499-161-8-84&partnerID=40&md5=a3d8f44facc266eb7b6c68fe278d010f,"Through years more and more software is produced. The quality of software architecture however has an important role in systems exploitation, as it determines the maintainability and extensibility of an application. Recently more emphasis is put on quality of the design, so that new features can be added with ease. To preserve code readability and extensibility, software architecture must be refactored from time to time to cope with the modifications. Nevertheless, reviewing the whole source code is time consuming and does not return any surplus, thus it is often skipped, causing the software architecture to decay in time over several modifications and making it harder to add new functionality in the future. An automated method of recognizing 'bad' code would help to solve some of the issues. In this article the authors propose a concept of a refactoring tool, which uses ontology to find 'smelly' design and tackle the aforementioned problems. Several aspects of the tool are discussed-how it works and how it can be used to improve the software architecture, thus augment the quality. © 2013 The authors and IOS Press. All rights reserved.",Conference paper,Final,Scopus
Xiao F.; Li Y.; Zhu X.; Fan D.,7201709493; 57192524469; 55696712400; 50961218400,A software refactoring paradigm for controling changes on control system,2013,Applied Mechanics and Materials,241-244,,,2587,2591,4,0,10.4028/www.scientific.net/AMM.241-244.2587,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84872955808&doi=10.4028%2fwww.scientific.net%2fAMM.241-244.2587&partnerID=40&md5=909b603cfbe1824bd9ccf99b32667b08,"In traditional, software implementation for requirement changes brings big effort on legacy architecture, and may decrease the readability, increase the possibility of error, and hard to maintain for software. So, software refactoring needs to be involved to solve the issue. A successful refactoring practice is presented in this paper to solve above issue met in a control application system supporting different boot process. It has been proved that the flexibility and extendibility are improved greatly than the original architecture. Furthermore, by encapsulating more details in the class and specified function, it reduces the complexity of interface. As a result, the risk of interface error is decreased, and the software quality is improved accordingly. © (2013) Trans Tech Publications, Switzerland.",Conference paper,Final,Scopus
Savidis A.; Stephanidis C.,6603471887; 7004072937,Software refactoring process to accommodate user-interface adaptivity in existing applications,2013,Interacting with Computers,25,6,,461,484,23,0,10.1093/iwc/iwt020,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885912873&doi=10.1093%2fiwc%2fiwt020&partnerID=40&md5=85ac9d05b4f9fe211758a7141f827cf1,"Adaptive user-interfaces are capable of: (a) composing themselves at runtime according to a given deployment profile typically encompassing user and usage-context information and (b) possibly dropping user-interface components and activate better alternatives in their place in response to dynamic profile modifications. While adaptive behavior increasingly gains interest for a wide range of software products and services, its support is very demanding requiring adoption of user-interface architectural patterns from the very early software design phases. While previous research addressed the issue of engineering adaptive interactive applications right from scratch, there is an important methodological gap as we lack processes for the systematic evolution of existing non-adaptive applications to adaptive ones.We present a stepwise transformation process of the user-interface source code by incrementally upgrading all relevant implementation structures towards user-interface adaptivity. Because all transformation actions have been chosen to be standard refactorings the conduct of the process is well-defined while adoption preserves the original application architecture and quality of the source code. © The Author 2013. Published by Oxford University Press on behalf of The British Computer Society. All rights reserved.",Article,Final,Scopus
Fernández-Ropero M.; Pérez-Castillo R.; Piattini M.,54683892800; 34977424500; 7004203473,Graph-based business process model refactoring,2013,CEUR Workshop Proceedings,1027,,,16,30,14,5,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84922229542&partnerID=40&md5=d3365f49e1391c00cb726cd21cc23a40,"Companies are ever more interested in process-oriented organizational designs due to the competitive advantages they can achieve. Companies must therefore be able to manage their business process models and deal with quality assurance concerns, especially when business process models are mined by reverse engineering (e.g.from information systems) since it has harmful effects on the quality. For example, non-relevant and fine-grained elements or incomplete processes can be obtained. Refactoring techniques have become a widely-used method to mitigate those effects, changing the internal structure of business process models without altering its external behavior. Business process models can be transformed into graph structures since it has been proved as a more efficient way to manage information. This work presents IBUPROFEN, a set of graph-based refactoring algorithms to improve the quality of business process models. This paper demonstrates its feasibility by conducting a case study using a set of industrial business process models.",Conference paper,Final,Scopus
Qian J.; Chen L.; Xu B.W.,15830326000; 57189042207; 7404589262,Finding shrink critical section refactoring opportunities for the evolution of concurrent code in trustworthy software,2013,Science China Information Sciences,56,1,,1,20,19,4,10.1007/s11432-012-4743-z,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84872787167&doi=10.1007%2fs11432-012-4743-z&partnerID=40&md5=7f094d374796ea2302a8e40a46c96112,"With the keyword synchronized, Java provides a simple but often over-used synchronization mechanism. Many programmers tend to use a big synchronized section to protect a large block of statements even if many of them are unnecessarily synchronized. Such coarse-gained synchronizations may increase lock contention and thereby decrease the performance of a program, especially in a multi-core environment. The decrease in performance may affect the quality of service provided by the software and hence make the software less trustworthy. To ensure trustworthiness, this paper proposes a source-code level refactoring approach to optimize coarse-gained synchronizations. It exploits dependence and escape information to search for shrinkable critical sections and can transform them into smaller ones automatically. The approach can be used to gradually evolve concurrent code for better quality. In the approach, to achieve more optimizations, we develop a new escape analysis, named escape state analysis, which can not only tell us whether an object finally escapes but also determine the escape states of objects at each program site. With such an analysis, more refactoring opportunities can be found. We build a tool and test our refactoring approach on several benchmark programs. The results show that the proposed approach does make effective refactoring suggestions for the users. © 2013 Science China Press and Springer-Verlag Berlin Heidelberg.",Article,Final,Scopus
Kannangara S.H.; Wijayanayake W.M.J.I.,57211169640; 6507962345,Impact of refactoring on external code quality improvement: An empirical evaluation,2013,"International Conference on Advances in ICT for Emerging Regions, ICTer 2013 - Conference Proceedings",,,6761156,60,67,7,10,10.1109/ICTer.2013.6761156,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84898438640&doi=10.1109%2fICTer.2013.6761156&partnerID=40&md5=52098514e5ccfc255b7474e060c264b2,"Refactoring is the process of improving the design of the existing code by changing its internal structure without affecting its external behaviour, with the main aims of improving the quality of software product. Therefore, there is belief that refactoring improves quality factors such as understandability, flexibility, and reusability. Moreover, there are also claims that refactoring yields higher development productivity. However, there is limited empirical evidence to support such assumptions. The objective of this study is to validate/invalidate the claims that refactoring improves software quality. Experimental research approach was used to achieve the objective and ten selected refactoring techniques were used for the analysis. The impact of each refactoring technique was assessed based on external measures namely; analysability, changeability, time behaviour and resource utilization. After analysing the experimental results, among the tested ten refactoring techniques, ""Replace Conditional with Polymorphism"" ranked in the highest as having high percentage of improvement in code quality. ""Introduce Null Object"" was ranked as worst which is having highest percentage of deteriorate of code quality. © 2013 IEEE.",Conference paper,Final,Scopus
Soares G.; Gheyi R.; Murphy-Hill E.; Johnson B.,36132146800; 8365747700; 16307910100; 55321465400,Comparing approaches to analyze refactoring activity on software repositories,2013,Journal of Systems and Software,86,4,,1006,1022,16,40,10.1016/j.jss.2012.10.040,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84875265413&doi=10.1016%2fj.jss.2012.10.040&partnerID=40&md5=8666baf1f3fba0c42464ffd156032efc,"Some approaches have been used to investigate evidence on how developers refactor their code, whether refactorings activities may decrease the number of bugs, or improve developers' productivity. However, there are some contradicting evidence in previous studies. For instance, some investigations found evidence that if the number of refactoring changes increases in the preceding time period the number of defects decreases, different from other studies. They have used different approaches to evaluate refactoring activities. Some of them identify committed behavior-preserving transformations in software repositories by using manual analysis, commit messages, or dynamic analysis. Others focus on identifying which refactorings are applied between two programs by using manual inspection or static analysis. In this work, we compare three different approaches based on manual analysis, commit message (Ratzinger's approach) and dynamic analysis (SafeRefactor's approach) to detect whether a pair of versions determines a refactoring, in terms of behavioral preservation. Additionally, we compare two approaches (manual analysis and Ref-Finder) to identify which refactorings are performed in each pair of versions. We perform both comparisons by evaluating their accuracy, precision, and recall in a randomly selected sample of 40 pairs of versions of JHotDraw, and 20 pairs of versions of Apache Common Collections. While the manual analysis presents the best results in both comparisons, it is not as scalable as the automated approaches. Ratzinger's approach is simple and fast, but presents a low recall; differently, SafeRefactor is able to detect most applied refactorings, although limitations in its test generation backend results for some kinds of subjects in low precision values. Ref-Finder presented a low precision and recall in our evaluation. © 2012 Elsevier Inc.",Conference paper,Final,Scopus
Pan W.-F.; Jiang B.; Li B.,35230163600; 57193331129; 55628528674,Refactoring software packages via community detection in complex software networks,2013,International Journal of Automation and Computing,10,2,,157,166,9,24,10.1007/s11633-013-0708-y,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84876176478&doi=10.1007%2fs11633-013-0708-y&partnerID=40&md5=bfe94e347f4bd4174c3a11fb40d41500,"An intrinsic property of software in a real-world environment is its need to evolve, which is usually accompanied by the increase of software complexity and deterioration of software quality, making software maintenance a tough problem. Refactoring is regarded as an effective way to address this problem. Many refactoring approaches at the method and class level have been proposed. But the research on software refactoring at the package level is very little. This paper presents a novel approach to refactor the package structures of object oriented software. It uses software networks to represent classes and their dependencies. It proposes a constrained community detection algorithm to obtain the optimized community structures in software networks, which also correspond to the optimized package structures. And it finally provides a list of classes as refactoring candidates by comparing the optimized package structures with the real package structures. The empirical evaluation of the proposed approach has been performed in two open source Java projects, and the benefits of our approach are illustrated in comparison with the other three approaches. © 2013 Institute of Automation, Chinese Academy of Sciences and Springer-Verlag Berlin Heidelberg.",Article,Final,Scopus
Khanam Z.; Rizvi S.A.M.,57203383209; 55601665100,An evaluative study of software refactoring in procedural programming,2013,Lecture Notes in Engineering and Computer Science,1,,,102,107,5,0,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84903468476&partnerID=40&md5=524b655887f4f35df80fec741fbb5da8,"Too many organizations suffer from superfluous, disproportionate, difficult-to-extend software because of the lack in maintenance effort and ignoring the fact that continuous refactoring provides a competitive advantage. Several refactoring have been proposed for object-oriented languages, but there are few related works focusing on procedural programming. In this paper, an assessment is provided of selected literatures which relate to refactoring of procedural languages, and it also contributes to highlighting new concepts and requirements for developing new refactoring techniques for C that may eventually benefit other procedural languages also. We have studied the refactorings performed on 3 procedural languages that are Fortran, Cobol and C to analyze the pattern of refactorings followed in these languages and assess their cumulative effect in different applications. We offer a few refactoring capabilities that may improve the existing refactorings for these languages by our contribution to refactoring that characterizes of a new aspect oriented programming style.",Conference paper,Final,Scopus
Negara S.; Chen N.; Vakilian M.; Johnson R.E.; Dig D.,25825481400; 36781524200; 24173759600; 35577606500; 13404654100,A comparative study of manual and automated refactorings,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),7920 LNCS,,,552,576,24,101,10.1007/978-3-642-39038-8_23,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84880014919&doi=10.1007%2f978-3-642-39038-8_23&partnerID=40&md5=df32c613600343179001bf8ddabe3e7b,"Despite the enormous success that manual and automated refactoring has enjoyed during the last decade, we know little about the practice of refactoring. Understanding the refactoring practice is important for developers, refactoring tool builders, and researchers. Many previous approaches to study refactorings are based on comparing code snapshots, which is imprecise, incomplete, and does not allow answering research questions that involve time or compare manual and automated refactoring. We present the first extended empirical study that considers both manual and automated refactoring. This study is enabled by our algorithm, which infers refactorings from continuous changes. We implemented and applied this algorithm to the code evolution data collected from 23 developers working in their natural environment for 1,520 hours. Using a corpus of 5,371 refactorings, we reveal several new facts about manual and automated refactorings. For example, more than half of the refactorings were performed manually. The popularity of automated and manual refactorings differs. More than one third of the refactorings performed by developers are clustered in time. On average, 30% of the performed refactorings do not reach the Version Control System. © 2013 Springer-Verlag Berlin Heidelberg.",Conference paper,Final,Scopus
Vakilian M.; Chen N.; Zilouchian Moghaddam R.; Negara S.; Johnson R.E.,24173759600; 36781524200; 39061768200; 25825481400; 35577606500,A compositional paradigm of automating refactorings,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),7920 LNCS,,,527,551,24,23,10.1007/978-3-642-39038-8_22,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84880003230&doi=10.1007%2f978-3-642-39038-8_22&partnerID=40&md5=e839142dd1ecca9b7644950de169c2a5,"Recent studies suggest that programmers greatly underuse refactoring tools, especially for complex refactorings. Complex refactorings tend to be tedious and error-prone to perform by hand. To promote the use of refactoring tools for complex changes, we propose a new paradigm for automating refactorings called compositional refactoring. The key idea is to perform small, predictable changes using a tool and manually compose them into complex changes. This paradigm trades off some level of automation by higher predictability and control. We show that this paradigm is natural, because our analysis of programmers' use of the Eclipse refactoring tool in the wild shows that they frequently batch and compose automated refactorings. We then show that programmers are receptive to this new paradigm through a survey of 100 respondents. Finally, we show that the compositional paradigm is effective through a controlled study of 13 professional programmers, comparing this paradigm to the existing wizard-based one. © 2013 Springer-Verlag Berlin Heidelberg.",Conference paper,Final,Scopus
Wongpiang R.; Muenchaisri P.,56266623000; 6505797100,Selecting sequence of refactoring techniques usage for code changing using greedy algorithm,2013,ICEIEC 2013 - Proceedings of 2013 IEEE 4th International Conference on Electronics Information and Emergency Communication,,,6835477,160,164,4,8,10.1109/ICEIEC.2013.6835477,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904180226&doi=10.1109%2fICEIEC.2013.6835477&partnerID=40&md5=a14e73c7f3aab728a562c83773c210e9,"Refactoring is the process of changing the internal structure of software but it preserves external behavior of software. To improve software maintainability, we may apply several refactoring techniques to source code. Applying different sequence of refactoring techniques to different parts of source code results in different code changes and different level of software maintainability. We propose an approach for selecting sequence of refactoring techniques usage for code changing using Greedy Algorithm. To get optimal software maintainability, we create possible sequences of refactoring techniques usage and apply each refactoring technique to source code. Greedy Algorithm is used to separate the optimal sequence of refactoring techniques usage from possible sequences of refactoring techniques. We evaluate the approach with source code containing Long Method, Large Class and Feature Envy bad smells by comparing the changed source code result between applying the approach and without applying sequence of refactoring techniques usage. The compared results show that the changed source code by applying our approach can improve software maintainability better than the changed source code without sequencing refactoring techniques usage. © 2013 IEEE.",Conference paper,Final,Scopus
Sun W.; France R.B.; Ray I.,35249717300; 7101667540; 58830606300,Analyzing behavioral refactoring of class models,2013,CEUR Workshop Proceedings,1090,,,70,79,9,3,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84923645048&partnerID=40&md5=8c05ea6ad1ec83ea9cede7741422f691,Software modelers refactor their design models to improve design quality while preserving essential functional properties. Tools that allow modelers to check whether their refactorings preserve specified essential behaviors are needed to support rigorous model evolution. In this paper we describe a rigorous approach to analyzing design model refactorings that involve changes to operation specifications expressed in the Object Constraint Language (OCL). The analysis checks whether the refactored model preserves the essential behavior of changed operations in a source design model. A refactoring example involving the Abstract Factory design pattern is used in the paper to illustrate the approach. © 2013 for the individual papers by the papers' authors.,Conference paper,Final,Scopus
Burger S.; Hummel O.,36727141500; 36911317300,On the effects of refactoring in software metrics; [Über die Auswirkungen von Refactoring auf Softwaremetriken],2013,"Lecture Notes in Informatics (LNI), Proceedings - Series of the Gesellschaft fur Informatik (GI)",P-213,,,113,126,13,1,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84922716475&partnerID=40&md5=f0a70e6f72f8d029d1cd8facf627df5b,[No abstract available],Conference paper,Final,Scopus
Pan W.; Jiang B.; Xu Y.,35230163600; 57193331129; 55891164400,Refactoring packages of object-oriented software using genetic algorithm based community detection technique,2013,International Journal of Computer Applications in Technology,48,3,,185,194,9,15,10.1504/IJCAT.2013.056914,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885895268&doi=10.1504%2fIJCAT.2013.056914&partnerID=40&md5=3a1c9a486a721ef00a705c2be8932028,"Refactoring is regarded as an effective way to address the software quality deterioration problem. Although many refactoring approaches have been proposed, there is little work at the package level. This paper proposes to use the community detection technique to refactor the packages of object-oriented software. It uses software class network to represent classes and their dependencies, proposes a genetic algorithm based community detection algorithm to obtain the optimised package structures, and finally provides a list of classes that should be moved by comparing the optimised package structures with the real package structures. The empirical evaluation of the proposed approach has been performed in two open source Java projects, and the benefits of our approach are illustrated in comparison with the only one software refactoring approach at the package level (viz. adaptive k-nearest neighbour algorithm), and other five community detection algorithms used in the complex networks literature. © 2013 Inderscience Enterprises Ltd.",Article,Final,Scopus
Arcelli D.; Cortellessa V.; Di Ruscio D.,55317293800; 6603764364; 57201633392,Applying model differences to automate performance-driven refactoring of software models,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),8168 LNCS,,,312,324,12,6,10.1007/978-3-642-40725-3_24,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84884865185&doi=10.1007%2f978-3-642-40725-3_24&partnerID=40&md5=7eb7449dceaf2d008e1ae7b34cb4608e,"Identifying and removing the causes of poor performance in software systems are complex problems, and these issues are usually tackled after software deployment only with human-based means. Performance antipatterns can be used to harness these problems since they capture design patterns that are known leading to performance problems, and they suggest refactoring actions that can solve the problems. This paper introduces an approach to automate software model refactoring based on performance antipatterns. A Role-Based Modeling Language is used to model antipattern problems as Source Role Models (SRMs), and antipattern solutions as Target Role Models (TRMs). Each (SRM, TRM) pair is represented by a difference model that encodes refactoring actions to be operated on a software model to remove the corresponding antipattern. Differences are applied to software models through a model transformation automatically generated by a higher-order transformation. The approach is shown at work on an example in the e-commerce domain. © 2013 Springer-Verlag Berlin Heidelberg.",Conference paper,Final,Scopus
Arcelli D.; Cortellessa V.; Trubiani C.,55317293800; 6603764364; 24781277400,Experimenting the influence of numerical thresholds on model-based detection and refactoring of performance antipatterns,2013,Electronic Communications of the EASST,59,,,1,30,29,14,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921052834&partnerID=40&md5=013354e3af50f9ecc86cb8e7f27be807,"Performance antipatterns are well-known bad design practices that lead to software products suffering from poor performance. A number of performance antipatterns has been defined and classified and refactoring actions have also been suggested to remove them. In the last few years, we have dedicated some effort to the detection and refactoring of performance antipatterns in software models. A specific characteristic of performance antipatterns is that they contain numerical parameters that may represent thresholds referring to either performance indices (e.g., a device utilization) or design features (e.g., number of interface operations of a software component). In this paper, we analyze the influence of such thresholds on the capability of detecting and refactoring performance antipatterns. In particular, (i) we analyze how a set of detected antipatterns may change while varying the threshold values and (ii) we discuss the influence of thresholds on the complexity of refactoring actions. With the help of a leading example, we quantify the influence using precision and recall metrics.",Article,Final,Scopus
Stal M.,6603593719,Refactoring Software Architectures,2013,Agile Software Architecture: Aligning Agile Processes and Software Architectures,,,,63,82,19,10,10.1016/B978-0-12-407772-0.00003-4,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902433457&doi=10.1016%2fB978-0-12-407772-0.00003-4&partnerID=40&md5=1e8a16a5e74d7bea83de060fca2bed0f,"This chapter describes how to systematically prevent software architecture erosion by applying refactoring techniques. Software architecture modifications are common rather than the exception in software development. Modifications come in different flavors, such as redefining or adding requirements, changing infrastructure and technology, or causing changes by bugs and incorrect decisions. But no matter where these changes originate, they need special attention from software architects. Otherwise, if software architects merely focus on adding new features-(changes or extensions that by themselves might not be adequate), design erosion will be the final result. In a systematic approach, software architects evaluate the existing software design before adding new artifacts or changing existing ones. Whenever they identify architecture problems, they immediately resolve architectural issues, thus assuring high quality and sustainability. Software architecture refactoring enables such iterative architecture improvement. It consists of indentifying problems, applying the right refactorings, and testing the results. Architecture refactoring is often combined with code refactoring activities to add the best value. Refactoring patterns offer proven solutions for recurring architectural problems, hence providing a toolset to software engineers. © 2014 Elsevier Inc. All rights reserved.",Book chapter,Final,Scopus
Gligoric M.; Behrang F.; Li Y.; Overbey J.; Hafiz M.; Marinov D.,26221765900; 55789905000; 57191443173; 26768136300; 15063972900; 8730036800,Systematic testing of refactoring engines on real software projects,2013,Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),7920 LNCS,,,629,653,24,28,10.1007/978-3-642-39038-8_26,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84880017980&doi=10.1007%2f978-3-642-39038-8_26&partnerID=40&md5=e146df7259fea6685834c791355d5e71,"Testing refactoring engines is a challenging problem that has gained recent attention in research. Several techniques were proposed to automate generation of programs used as test inputs and to help developers in inspecting test failures. However, these techniques can require substantial effort for writing test generators or finding unique bugs, and do not provide an estimate of how reliable refactoring engines are for refactoring tasks on real software projects. This paper evaluates an end-to-end approach for testing refactoring engines and estimating their reliability by (1) systematically applying refactorings at a large number of places in well-known, open-source projects and collecting failures during refactoring or while trying to compile the refactored projects, (2) clustering failures into a small, manageable number of failure groups, and (3) inspecting failures to identify non-duplicate bugs. By using this approach on the Eclipse refactoring engines for Java and C, we already found and reported 77 new bugs for Java and 43 for C. Despite the seemingly large numbers of bugs, we found these refactoring engines to be relatively reliable, with only 1.4% of refactoring tasks failing for Java and 7.5% for C. © 2013 Springer-Verlag Berlin Heidelberg.",Conference paper,Final,Scopus
Jindal S.; Khurana G.,56122590800; 56230204500,The statistical analysis of source-code to determine the refactoring opportunities factor (ROF) using a machine learning algorithm,2013,IET Conference Publications,2013,645 CP,,396,403,7,1,10.1049/cp.2013.2244,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84903278199&doi=10.1049%2fcp.2013.2244&partnerID=40&md5=0b7b696341ef853f80ec6733d9040804,"In this research, we have proposed refactoring as a measured object with the help of a measurement scale. We have proposed a case study in which we have studied three different projects, obtained from a company for which an ordinal scale is prepared. The UML diagrams are drawn from which the values of different source-code metrics, those are helpful to determine the quality of the code, are calculated. A refactoring opportunities factor (ROF) has been introduced which determine the correct perspective of refactoring. Each UML diagram is assigned a ROF based on the values of source-code metrics. A machine learning algorithm is developed, based on the Naive Bayes Algorithm, which takes dataset prepared by studying 3 projects, as an input and determines which of these has good and bad opportunities for refactoring. The accuracy (precision and recall) of the machine learning classifier validates the refactoring opportunities factor.",Conference paper,Final,Scopus
Schulze S.; Richers O.; Schaefer I.,35225243700; 55646313100; 55152409100,Refactoring delta-oriented software product lines,2013,AOSD 2013 - Proceedings of the 2013 ACM on Aspect-Oriented Software Development,,,,73,84,11,36,10.1145/2451436.2451446,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84875971216&doi=10.1145%2f2451436.2451446&partnerID=40&md5=810824f207bc3e23e20cb4271344310e,"Delta-oriented programming (DOP) is an implementation approach to develop software product lines (SPL). Deltaoriented SPLs evolve over time due to new or changed requirements and need to be maintained to retain their value. Refactorings have been proposed as behavior-preserving program transformations that improve the design and structure of (object-oriented) software systems. However, there is a lack of refactoring support for software product lines since refactoring of SPLs is more complex than of single systems. For refactoring SPLs, we have to preserve the behavior of probably thousands of programs instead of only one. In this paper, we address the refactoring of software product lines by presenting a catalogue of refactorings for delta-oriented SPLs. Additionally, we propose code smells to guide developers to potential refactoring opportunities. We show how code smells can aid the identification of SPL refactorings and how these refactorings improve the evolvability and maintainability of delta-oriented SPLs. Copyright © 2013 ACM.",Conference paper,Final,Scopus
Mayer P.; Schroeder A.,22980557600; 8902630000,Towards automated cross-language refactorings between Java and DSLs used by Java frameworks,2013,WRT 2013 - Proceedings of the 2013 ACM Workshop on Refactoring Tools,,,,5,8,3,10,10.1145/2541348.2541350,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84892910987&doi=10.1145%2f2541348.2541350&partnerID=40&md5=6960e6868b23d55234b141de3b01c8ed,"Today, software applications are usually not written in just one programming language. In many cases, a general-purpose language such as Java is combined with multiple domain-specific languages (DSLs) for diverse purposes such as system configuration, UI description, or database querying. The artifacts defined in those different languages reference each other, often by name; in most cases these references are essential for the functionality of the overall system. This introduces problems if an artifact is refactored in any single language, since most current refactoring tools are not aware of language-external uses of the artifact. What is therefore needed is extended refactoring support across language boundaries. In this work, we explore the area of cross-language linking and refactoring, and present an approach and tool which we evaluate in a systematic fashion using automated renaming and unit testing on an open-source case study. Copyright is held by the owner/author(s).",Conference paper,Final,Scopus
Feldthaus A.; Møller A.,54395199400; 57195116933,Semi-automatic rename refactoring for JavaScript,2013,ACM SIGPLAN Notices,48,10,,323,337,14,15,10.1145/2544173.2509520,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84888778938&doi=10.1145%2f2544173.2509520&partnerID=40&md5=42c3c3290ab6fec3d3c39fd84d9b2c6f,"Modern IDEs support automated refactoring for many programming languages, but support for JavaScript is still primitive. To perform renaming, which is one of the fundamental refactorings, there is often no practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives have been developed, they are limited by wholeprogram assumptions and poor scalability. We propose a technique for semi-automatic refactoring for JavaScript, with a focus on renaming. Unlike traditional refactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction with the programmer. With this pragmatic approach, we can provide scalable and effective refactoring support for realworld code, including libraries and incomplete applications. Through a series of experiments that estimate how much manual effort our technique demands from the programmer, we show that our approach is a useful improvement compared to search-and-replace tools. Copyright © 2013 ACM. Copyright © 2013 ACM.",Article,Final,Scopus
Pérez-Castillo R.; Fernández-Ropero M.; Piattini M.; Caivano D.,34977424500; 54683892800; 7004203473; 6603243250,How does refactoring affect understandability of business process models?,2013,"Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE",2013-January,January,,644,649,5,4,,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84937720394&partnerID=40&md5=bf3a97e6aab38c50c60d9f8585c7a2ad,"Business process refactoring techniques have been often provided for business process manually modeled. Unfortunately, no many refactoring techniques lie in reversing business process models obtained from existing information systems, which need, even more, to be refactored. Hence, there is no strong empirical evidence on how the understandability of business process models is affected by this kind of refactoring techniques. This paper is aimed at providing a case study with two real-life information systems, from which 40 business process models were obtained by reverse engineering. The empirical study attempts to quantify the effect to the understandability of the order of refactoring operators as well as the previous refactoring actions. The main implication of the obtained results are a set of rules that may be used to optimize the understandability by means of the prioritization and configuration of refactoring techniques specially developed for business process models retrieved by reverse engineering. Copyright © 2013 by Knowledge Systems Institute Graduate School.",Conference paper,Final,Scopus
Orchard D.; Rice A.,25628491000; 14036315700,Upgrading Fortran source code using automatic refactoring,2013,WRT 2013 - Proceedings of the 2013 ACM Workshop on Refactoring Tools,,,,29,32,3,9,10.1145/2541348.2541356,https://www.scopus.com/inward/record.uri?eid=2-s2.0-84892928446&doi=10.1145%2f2541348.2541356&partnerID=40&md5=5678452443043c0e114010aaa0f50c44,"Many of the computer models used in scientific research have been developed in Fortran over many years. This evolutionary process means these models often use deprecated language features and idioms that impede software maintenance, understandability, extension, and verification. To mitigate this, we built CamFort, an open-source automatic refactoring tool for upgrading Fortran source code. We describe functionality in CamFort for removing equivalence statements and common blocks, and for introducing structured data types, and give examples of how these transformations can benefit codebase robustness. Copyright is held by the owner/author(s).",Conference paper,Final,Scopus
